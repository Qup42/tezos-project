(* File generated by the BNF Converter (bnfc 2.9.3). *)

type str = Str of string
and hex = Hex of string
and prog =
   Contract of typ * typ * instr list
 | Code of instr list

and data =
   DInt of inte
 | DStr of str
 | DByte of hex
 | DUnit
 | DTrue
 | DFalse
 | DPair of pair
 | DLeft of data
 | DRight of data
 | DSome of data
 | DNone
 | DBlock of data list
 | DMap of map list
 | DInstruction of instr

and pair =
   DPairSeq1 of data * data
 | DPairSeq2 of data * data list

and map =
   DMapSeq of data * data

and inte =
   DIntPos of int
 | DIntNeg of int

and instr =
   BLOCK of instr list
 | DROP
 | DROP_N of int
 | DUP
 | DUP_N of int
 | SWAP
 | DIG_N of int
 | DUG_N of int
 | PUSH of typ * data
 | SOME
 | NONE of typ
 | UNIT
 | NEVER
 | IF_NONE of instr list * instr list
 | PAIR
 | PAIR_N of int
 | CAR
 | CDR
 | UNPAIR
 | UNPAIR_N of int
 | LEFT of typ
 | RIGHT of typ
 | IF_LEFT of instr list * instr list
 | NIL of typ
 | CONS
 | IF_CONS of instr list * instr list
 | SIZE
 | EMPTY_SET of cTyp
 | EMPTY_MAP of cTyp * typ
 | EMPTY_BIG_MAP of cTyp * typ
 | MAP of instr list
 | ITER of instr list
 | MEM
 | GET
 | GET_N of int
 | UPDATE
 | UPDATE_N of int
 | IF of instr list * instr list
 | LOOP of instr list
 | LOOP_LEFT of instr list
 | LAMBDA of typ * typ * instr list
 | EXEC
 | APPLY
 | DIP of instr list
 | DIP_N of int * instr list
 | FAILWITH
 | CAST
 | RENAME
 | CONCAT
 | SLICE
 | PACK
 | UNPACK of typ
 | ADD
 | SUB
 | MUL
 | EDIC
 | ABS
 | SNAT
 | INT
 | NEG
 | LSL
 | LSR
 | OR
 | AND
 | XOR
 | NOT
 | COMPARE
 | EQ
 | NEQ
 | LT
 | GT
 | LE
 | GE
 | SELF
 | SELF_ADDRESS
 | CONTRACT of typ
 | TRANSFER_TOKENS
 | SET_DELEGATE
 | CREATE_CONTRACT of instr list
 | IMPLICIT_ACCOUNT
 | VOTING_POWER
 | NOW
 | LEVEL
 | AMOUNT
 | BALANCE
 | CHECK_SIGNATURE
 | BLAKE2B
 | KECCAK
 | SHA3
 | SHA256
 | SHA512
 | HASH_KEY
 | SOURCE
 | SENDER
 | ADDRESS
 | CHAIN_ID
 | TOTAL_VOTING_POWER
 | PAIRING_CHECK
 | SAPLING_EMPTY_STATE of int
 | SAPLING_VERIFY_UPDATE
 | TICKET
 | READ_TICKET
 | SPLIT_TICKET
 | JOIN_TICKETS
 | OPEN_CHEST

and typeSeq =
   TTypSeq1 of typ * typ
 | TTypSeq2 of typ * typeSeq

and typ =
   TCtype of cTyp
 | TOperation
 | TContract of typ
 | TOption of typ
 | TList of typ
 | TSet of cTyp
 | TTicket of cTyp
 | TPair of typeSeq
 | TOr of typ * typ
 | TLambda of typ * typ
 | TMap of cTyp * typ
 | TBig_map of cTyp * typ
 | TBls_g1
 | TBls_g2
 | TBls_fr
 | TSapling_transaction of int
 | TSapling_state of int
 | TChest
 | TChest_key

and cTypeSeq =
   CTypSeq1 of cTyp * cTyp
 | CTypSeq2 of cTyp * cTypeSeq

and cTyp =
   CUnit
 | CNever
 | CBool
 | CInt
 | CNat
 | CString
 | CChain_id
 | CBytes
 | CMutez
 | CKey_hash
 | CKey
 | CSignature
 | CTimestamp
 | CAddress
 | COption of cTyp
 | COr of cTyp * cTyp
 | CPair of cTypeSeq

(* defined constructors *)

let m_IFCMPEQ (bt, bf) = BLOCK (COMPARE :: EQ :: (IF (bt, bf)) :: [])
let m_IFCMPNEQ (bt, bf) = BLOCK (COMPARE :: NEQ :: (IF (bt, bf)) :: [])
let m_IFCMPLT (bt, bf) = BLOCK (COMPARE :: LT :: (IF (bt, bf)) :: [])
let m_IFCMPGT (bt, bf) = BLOCK (COMPARE :: GT :: (IF (bt, bf)) :: [])
let m_IFCMPLE (bt, bf) = BLOCK (COMPARE :: LE :: (IF (bt, bf)) :: [])
let m_IFCMPGE (bt, bf) = BLOCK (COMPARE :: GE :: (IF (bt, bf)) :: [])
let m_IF_SOME (bt, bf) = IF_NONE (bt, bf)
