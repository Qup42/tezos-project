{-
    Michelson (L)BNF Grammar to be used with the BNF Converter https://github.com/BNFC/bnfc
    Grammar based on:
    https://tezos.gitlab.io/shell/micheline.html#syntax
    https://tezos.gitlab.io/alpha/michelson.html#full-grammar
-}


-- RULES
comment "#" ; -- line comment

entrypoints Prog ;

-- TODO empty contracts (not) allowed? how many instr needed for minimal contract?
-- TODO "Pair" (parameter, storage) instead of parameter/storage  ?
_.        Prog ::= Prog ";" ; -- allow the ";" in "... code {...};"
Contract. Prog ::= "parameter" Typ ";" "storage" Typ ";" "code" "{" [Instr] "}" ; -- full contract
--Code.     Prog ::= [Instr] ;  -- pure input of (a list of) instructions
--Argument. Prog ::= Data ; -- for input / storage arguments

-- User-Defined regex-based token types
token Str '"' ( (char - ["\"\\"]) | ('\\' ["\"\\rntb"]) )* '"' ; -- should be equivalent to (\" | \r | \n | \t | \b | \\ | [^"\])*
token Hex '0''x' ( digit | ["abcdefABCDEF"] )+ ;
token Nat digit+ ;

-- TODO: add regex for other allowed integer notations like 10_00, 1000.00, ect. --0, +0, -0, 0001
-- TODO: but give this notations other tokens (as strings) to interpret seperately
DIntPos. Inte ::= Integer;
DIntNeg. Inte ::= "-" Integer;


-- Data
separator Data ";" ; -- FIXME muss letztes Data mit ";" abgeschlossen werden? dann zu terminator wechseln
_.               Data         ::= "(" Data ")" ; -- https://tezos.gitlab.io/alpha/michelson.html#format-of-patterns
DInt.            Data         ::= Inte ;
DStr.            Data         ::= Str ;
DBytes.          Data         ::= Hex ;
DUnit.           Data         ::= "Unit" ;
DTrue.           Data         ::= "True" ;
DFalse.          Data         ::= "False" ;
DPair.           Data         ::= "(" "Pair" Data [PairSeq] ")" ; -- FIXME: klammern pflicht?
DLeft.           Data         ::= "(" "Left" Data ")" ;  -- FIXME: klammern pflicht?
DRight.          Data         ::= "(" "Right" Data ")" ;  -- FIXME: klammern pflicht?
DSome.           Data         ::= "Some" Data ;
DNone.           Data         ::= "None" ;
DBlock.          Data         ::= "{" [Data] "}" ;  -- list or set
DMap.            Data         ::= "{" [MapSeq] "}" ;
DInstruction.    Data         ::= Instr ;

terminator nonempty PairSeq "" ;
DPairSeq. PairSeq ::= Data ;
separator MapSeq ";" ;
DMapSeq. MapSeq ::= "Elt" Data Data ;

-- Instructions TODO: seperate into core instructions usw.
separator Instr ";" ; -- empty instruction sequence allowed! Last 'Instr' does does not >need< to be terminated with ';'!
BLOCK.                 Instr ::= "{" [Instr] "}" ;
DROP.                  Instr ::= "DROP" ;
DROP_N.                Instr ::= "DROP" Integer ;
DUP.                   Instr ::= "DUP" ;
DUP_N.                 Instr ::= "DUP" Integer ;
SWAP.                  Instr ::= "SWAP" ;
DIG_N.                 Instr ::= "DIG" Integer ;
DUG_N.                 Instr ::= "DUG" Integer ;
PUSH.                  Instr ::= "PUSH" Typ Data ;
SOME.                  Instr ::= "SOME" ;
NONE.                  Instr ::= "NONE" Typ ;
UNIT.                  Instr ::= "UNIT" ;
NEVER.                 Instr ::= "NEVER" ;
IF_NONE.               Instr ::= "IF_NONE" "{" [Instr] "}" "{" [Instr] "}" ;
PAIR.                  Instr ::= "PAIR" ;
PAIR_N.                Instr ::= "PAIR" Integer ;
CAR.                   Instr ::= "CAR" ;
CDR.                   Instr ::= "CDR" ;
UNPAIR.                Instr ::= "UNPAIR" ;
UNPAIR_N.              Instr ::= "UNPAIR" Integer ;
LEFT.                  Instr ::= "LEFT" Typ ;
RIGHT.                 Instr ::= "RIGHT" Typ ;
IF_LEFT.               Instr ::= "IF_LEFT" "{" [Instr] "}" "{" [Instr] "}" ;
NIL.                   Instr ::= "NIL" Typ ;
CONS.                  Instr ::= "CONS" ;
IF_CONS.               Instr ::= "IF_CONS" "{" [Instr] "}" "{" [Instr] "}" ;
SIZE.                  Instr ::= "SIZE" ;
EMPTY_SET.             Instr ::= "EMPTY_SET" CTyp ;
EMPTY_MAP.             Instr ::= "EMPTY_MAP" CTyp Typ ;
EMPTY_BIG_MAP.         Instr ::= "EMPTY_BIG_MAP" CTyp Typ ;
MAP.                   Instr ::= "MAP" "{" [Instr] "}" ;
ITER.                  Instr ::= "ITER" "{" [Instr] "}" ;
MEM.                   Instr ::= "MEM" ;
GET.                   Instr ::= "GET" ;
GET_N.                 Instr ::= "GET" Integer ;
UPDATE.                Instr ::= "UPDATE" ;
UPDATE_N.              Instr ::= "UPDATE" Integer ;
IF.                    Instr ::= "IF" "{" [Instr] "}" "{" [Instr] "}" ;
LOOP.                  Instr ::= "LOOP" "{" [Instr] "}" ;
LOOP_LEFT.             Instr ::= "LOOP_LEFT" "{" [Instr] "}" ;
LAMBDA.                Instr ::= "LAMBDA" Typ Typ "{" [Instr] "}" ;
EXEC.                  Instr ::= "EXEC" ;
APPLY.                 Instr ::= "APPLY" ;
DIP.                   Instr ::= "DIP" "{" [Instr] "}" ;
DIP_N.                 Instr ::= "DIP" Integer "{" [Instr] "}" ;
FAILWITH.              Instr ::= "FAILWITH" ;
CAST.                  Instr ::= "CAST" ;
RENAME.                Instr ::= "RENAME" ;
CONCAT.                Instr ::= "CONCAT" ;
SLICE.                 Instr ::= "SLICE" ;
PACK.                  Instr ::= "PACK" ;
UNPACK.                Instr ::= "UNPACK" Typ ;
ADD.                   Instr ::= "ADD" ;
SUB.                   Instr ::= "SUB" ;
MUL.                   Instr ::= "MUL" ;
EDIV.                  Instr ::= "EDIV" ;
ABS.                   Instr ::= "ABS" ;
SNAT.                  Instr ::= "ISNAT" ;
INT.                   Instr ::= "INT" ;
NEG.                   Instr ::= "NEG" ;
LSL.                   Instr ::= "LSL" ;
LSR.                   Instr ::= "LSR" ;
OR.                    Instr ::= "OR" ;
AND.                   Instr ::= "AND" ;
XOR.                   Instr ::= "XOR" ;
NOT.                   Instr ::= "NOT" ;
COMPARE.               Instr ::= "COMPARE" ;
EQ.                    Instr ::= "EQ" ;
NEQ.                   Instr ::= "NEQ" ;
LT.                    Instr ::= "LT" ;
GT.                    Instr ::= "GT" ;
LE.                    Instr ::= "LE" ;
GE.                    Instr ::= "GE" ;
SELF.                  Instr ::= "SELF" ;
SELF_ADDRESS.          Instr ::= "SELF_ADDRESS" ;
CONTRACT.              Instr ::= "CONTRACT" Typ ;
TRANSFER_TOKENS.       Instr ::= "TRANSFER_TOKENS" ;
SET_DELEGATE.          Instr ::= "SET_DELEGATE" ;
CREATE_CONTRACT.       Instr ::= "CREATE_CONTRACT" "{" [Instr] "}" ;
IMPLICIT_ACCOUNT.      Instr ::= "IMPLICIT_ACCOUNT" ;
VOTING_POWER.          Instr ::= "VOTING_POWER" ;
NOW.                   Instr ::= "NOW" ;
LEVEL.                 Instr ::= "LEVEL" ;
AMOUNT.                Instr ::= "AMOUNT" ;
BALANCE.               Instr ::= "BALANCE" ;
CHECK_SIGNATURE.       Instr ::= "CHECK_SIGNATURE" ;
BLAKE2B.               Instr ::= "BLAKE2B" ;
KECCAK.                Instr ::= "KECCAK" ;
SHA3.                  Instr ::= "SHA3" ;
SHA256.                Instr ::= "SHA256" ;
SHA512.                Instr ::= "SHA512" ;
HASH_KEY.              Instr ::= "HASH_KEY" ;
SOURCE.                Instr ::= "SOURCE" ;
SENDER.                Instr ::= "SENDER" ;
ADDRESS.               Instr ::= "ADDRESS" ;
CHAIN_ID.              Instr ::= "CHAIN_ID" ;
TOTAL_VOTING_POWER.    Instr ::= "TOTAL_VOTING_POWER" ;
PAIRING_CHECK.         Instr ::= "PAIRING_CHECK" ;
SAPLING_EMPTY_STATE.   Instr ::= "SAPLING_EMPTY_STATE" Integer ; -- TODO: https://gitlab.com/morley-framework/morley/-/issues/380  SAPPLING NOT NEEDED?
SAPLING_VERIFY_UPDATE. Instr ::= "SAPLING_VERIFY_UPDATE" ;
TICKET.                Instr ::= "TICKET" ;
READ_TICKET.           Instr ::= "READ_TICKET" ;
SPLIT_TICKET.          Instr ::= "SPLIT_TICKET" ;
JOIN_TICKETS.          Instr ::= "JOIN_TICKETS" ;
OPEN_CHEST.            Instr ::= "OPEN_CHEST" ;

-- MACRO INSTRUCTIONS
-- Fail
m_FAIL.     Instr ::= "FAIL" ;
define m_FAIL = BLOCK[UNIT, FAILWITH] ;  -- TODO: BLOCK is equivalent to "{" [Instr] "}". Is there a solution without (ask support)?
-- Compare
m_CMPEQ.    Instr ::= "CMPEQ" ;
m_CMPNEQ.   Instr ::= "CMPNEQ" ;
m_CMPLT.    Instr ::= "CMPLT" ;
m_CMPGT.    Instr ::= "CMPGT" ;
m_CMPLE.    Instr ::= "CMPLE" ;
m_CMPGE.    Instr ::= "CMPGE" ;
m_IFEQ.     Instr ::= "IFEQ" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFNEQ.    Instr ::= "IFNEQ" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFLT.     Instr ::= "IFLT" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFGT.     Instr ::= "IFGT" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFLE.     Instr ::= "IFLE" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFGE.     Instr ::= "IFGE" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFCMPEQ.  Instr ::= "IFCMPEQ" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFCMPNEQ. Instr ::= "IFCMPNEQ" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFCMPLT.  Instr ::= "IFCMPLT" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFCMPGT.  Instr ::= "IFCMPGT" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFCMPLE.  Instr ::= "IFCMPLE" "{" [Instr] "}" "{" [Instr] "}" ;
m_IFCMPGE.  Instr ::= "IFCMPGE" "{" [Instr] "}" "{" [Instr] "}" ;
define m_CMPEQ          = BLOCK[COMPARE, EQ] ;
define m_CMPNEQ         = BLOCK[COMPARE, NEQ] ;
define m_CMPLT          = BLOCK[COMPARE, LT] ;
define m_CMPGT          = BLOCK[COMPARE, GT] ;
define m_CMPLE          = BLOCK[COMPARE, LE] ;
define m_CMPGE          = BLOCK[COMPARE, GE] ;
define m_IFEQ bt bf     = BLOCK[EQ, (IF bt bf)] ;
define m_IFNEQ bt bf    = BLOCK[NEQ, (IF bt bf)] ;
define m_IFLT bt bf     = BLOCK[LT, (IF bt bf)] ;
define m_IFGT bt bf     = BLOCK[GT, (IF bt bf)] ;
define m_IFLE bt bf     = BLOCK[LE, (IF bt bf)] ;
define m_IFGE bt bf     = BLOCK[GE, (IF bt bf)] ;
define m_IFCMPEQ  bt bf = BLOCK[m_CMPEQ, (IF bt bf)] ;
define m_IFCMPNEQ bt bf = BLOCK[m_CMPNEQ, (IF bt bf)] ;
define m_IFCMPLT bt bf  = BLOCK[m_CMPLT, (IF bt bf)] ;
define m_IFCMPGT bt bf  = BLOCK[m_CMPGT, (IF bt bf)] ;
define m_IFCMPLE bt bf  = BLOCK[m_CMPLE, (IF bt bf)] ;
define m_IFCMPGE bt bf  = BLOCK[m_CMPGE, (IF bt bf)] ;
-- Assertions
m_ASSERT.        Instr ::= "ASSERT" ;
m_ASSERT_EQ.     Instr ::= "ASSERT_EQ" ;
m_ASSERT_NEQ.    Instr ::= "ASSERT_NEQ" ;
m_ASSERT_LT.     Instr ::= "ASSERT_LT" ;
m_ASSERT_GT.     Instr ::= "ASSERT_GT" ;
m_ASSERT_LE.     Instr ::= "ASSERT_LE" ;
m_ASSERT_GE.     Instr ::= "ASSERT_GE" ;
m_ASSERT_CMPEQ.  Instr ::= "ASSERT_CMPEQ" ;
m_ASSERT_CMPNEQ. Instr ::= "ASSERT_CMPNEQ" ;
m_ASSERT_CMPLT.  Instr ::= "ASSERT_CMPLT" ;
m_ASSERT_CMPGT.  Instr ::= "ASSERT_CMPGT" ;
m_ASSERT_CMPLE.  Instr ::= "ASSERT_CMPLE" ;
m_ASSERT_CMPGE.  Instr ::= "ASSERT_CMPGE" ;
m_ASSERT_NONE.   Instr ::= "ASSERT_NONE" ;
m_ASSERT_SOME.   Instr ::= "ASSERT_SOME" ;
m_ASSERT_LEFT.   Instr ::= "ASSERT_LEFT" ;
m_ASSERT_RIGHT.  Instr ::= "ASSERT_RIGHT" ;
define m_ASSERT        = (IF [] [m_FAIL]) ;
define m_ASSERT_EQ     = (m_IFEQ [] [m_FAIL]) ;
define m_ASSERT_NEQ    = (m_IFNEQ [] [m_FAIL]) ;
define m_ASSERT_LT     = (m_IFLT [] [m_FAIL]) ;
define m_ASSERT_GT     = (m_IFGT [] [m_FAIL]) ;
define m_ASSERT_LE     = (m_IFLE [] [m_FAIL]) ;
define m_ASSERT_GE     = (m_IFGE [] [m_FAIL]) ;
define m_ASSERT_CMPEQ  = (m_IFCMPEQ [] [m_FAIL]) ;
define m_ASSERT_CMPNEQ = (m_IFCMPNEQ [] [m_FAIL]) ;
define m_ASSERT_CMPLT  = (m_IFCMPLT [] [m_FAIL]) ;
define m_ASSERT_CMPGT  = (m_IFCMPGT [] [m_FAIL]) ;
define m_ASSERT_CMPLE  = (m_IFCMPLE [] [m_FAIL]) ;
define m_ASSERT_CMPGE  = (m_IFCMPGE [] [m_FAIL]) ;
define m_ASSERT_NONE   = (IF_NONE [] [m_FAIL]) ;
define m_ASSERT_SOME   = (IF_NONE [m_FAIL] [RENAME]) ; -- FIXME missing annotations
define m_ASSERT_LEFT   = (IF_LEFT [RENAME] [m_FAIL]) ; -- FIXME missing annotations
define m_ASSERT_RIGHT  = (IF_LEFT [m_FAIL] [RENAME]) ; -- FIXME missing annotations
-- Syntactic Conveniences
-- P(\left=A|P(\left)(\right))(\right=I|P(\left)(\right))R
-- UNP(\left=A|P(\left)(\right))(\right=I|P(\left)(\right))R
-- C[AD]+R
-- m_CAR_K.
-- m_CDR_K.
m_IF_SOME.  Instr ::= "IF_SOME" "{" [Instr] "}" "{" [Instr] "}" ;
define m_IF_SOME  bt bf = IF_NONE bt bf ;
m_IF_RIGHT. Instr ::= "IF_RIGHT" "{" [Instr] "}" "{" [Instr] "}" ;
define m_IF_RIGHT bt bf = IF_LEFT bf bt ;
-- m_SET_CAR.
-- m_SET_CDR.
-- SET_C[AD]+R
-- m_MAP_CAR.
-- m_MAP_CDR.
-- MAP_C[AD]+R



-- ANNOTATIONS
-- possibly just remove them?
-- Type annotations
-- Variable annotations
-- Field and constructor annotations
-- Syntax
-- Annotations and macros
-- Special annotations

-- Views

-- Entrypoints

-- Types
_.                    Typ ::= "(" Typ ")" ;
TCtype.               Typ ::= CTyp ;  -- TODO: drop token in interpreter (it seems not possible to stop the token from beeing created)
TOperation.           Typ ::= "operation" ;
TContract.            Typ ::= "contract" Typ ;
TOption.              Typ ::= "option" Typ ;
TList.                Typ ::= "list" Typ ;
TSet.                 Typ ::= "set" CTyp ;
TTicket.              Typ ::= "ticket" CTyp ;
TPair.                Typ ::= "(" "pair" Typ [TypeSeq] ")"; -- FIXME: Klammern pflicht oder nicht?
TOr.                  Typ ::= "or" Typ Typ ;
TLambda.              Typ ::= "lambda" Typ Typ ;
TMap.                 Typ ::= "map" CTyp Typ ;
TBig_map.             Typ ::= "big_map" CTyp Typ ;
TBls_381_g1.          Typ ::= "bls12_381_g1" ;
TBls_381_g2.          Typ ::= "bls12_381_g2" ;
TBls_381_fr.          Typ ::= "bls12_381_fr" ;
TSapling_transaction. Typ ::= "sapling_transaction" Integer ;
TSapling_state.       Typ ::= "sapling_state" Integer ;
TChest.               Typ ::= "chest" ;
TChest_key.           Typ ::= "chest_key" ;
terminator nonempty TypeSeq "" ;
TypeSeq0. TypeSeq ::= Typ ;
--TTypSeq1.             TypeSeq  ::= Typ Typ ;
--TTypSeq2.             TypeSeq  ::= Typ TypeSeq ;

-- Comparable Types

CUnit.      CTyp ::= "unit" ;
CNever.     CTyp ::= "never" ;
CBool.      CTyp ::= "bool" ;
CInt.       CTyp ::= "int" ;
CNat.       CTyp ::= "nat" ;
CString.    CTyp ::= "string" ;
CChain_id.  CTyp ::= "chain_id" ;
CBytes.     CTyp ::= "bytes" ;
CMutez.     CTyp ::= "mutez" ;
CKey_hash.  CTyp ::= "key_hash" ;
CKey.       CTyp ::= "key" ;
CSignature. CTyp ::= "signature" ;
CTimestamp. CTyp ::= "timestamp" ;
CAddress.   CTyp ::= "address" ;
COption.    CTyp ::= "option" CTyp ;
COr.        CTyp ::= "or" CTyp CTyp ;
CPair.      CTyp ::= "(" "pair" CTyp [CTypeSeq] ")" ;
terminator nonempty CTypeSeq "" ;
CTypeSeq0. CTypeSeq ::= CTyp ;
--CTypSeq1.   CTypeSeq ::= CTyp CTyp ;
--CTypSeq2.   CTypeSeq ::= CTyp CTypeSeq ;