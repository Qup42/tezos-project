-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Michelson.Par
  ( happyError
  , myLexer
  , pProg
  ) where

import Prelude

import qualified Michelson.Abs
import Michelson.Lex

}

%name pProg Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  ';'                     { PT _ (TS _ 1)   }
  'ABS'                   { PT _ (TS _ 2)   }
  'ADD'                   { PT _ (TS _ 3)   }
  'ADDRESS'               { PT _ (TS _ 4)   }
  'AMOUNT'                { PT _ (TS _ 5)   }
  'AND'                   { PT _ (TS _ 6)   }
  'APPLY'                 { PT _ (TS _ 7)   }
  'BALANCE'               { PT _ (TS _ 8)   }
  'BLAKE2B'               { PT _ (TS _ 9)   }
  'CAR'                   { PT _ (TS _ 10)  }
  'CAST'                  { PT _ (TS _ 11)  }
  'CDR'                   { PT _ (TS _ 12)  }
  'CHAIN_ID'              { PT _ (TS _ 13)  }
  'CHECK_SIGNATURE'       { PT _ (TS _ 14)  }
  'COMPARE'               { PT _ (TS _ 15)  }
  'CONCAT'                { PT _ (TS _ 16)  }
  'CONS'                  { PT _ (TS _ 17)  }
  'CONTRACT'              { PT _ (TS _ 18)  }
  'CREATE_CONTRACT'       { PT _ (TS _ 19)  }
  'DIG'                   { PT _ (TS _ 20)  }
  'DIP'                   { PT _ (TS _ 21)  }
  'DROP'                  { PT _ (TS _ 22)  }
  'DUG'                   { PT _ (TS _ 23)  }
  'DUP'                   { PT _ (TS _ 24)  }
  'EDIV'                  { PT _ (TS _ 25)  }
  'EMPTY_BIG_MAP'         { PT _ (TS _ 26)  }
  'EMPTY_MAP'             { PT _ (TS _ 27)  }
  'EMPTY_SET'             { PT _ (TS _ 28)  }
  'EQ'                    { PT _ (TS _ 29)  }
  'EXEC'                  { PT _ (TS _ 30)  }
  'Elt'                   { PT _ (TS _ 31)  }
  'FAILWITH'              { PT _ (TS _ 32)  }
  'False'                 { PT _ (TS _ 33)  }
  'GE'                    { PT _ (TS _ 34)  }
  'GET'                   { PT _ (TS _ 35)  }
  'GT'                    { PT _ (TS _ 36)  }
  'HASH_KEY'              { PT _ (TS _ 37)  }
  'IF'                    { PT _ (TS _ 38)  }
  'IF_CONS'               { PT _ (TS _ 39)  }
  'IF_LEFT'               { PT _ (TS _ 40)  }
  'IF_NONE'               { PT _ (TS _ 41)  }
  'IMPLICIT_ACCOUNT'      { PT _ (TS _ 42)  }
  'INT'                   { PT _ (TS _ 43)  }
  'ISNAT'                 { PT _ (TS _ 44)  }
  'ITER'                  { PT _ (TS _ 45)  }
  'JOIN_TICKETS'          { PT _ (TS _ 46)  }
  'KECCAK'                { PT _ (TS _ 47)  }
  'LAMBDA'                { PT _ (TS _ 48)  }
  'LE'                    { PT _ (TS _ 49)  }
  'LEFT'                  { PT _ (TS _ 50)  }
  'LEVEL'                 { PT _ (TS _ 51)  }
  'LOOP'                  { PT _ (TS _ 52)  }
  'LOOP_LEFT'             { PT _ (TS _ 53)  }
  'LSL'                   { PT _ (TS _ 54)  }
  'LSR'                   { PT _ (TS _ 55)  }
  'LT'                    { PT _ (TS _ 56)  }
  'Left'                  { PT _ (TS _ 57)  }
  'MAP'                   { PT _ (TS _ 58)  }
  'MEM'                   { PT _ (TS _ 59)  }
  'MUL'                   { PT _ (TS _ 60)  }
  'NEG'                   { PT _ (TS _ 61)  }
  'NEQ'                   { PT _ (TS _ 62)  }
  'NEVER'                 { PT _ (TS _ 63)  }
  'NIL'                   { PT _ (TS _ 64)  }
  'NONE'                  { PT _ (TS _ 65)  }
  'NOT'                   { PT _ (TS _ 66)  }
  'NOW'                   { PT _ (TS _ 67)  }
  'None'                  { PT _ (TS _ 68)  }
  'OPEN_CHEST'            { PT _ (TS _ 69)  }
  'OR'                    { PT _ (TS _ 70)  }
  'PACK'                  { PT _ (TS _ 71)  }
  'PAIR'                  { PT _ (TS _ 72)  }
  'PAIRING_CHECK'         { PT _ (TS _ 73)  }
  'PUSH'                  { PT _ (TS _ 74)  }
  'Pair'                  { PT _ (TS _ 75)  }
  'READ_TICKET'           { PT _ (TS _ 76)  }
  'RENAME'                { PT _ (TS _ 77)  }
  'RIGHT'                 { PT _ (TS _ 78)  }
  'Right'                 { PT _ (TS _ 79)  }
  'SAPLING_EMPTY_STATE'   { PT _ (TS _ 80)  }
  'SAPLING_VERIFY_UPDATE' { PT _ (TS _ 81)  }
  'SELF'                  { PT _ (TS _ 82)  }
  'SELF_ADDRESS'          { PT _ (TS _ 83)  }
  'SENDER'                { PT _ (TS _ 84)  }
  'SET_DELEGATE'          { PT _ (TS _ 85)  }
  'SHA256'                { PT _ (TS _ 86)  }
  'SHA3'                  { PT _ (TS _ 87)  }
  'SHA512'                { PT _ (TS _ 88)  }
  'SIZE'                  { PT _ (TS _ 89)  }
  'SLICE'                 { PT _ (TS _ 90)  }
  'SOME'                  { PT _ (TS _ 91)  }
  'SOURCE'                { PT _ (TS _ 92)  }
  'SPLIT_TICKET'          { PT _ (TS _ 93)  }
  'SUB'                   { PT _ (TS _ 94)  }
  'SWAP'                  { PT _ (TS _ 95)  }
  'Some'                  { PT _ (TS _ 96)  }
  'TICKET'                { PT _ (TS _ 97)  }
  'TOTAL_VOTING_POWER'    { PT _ (TS _ 98)  }
  'TRANSFER_TOKENS'       { PT _ (TS _ 99)  }
  'True'                  { PT _ (TS _ 100) }
  'UNIT'                  { PT _ (TS _ 101) }
  'UNPACK'                { PT _ (TS _ 102) }
  'UNPAIR'                { PT _ (TS _ 103) }
  'UPDATE'                { PT _ (TS _ 104) }
  'Unit'                  { PT _ (TS _ 105) }
  'VOTING_POWER'          { PT _ (TS _ 106) }
  'XOR'                   { PT _ (TS _ 107) }
  'address'               { PT _ (TS _ 108) }
  'big_map'               { PT _ (TS _ 109) }
  'bls12_381_fr'          { PT _ (TS _ 110) }
  'bls12_381_g1'          { PT _ (TS _ 111) }
  'bls12_381_g2'          { PT _ (TS _ 112) }
  'bool'                  { PT _ (TS _ 113) }
  'bytes'                 { PT _ (TS _ 114) }
  'chain_id'              { PT _ (TS _ 115) }
  'chest'                 { PT _ (TS _ 116) }
  'chest_key'             { PT _ (TS _ 117) }
  'contract'              { PT _ (TS _ 118) }
  'int'                   { PT _ (TS _ 119) }
  'key'                   { PT _ (TS _ 120) }
  'key_hash'              { PT _ (TS _ 121) }
  'lambda'                { PT _ (TS _ 122) }
  'list'                  { PT _ (TS _ 123) }
  'map'                   { PT _ (TS _ 124) }
  'mutez'                 { PT _ (TS _ 125) }
  'nat'                   { PT _ (TS _ 126) }
  'never'                 { PT _ (TS _ 127) }
  'operation'             { PT _ (TS _ 128) }
  'option'                { PT _ (TS _ 129) }
  'or'                    { PT _ (TS _ 130) }
  'pair'                  { PT _ (TS _ 131) }
  'sapling_state'         { PT _ (TS _ 132) }
  'sapling_transaction'   { PT _ (TS _ 133) }
  'set'                   { PT _ (TS _ 134) }
  'signature'             { PT _ (TS _ 135) }
  'string'                { PT _ (TS _ 136) }
  'ticket'                { PT _ (TS _ 137) }
  'timestamp'             { PT _ (TS _ 138) }
  'unit'                  { PT _ (TS _ 139) }
  '{'                     { PT _ (TS _ 140) }
  '}'                     { PT _ (TS _ 141) }
  L_Nat                   { PT _ (T_Nat $$) }
  L_Int                   { PT _ (T_Int $$) }
  L_Str                   { PT _ (T_Str $$) }
  L_Hex                   { PT _ (T_Hex $$) }

%%

Nat :: { Michelson.Abs.Nat }
Nat  : L_Nat { Michelson.Abs.Nat $1 }

Int :: { Michelson.Abs.Int }
Int  : L_Int { Michelson.Abs.Int $1 }

Str :: { Michelson.Abs.Str }
Str  : L_Str { Michelson.Abs.Str $1 }

Hex :: { Michelson.Abs.Hex }
Hex  : L_Hex { Michelson.Abs.Hex $1 }

Prog :: { Michelson.Abs.Prog }
Prog : Instr ';' ListInstr { Michelson.Abs.Code $1 $3 }

ListData :: { [Michelson.Abs.Data] }
ListData : {- empty -} { [] } | Data ';' ListData { (:) $1 $3 }

PairSeq :: { Michelson.Abs.PairSeq }
PairSeq
  : Data Data { Michelson.Abs.DPairSeq1 $1 $2 }
  | Data PairSeq { Michelson.Abs.DPairSeq2 $1 $2 }

MapSeq :: { Michelson.Abs.MapSeq }
MapSeq
  : 'Elt' Data Data ';' { Michelson.Abs.DMapSeq1 $2 $3 }
  | 'Elt' Data Data ';' MapSeq { Michelson.Abs.DMapSeq2 $2 $3 $5 }

Data :: { Michelson.Abs.Data }
Data
  : Int { Michelson.Abs.DInt $1 }
  | Str { Michelson.Abs.DStr $1 }
  | Hex { Michelson.Abs.DByte $1 }
  | 'Unit' { Michelson.Abs.DUnit }
  | 'True' { Michelson.Abs.DTrue }
  | 'False' { Michelson.Abs.DFalse }
  | 'Pair' PairSeq { Michelson.Abs.DPair2 $2 }
  | 'Left' Data { Michelson.Abs.DLeft $2 }
  | 'Right' Data { Michelson.Abs.DRight $2 }
  | 'Some' Data { Michelson.Abs.DSome $2 }
  | 'None' { Michelson.Abs.DNone }
  | '{' ListData '}' { Michelson.Abs.DBlock $2 }
  | '{' MapSeq '}' { Michelson.Abs.DMap $2 }
  | Instr { Michelson.Abs.DInstr $1 }

ListInstr :: { [Michelson.Abs.Instr] }
ListInstr
  : {- empty -} { [] }
  | Instr { (:[]) $1 }
  | Instr ';' ListInstr { (:) $1 $3 }

Instr :: { Michelson.Abs.Instr }
Instr
  : Instr ';' { $1 }
  | '{' ListInstr '}' { Michelson.Abs.IBLOCK $2 }
  | 'DROP' { Michelson.Abs.IDROP }
  | 'DROP' Nat { Michelson.Abs.IDROP_N $2 }
  | 'DUP' { Michelson.Abs.IDUP }
  | 'DUP' Nat { Michelson.Abs.IDUP_N $2 }
  | 'SWAP' { Michelson.Abs.ISWAP }
  | 'DIG' Nat { Michelson.Abs.IDIG_N $2 }
  | 'DUG' Nat { Michelson.Abs.IDUG_N $2 }
  | 'PUSH' Typ Data { Michelson.Abs.IPUSH $2 $3 }
  | 'SOME' { Michelson.Abs.ISOME }
  | 'NONE' Typ { Michelson.Abs.INONE $2 }
  | 'UNIT' { Michelson.Abs.IUNIT }
  | 'NEVER' { Michelson.Abs.INEVER }
  | 'IF_NONE' '{' ListInstr '}' '{' ListInstr '}' { Michelson.Abs.IIF_NONE $3 $6 }
  | 'PAIR' { Michelson.Abs.IPAIR }
  | 'PAIR' Nat { Michelson.Abs.IPAIR_N $2 }
  | 'CAR' { Michelson.Abs.ICAR }
  | 'CDR' { Michelson.Abs.ICDR }
  | 'UNPAIR' { Michelson.Abs.IUNPAIR }
  | 'UNPAIR' Nat { Michelson.Abs.IUNPAIR_N $2 }
  | 'LEFT' Typ { Michelson.Abs.ILEFT $2 }
  | 'RIGHT' Typ { Michelson.Abs.IRIGHT $2 }
  | 'IF_LEFT' '{' ListInstr '}' '{' ListInstr '}' { Michelson.Abs.IIF_LEFT $3 $6 }
  | 'NIL' Typ { Michelson.Abs.INIL $2 }
  | 'CONS' { Michelson.Abs.ICONS }
  | 'IF_CONS' '{' ListInstr '}' '{' ListInstr '}' { Michelson.Abs.IIF_CONS $3 $6 }
  | 'SIZE' { Michelson.Abs.ISIZE }
  | 'EMPTY_SET' CTyp { Michelson.Abs.IEMPTY_SET $2 }
  | 'EMPTY_MAP' CTyp Typ { Michelson.Abs.IEMPTY_MAP $2 $3 }
  | 'EMPTY_BIG_MAP' CTyp Typ { Michelson.Abs.IEMPTY_BIG_MAP $2 $3 }
  | 'MAP' '{' ListInstr '}' { Michelson.Abs.IMAP $3 }
  | 'ITER' '{' ListInstr '}' { Michelson.Abs.IITER $3 }
  | 'MEM' { Michelson.Abs.IMEM }
  | 'GET' { Michelson.Abs.IGET }
  | 'GET' Nat { Michelson.Abs.IGET_N $2 }
  | 'UPDATE' { Michelson.Abs.IUPDATE }
  | 'UPDATE' Nat { Michelson.Abs.IUPDATE_N $2 }
  | 'IF' '{' ListInstr '}' '{' ListInstr '}' { Michelson.Abs.IIF $3 $6 }
  | 'LOOP' '{' ListInstr '}' { Michelson.Abs.ILOOP $3 }
  | 'LOOP_LEFT' '{' ListInstr '}' { Michelson.Abs.ILOOP_LEFT $3 }
  | 'LAMBDA' Typ Typ '{' ListInstr '}' { Michelson.Abs.ILAMBDA $2 $3 $5 }
  | 'EXEC' { Michelson.Abs.IEXEC }
  | 'APPLY' { Michelson.Abs.IAPPLY }
  | 'DIP' '{' ListInstr '}' { Michelson.Abs.IDIP $3 }
  | 'DIP' Nat '{' ListInstr '}' { Michelson.Abs.IDIP_N $2 $4 }
  | 'FAILWITH' { Michelson.Abs.IFAILWITH }
  | 'CAST' { Michelson.Abs.ICAST }
  | 'RENAME' { Michelson.Abs.IRENAME }
  | 'CONCAT' { Michelson.Abs.ICONCAT }
  | 'SLICE' { Michelson.Abs.ISLICE }
  | 'PACK' { Michelson.Abs.IPACK }
  | 'UNPACK' Typ { Michelson.Abs.IUNPACK $2 }
  | 'ADD' { Michelson.Abs.IADD }
  | 'SUB' { Michelson.Abs.ISUB }
  | 'MUL' { Michelson.Abs.IMUL }
  | 'EDIV' { Michelson.Abs.IEDIC }
  | 'ABS' { Michelson.Abs.IABS }
  | 'ISNAT' { Michelson.Abs.ISNAT }
  | 'INT' { Michelson.Abs.IINT }
  | 'NEG' { Michelson.Abs.INEG }
  | 'LSL' { Michelson.Abs.ILSL }
  | 'LSR' { Michelson.Abs.ILSR }
  | 'OR' { Michelson.Abs.IOR }
  | 'AND' { Michelson.Abs.IAND }
  | 'XOR' { Michelson.Abs.IXOR }
  | 'NOT' { Michelson.Abs.INOT }
  | 'COMPARE' { Michelson.Abs.ICOMPARE }
  | 'EQ' { Michelson.Abs.IEQ }
  | 'NEQ' { Michelson.Abs.INEQ }
  | 'LT' { Michelson.Abs.ILT }
  | 'GT' { Michelson.Abs.IGT }
  | 'LE' { Michelson.Abs.ILE }
  | 'GE' { Michelson.Abs.IGE }
  | 'SELF' { Michelson.Abs.ISELF }
  | 'SELF_ADDRESS' { Michelson.Abs.ISELF_ADDRESS }
  | 'CONTRACT' Typ { Michelson.Abs.ICONTRACT $2 }
  | 'TRANSFER_TOKENS' { Michelson.Abs.ITRANSFER_TOKENS }
  | 'SET_DELEGATE' { Michelson.Abs.ISET_DELEGATE }
  | 'CREATE_CONTRACT' '{' ListInstr '}' { Michelson.Abs.ICREATE_CONTRACT $3 }
  | 'IMPLICIT_ACCOUNT' { Michelson.Abs.IIMPLICIT_ACCOUNT }
  | 'VOTING_POWER' { Michelson.Abs.IVOTING_POWER }
  | 'NOW' { Michelson.Abs.INOW }
  | 'LEVEL' { Michelson.Abs.ILEVEL }
  | 'AMOUNT' { Michelson.Abs.IAMOUNT }
  | 'BALANCE' { Michelson.Abs.IBALANCE }
  | 'CHECK_SIGNATURE' { Michelson.Abs.ICHECK_SIGNATURE }
  | 'BLAKE2B' { Michelson.Abs.IBLAKE2B }
  | 'KECCAK' { Michelson.Abs.IKECCAK }
  | 'SHA3' { Michelson.Abs.ISHA3 }
  | 'SHA256' { Michelson.Abs.ISHA256 }
  | 'SHA512' { Michelson.Abs.ISHA512 }
  | 'HASH_KEY' { Michelson.Abs.IHASH_KEY }
  | 'SOURCE' { Michelson.Abs.ISOURCE }
  | 'SENDER' { Michelson.Abs.ISENDER }
  | 'ADDRESS' { Michelson.Abs.IADDRESS }
  | 'CHAIN_ID' { Michelson.Abs.ICHAIN_ID }
  | 'TOTAL_VOTING_POWER' { Michelson.Abs.ITOTAL_VOTING_POWER }
  | 'PAIRING_CHECK' { Michelson.Abs.IPAIRING_CHECK }
  | 'SAPLING_EMPTY_STATE' Nat { Michelson.Abs.ISAPLING_EMPTY_STATE $2 }
  | 'SAPLING_VERIFY_UPDATE' { Michelson.Abs.ISAPLING_VERIFY_UPDATE }
  | 'TICKET' { Michelson.Abs.ITICKET }
  | 'READ_TICKET' { Michelson.Abs.IREAD_TICKET }
  | 'SPLIT_TICKET' { Michelson.Abs.ISPLIT_TICKET }
  | 'JOIN_TICKETS' { Michelson.Abs.IJOIN_TICKETS }
  | 'OPEN_CHEST' { Michelson.Abs.IOPEN_CHEST }

TypeSeq :: { Michelson.Abs.TypeSeq }
TypeSeq
  : Typ Typ { Michelson.Abs.TTypSeq1 $1 $2 }
  | Typ TypeSeq { Michelson.Abs.TTypSeq2 $1 $2 }

Typ :: { Michelson.Abs.Typ }
Typ
  : CTyp { Michelson.Abs.TCtype $1 }
  | 'option' Typ { Michelson.Abs.TOption $2 }
  | 'list' Typ { Michelson.Abs.TList $2 }
  | 'set' CTyp { Michelson.Abs.TSet $2 }
  | 'operation' { Michelson.Abs.TOperation }
  | 'contract' Typ { Michelson.Abs.TContract $2 }
  | 'ticket' CTyp { Michelson.Abs.TTicket $2 }
  | 'pair' TypeSeq { Michelson.Abs.TPair $2 }
  | 'or' Typ Typ { Michelson.Abs.TOr $2 $3 }
  | 'lambda' Typ Typ { Michelson.Abs.TLambda $2 $3 }
  | 'map' CTyp Typ { Michelson.Abs.TMap $2 $3 }
  | 'big_map' CTyp Typ { Michelson.Abs.TBig_map $2 $3 }
  | 'bls12_381_g1' { Michelson.Abs.TBls_g1 }
  | 'bls12_381_g2' { Michelson.Abs.TBls_g2 }
  | 'bls12_381_fr' { Michelson.Abs.TBls_fr }
  | 'sapling_transaction' Nat { Michelson.Abs.TSapling_transaction $2 }
  | 'sapling_state' Nat { Michelson.Abs.TSapling_state $2 }
  | 'chest' { Michelson.Abs.TChest }
  | 'chest_key' { Michelson.Abs.TChest_key }

CTypeSeq :: { Michelson.Abs.CTypeSeq }
CTypeSeq
  : CTyp CTyp { Michelson.Abs.CTypSeq1 $1 $2 }
  | CTyp CTypeSeq { Michelson.Abs.CTypSeq2 $1 $2 }

CTyp :: { Michelson.Abs.CTyp }
CTyp
  : 'unit' { Michelson.Abs.CUnit }
  | 'never' { Michelson.Abs.CNever }
  | 'bool' { Michelson.Abs.CBool }
  | 'int' { Michelson.Abs.CInt }
  | 'nat' { Michelson.Abs.CNat }
  | 'string' { Michelson.Abs.CString }
  | 'chain_id' { Michelson.Abs.CChain_id }
  | 'bytes' { Michelson.Abs.CBytes }
  | 'mutez' { Michelson.Abs.CMutez }
  | 'key_hash' { Michelson.Abs.CKey_hash }
  | 'key' { Michelson.Abs.CKey }
  | 'signature' { Michelson.Abs.CSignature }
  | 'timestamp' { Michelson.Abs.CTimestamp }
  | 'address' { Michelson.Abs.CAddress }
  | 'option' CTyp { Michelson.Abs.COption $2 }
  | 'or' CTyp CTyp { Michelson.Abs.COr $2 $3 }
  | 'pair' CTypeSeq { Michelson.Abs.CPair $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

