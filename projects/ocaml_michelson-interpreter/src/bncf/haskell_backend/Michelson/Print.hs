{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}

-- | Pretty-printer for Michelson.
--   Generated by the BNF converter.

module Michelson.Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified Michelson.Abs

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Michelson.Abs.Int where
  prt _ (Michelson.Abs.Int i) = doc $ showString i
instance Print Michelson.Abs.Nat where
  prt _ (Michelson.Abs.Nat i) = doc $ showString i
instance Print Michelson.Abs.Str where
  prt _ (Michelson.Abs.Str i) = doc $ showString i
instance Print Michelson.Abs.Hex where
  prt _ (Michelson.Abs.Hex i) = doc $ showString i
instance Print Michelson.Abs.Prog where
  prt i = \case
    Michelson.Abs.Code instr instrs -> prPrec i 0 (concatD [prt 0 instr, doc (showString ";"), prt 0 instrs])

instance Print [Michelson.Abs.Data] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Michelson.Abs.PairSeq where
  prt i = \case
    Michelson.Abs.DPairSeq1 data_1 data_2 -> prPrec i 0 (concatD [prt 0 data_1, prt 0 data_2])
    Michelson.Abs.DPairSeq2 data_ pairseq -> prPrec i 0 (concatD [prt 0 data_, prt 0 pairseq])

instance Print Michelson.Abs.MapSeq where
  prt i = \case
    Michelson.Abs.DMapSeq1 data_1 data_2 -> prPrec i 0 (concatD [doc (showString "Elt"), prt 0 data_1, prt 0 data_2, doc (showString ";")])
    Michelson.Abs.DMapSeq2 data_1 data_2 mapseq -> prPrec i 0 (concatD [doc (showString "Elt"), prt 0 data_1, prt 0 data_2, doc (showString ";"), prt 0 mapseq])

instance Print Michelson.Abs.Data where
  prt i = \case
    Michelson.Abs.DInt int -> prPrec i 0 (concatD [prt 0 int])
    Michelson.Abs.DStr str -> prPrec i 0 (concatD [prt 0 str])
    Michelson.Abs.DByte hex -> prPrec i 0 (concatD [prt 0 hex])
    Michelson.Abs.DUnit -> prPrec i 0 (concatD [doc (showString "Unit")])
    Michelson.Abs.DTrue -> prPrec i 0 (concatD [doc (showString "True")])
    Michelson.Abs.DFalse -> prPrec i 0 (concatD [doc (showString "False")])
    Michelson.Abs.DPair2 pairseq -> prPrec i 0 (concatD [doc (showString "Pair"), prt 0 pairseq])
    Michelson.Abs.DLeft data_ -> prPrec i 0 (concatD [doc (showString "Left"), prt 0 data_])
    Michelson.Abs.DRight data_ -> prPrec i 0 (concatD [doc (showString "Right"), prt 0 data_])
    Michelson.Abs.DSome data_ -> prPrec i 0 (concatD [doc (showString "Some"), prt 0 data_])
    Michelson.Abs.DNone -> prPrec i 0 (concatD [doc (showString "None")])
    Michelson.Abs.DBlock datas -> prPrec i 0 (concatD [doc (showString "{"), prt 0 datas, doc (showString "}")])
    Michelson.Abs.DMap mapseq -> prPrec i 0 (concatD [doc (showString "{"), prt 0 mapseq, doc (showString "}")])
    Michelson.Abs.DInstr instr -> prPrec i 0 (concatD [prt 0 instr])

instance Print [Michelson.Abs.Instr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Michelson.Abs.Instr where
  prt i = \case
    Michelson.Abs.IBLOCK instrs -> prPrec i 0 (concatD [doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IDROP -> prPrec i 0 (concatD [doc (showString "DROP")])
    Michelson.Abs.IDROP_N nat -> prPrec i 0 (concatD [doc (showString "DROP"), prt 0 nat])
    Michelson.Abs.IDUP -> prPrec i 0 (concatD [doc (showString "DUP")])
    Michelson.Abs.IDUP_N nat -> prPrec i 0 (concatD [doc (showString "DUP"), prt 0 nat])
    Michelson.Abs.ISWAP -> prPrec i 0 (concatD [doc (showString "SWAP")])
    Michelson.Abs.IDIG_N nat -> prPrec i 0 (concatD [doc (showString "DIG"), prt 0 nat])
    Michelson.Abs.IDUG_N nat -> prPrec i 0 (concatD [doc (showString "DUG"), prt 0 nat])
    Michelson.Abs.IPUSH typ data_ -> prPrec i 0 (concatD [doc (showString "PUSH"), prt 0 typ, prt 0 data_])
    Michelson.Abs.ISOME -> prPrec i 0 (concatD [doc (showString "SOME")])
    Michelson.Abs.INONE typ -> prPrec i 0 (concatD [doc (showString "NONE"), prt 0 typ])
    Michelson.Abs.IUNIT -> prPrec i 0 (concatD [doc (showString "UNIT")])
    Michelson.Abs.INEVER -> prPrec i 0 (concatD [doc (showString "NEVER")])
    Michelson.Abs.IIF_NONE instrs1 instrs2 -> prPrec i 0 (concatD [doc (showString "IF_NONE"), doc (showString "{"), prt 0 instrs1, doc (showString "}"), doc (showString "{"), prt 0 instrs2, doc (showString "}")])
    Michelson.Abs.IPAIR -> prPrec i 0 (concatD [doc (showString "PAIR")])
    Michelson.Abs.IPAIR_N nat -> prPrec i 0 (concatD [doc (showString "PAIR"), prt 0 nat])
    Michelson.Abs.ICAR -> prPrec i 0 (concatD [doc (showString "CAR")])
    Michelson.Abs.ICDR -> prPrec i 0 (concatD [doc (showString "CDR")])
    Michelson.Abs.IUNPAIR -> prPrec i 0 (concatD [doc (showString "UNPAIR")])
    Michelson.Abs.IUNPAIR_N nat -> prPrec i 0 (concatD [doc (showString "UNPAIR"), prt 0 nat])
    Michelson.Abs.ILEFT typ -> prPrec i 0 (concatD [doc (showString "LEFT"), prt 0 typ])
    Michelson.Abs.IRIGHT typ -> prPrec i 0 (concatD [doc (showString "RIGHT"), prt 0 typ])
    Michelson.Abs.IIF_LEFT instrs1 instrs2 -> prPrec i 0 (concatD [doc (showString "IF_LEFT"), doc (showString "{"), prt 0 instrs1, doc (showString "}"), doc (showString "{"), prt 0 instrs2, doc (showString "}")])
    Michelson.Abs.INIL typ -> prPrec i 0 (concatD [doc (showString "NIL"), prt 0 typ])
    Michelson.Abs.ICONS -> prPrec i 0 (concatD [doc (showString "CONS")])
    Michelson.Abs.IIF_CONS instrs1 instrs2 -> prPrec i 0 (concatD [doc (showString "IF_CONS"), doc (showString "{"), prt 0 instrs1, doc (showString "}"), doc (showString "{"), prt 0 instrs2, doc (showString "}")])
    Michelson.Abs.ISIZE -> prPrec i 0 (concatD [doc (showString "SIZE")])
    Michelson.Abs.IEMPTY_SET ctyp -> prPrec i 0 (concatD [doc (showString "EMPTY_SET"), prt 0 ctyp])
    Michelson.Abs.IEMPTY_MAP ctyp typ -> prPrec i 0 (concatD [doc (showString "EMPTY_MAP"), prt 0 ctyp, prt 0 typ])
    Michelson.Abs.IEMPTY_BIG_MAP ctyp typ -> prPrec i 0 (concatD [doc (showString "EMPTY_BIG_MAP"), prt 0 ctyp, prt 0 typ])
    Michelson.Abs.IMAP instrs -> prPrec i 0 (concatD [doc (showString "MAP"), doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IITER instrs -> prPrec i 0 (concatD [doc (showString "ITER"), doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IMEM -> prPrec i 0 (concatD [doc (showString "MEM")])
    Michelson.Abs.IGET -> prPrec i 0 (concatD [doc (showString "GET")])
    Michelson.Abs.IGET_N nat -> prPrec i 0 (concatD [doc (showString "GET"), prt 0 nat])
    Michelson.Abs.IUPDATE -> prPrec i 0 (concatD [doc (showString "UPDATE")])
    Michelson.Abs.IUPDATE_N nat -> prPrec i 0 (concatD [doc (showString "UPDATE"), prt 0 nat])
    Michelson.Abs.IIF instrs1 instrs2 -> prPrec i 0 (concatD [doc (showString "IF"), doc (showString "{"), prt 0 instrs1, doc (showString "}"), doc (showString "{"), prt 0 instrs2, doc (showString "}")])
    Michelson.Abs.ILOOP instrs -> prPrec i 0 (concatD [doc (showString "LOOP"), doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.ILOOP_LEFT instrs -> prPrec i 0 (concatD [doc (showString "LOOP_LEFT"), doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.ILAMBDA typ1 typ2 instrs -> prPrec i 0 (concatD [doc (showString "LAMBDA"), prt 0 typ1, prt 0 typ2, doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IEXEC -> prPrec i 0 (concatD [doc (showString "EXEC")])
    Michelson.Abs.IAPPLY -> prPrec i 0 (concatD [doc (showString "APPLY")])
    Michelson.Abs.IDIP instrs -> prPrec i 0 (concatD [doc (showString "DIP"), doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IDIP_N nat instrs -> prPrec i 0 (concatD [doc (showString "DIP"), prt 0 nat, doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IFAILWITH -> prPrec i 0 (concatD [doc (showString "FAILWITH")])
    Michelson.Abs.ICAST -> prPrec i 0 (concatD [doc (showString "CAST")])
    Michelson.Abs.IRENAME -> prPrec i 0 (concatD [doc (showString "RENAME")])
    Michelson.Abs.ICONCAT -> prPrec i 0 (concatD [doc (showString "CONCAT")])
    Michelson.Abs.ISLICE -> prPrec i 0 (concatD [doc (showString "SLICE")])
    Michelson.Abs.IPACK -> prPrec i 0 (concatD [doc (showString "PACK")])
    Michelson.Abs.IUNPACK typ -> prPrec i 0 (concatD [doc (showString "UNPACK"), prt 0 typ])
    Michelson.Abs.IADD -> prPrec i 0 (concatD [doc (showString "ADD")])
    Michelson.Abs.ISUB -> prPrec i 0 (concatD [doc (showString "SUB")])
    Michelson.Abs.IMUL -> prPrec i 0 (concatD [doc (showString "MUL")])
    Michelson.Abs.IEDIC -> prPrec i 0 (concatD [doc (showString "EDIV")])
    Michelson.Abs.IABS -> prPrec i 0 (concatD [doc (showString "ABS")])
    Michelson.Abs.ISNAT -> prPrec i 0 (concatD [doc (showString "ISNAT")])
    Michelson.Abs.IINT -> prPrec i 0 (concatD [doc (showString "INT")])
    Michelson.Abs.INEG -> prPrec i 0 (concatD [doc (showString "NEG")])
    Michelson.Abs.ILSL -> prPrec i 0 (concatD [doc (showString "LSL")])
    Michelson.Abs.ILSR -> prPrec i 0 (concatD [doc (showString "LSR")])
    Michelson.Abs.IOR -> prPrec i 0 (concatD [doc (showString "OR")])
    Michelson.Abs.IAND -> prPrec i 0 (concatD [doc (showString "AND")])
    Michelson.Abs.IXOR -> prPrec i 0 (concatD [doc (showString "XOR")])
    Michelson.Abs.INOT -> prPrec i 0 (concatD [doc (showString "NOT")])
    Michelson.Abs.ICOMPARE -> prPrec i 0 (concatD [doc (showString "COMPARE")])
    Michelson.Abs.IEQ -> prPrec i 0 (concatD [doc (showString "EQ")])
    Michelson.Abs.INEQ -> prPrec i 0 (concatD [doc (showString "NEQ")])
    Michelson.Abs.ILT -> prPrec i 0 (concatD [doc (showString "LT")])
    Michelson.Abs.IGT -> prPrec i 0 (concatD [doc (showString "GT")])
    Michelson.Abs.ILE -> prPrec i 0 (concatD [doc (showString "LE")])
    Michelson.Abs.IGE -> prPrec i 0 (concatD [doc (showString "GE")])
    Michelson.Abs.ISELF -> prPrec i 0 (concatD [doc (showString "SELF")])
    Michelson.Abs.ISELF_ADDRESS -> prPrec i 0 (concatD [doc (showString "SELF_ADDRESS")])
    Michelson.Abs.ICONTRACT typ -> prPrec i 0 (concatD [doc (showString "CONTRACT"), prt 0 typ])
    Michelson.Abs.ITRANSFER_TOKENS -> prPrec i 0 (concatD [doc (showString "TRANSFER_TOKENS")])
    Michelson.Abs.ISET_DELEGATE -> prPrec i 0 (concatD [doc (showString "SET_DELEGATE")])
    Michelson.Abs.ICREATE_CONTRACT instrs -> prPrec i 0 (concatD [doc (showString "CREATE_CONTRACT"), doc (showString "{"), prt 0 instrs, doc (showString "}")])
    Michelson.Abs.IIMPLICIT_ACCOUNT -> prPrec i 0 (concatD [doc (showString "IMPLICIT_ACCOUNT")])
    Michelson.Abs.IVOTING_POWER -> prPrec i 0 (concatD [doc (showString "VOTING_POWER")])
    Michelson.Abs.INOW -> prPrec i 0 (concatD [doc (showString "NOW")])
    Michelson.Abs.ILEVEL -> prPrec i 0 (concatD [doc (showString "LEVEL")])
    Michelson.Abs.IAMOUNT -> prPrec i 0 (concatD [doc (showString "AMOUNT")])
    Michelson.Abs.IBALANCE -> prPrec i 0 (concatD [doc (showString "BALANCE")])
    Michelson.Abs.ICHECK_SIGNATURE -> prPrec i 0 (concatD [doc (showString "CHECK_SIGNATURE")])
    Michelson.Abs.IBLAKE2B -> prPrec i 0 (concatD [doc (showString "BLAKE2B")])
    Michelson.Abs.IKECCAK -> prPrec i 0 (concatD [doc (showString "KECCAK")])
    Michelson.Abs.ISHA3 -> prPrec i 0 (concatD [doc (showString "SHA3")])
    Michelson.Abs.ISHA256 -> prPrec i 0 (concatD [doc (showString "SHA256")])
    Michelson.Abs.ISHA512 -> prPrec i 0 (concatD [doc (showString "SHA512")])
    Michelson.Abs.IHASH_KEY -> prPrec i 0 (concatD [doc (showString "HASH_KEY")])
    Michelson.Abs.ISOURCE -> prPrec i 0 (concatD [doc (showString "SOURCE")])
    Michelson.Abs.ISENDER -> prPrec i 0 (concatD [doc (showString "SENDER")])
    Michelson.Abs.IADDRESS -> prPrec i 0 (concatD [doc (showString "ADDRESS")])
    Michelson.Abs.ICHAIN_ID -> prPrec i 0 (concatD [doc (showString "CHAIN_ID")])
    Michelson.Abs.ITOTAL_VOTING_POWER -> prPrec i 0 (concatD [doc (showString "TOTAL_VOTING_POWER")])
    Michelson.Abs.IPAIRING_CHECK -> prPrec i 0 (concatD [doc (showString "PAIRING_CHECK")])
    Michelson.Abs.ISAPLING_EMPTY_STATE nat -> prPrec i 0 (concatD [doc (showString "SAPLING_EMPTY_STATE"), prt 0 nat])
    Michelson.Abs.ISAPLING_VERIFY_UPDATE -> prPrec i 0 (concatD [doc (showString "SAPLING_VERIFY_UPDATE")])
    Michelson.Abs.ITICKET -> prPrec i 0 (concatD [doc (showString "TICKET")])
    Michelson.Abs.IREAD_TICKET -> prPrec i 0 (concatD [doc (showString "READ_TICKET")])
    Michelson.Abs.ISPLIT_TICKET -> prPrec i 0 (concatD [doc (showString "SPLIT_TICKET")])
    Michelson.Abs.IJOIN_TICKETS -> prPrec i 0 (concatD [doc (showString "JOIN_TICKETS")])
    Michelson.Abs.IOPEN_CHEST -> prPrec i 0 (concatD [doc (showString "OPEN_CHEST")])

instance Print Michelson.Abs.TypeSeq where
  prt i = \case
    Michelson.Abs.TTypSeq1 typ1 typ2 -> prPrec i 0 (concatD [prt 0 typ1, prt 0 typ2])
    Michelson.Abs.TTypSeq2 typ typeseq -> prPrec i 0 (concatD [prt 0 typ, prt 0 typeseq])

instance Print Michelson.Abs.Typ where
  prt i = \case
    Michelson.Abs.TCtype ctyp -> prPrec i 0 (concatD [prt 0 ctyp])
    Michelson.Abs.TOption typ -> prPrec i 0 (concatD [doc (showString "option"), prt 0 typ])
    Michelson.Abs.TList typ -> prPrec i 0 (concatD [doc (showString "list"), prt 0 typ])
    Michelson.Abs.TSet ctyp -> prPrec i 0 (concatD [doc (showString "set"), prt 0 ctyp])
    Michelson.Abs.TOperation -> prPrec i 0 (concatD [doc (showString "operation")])
    Michelson.Abs.TContract typ -> prPrec i 0 (concatD [doc (showString "contract"), prt 0 typ])
    Michelson.Abs.TTicket ctyp -> prPrec i 0 (concatD [doc (showString "ticket"), prt 0 ctyp])
    Michelson.Abs.TPair typeseq -> prPrec i 0 (concatD [doc (showString "pair"), prt 0 typeseq])
    Michelson.Abs.TOr typ1 typ2 -> prPrec i 0 (concatD [doc (showString "or"), prt 0 typ1, prt 0 typ2])
    Michelson.Abs.TLambda typ1 typ2 -> prPrec i 0 (concatD [doc (showString "lambda"), prt 0 typ1, prt 0 typ2])
    Michelson.Abs.TMap ctyp typ -> prPrec i 0 (concatD [doc (showString "map"), prt 0 ctyp, prt 0 typ])
    Michelson.Abs.TBig_map ctyp typ -> prPrec i 0 (concatD [doc (showString "big_map"), prt 0 ctyp, prt 0 typ])
    Michelson.Abs.TBls_g1 -> prPrec i 0 (concatD [doc (showString "bls12_381_g1")])
    Michelson.Abs.TBls_g2 -> prPrec i 0 (concatD [doc (showString "bls12_381_g2")])
    Michelson.Abs.TBls_fr -> prPrec i 0 (concatD [doc (showString "bls12_381_fr")])
    Michelson.Abs.TSapling_transaction nat -> prPrec i 0 (concatD [doc (showString "sapling_transaction"), prt 0 nat])
    Michelson.Abs.TSapling_state nat -> prPrec i 0 (concatD [doc (showString "sapling_state"), prt 0 nat])
    Michelson.Abs.TChest -> prPrec i 0 (concatD [doc (showString "chest")])
    Michelson.Abs.TChest_key -> prPrec i 0 (concatD [doc (showString "chest_key")])

instance Print Michelson.Abs.CTypeSeq where
  prt i = \case
    Michelson.Abs.CTypSeq1 ctyp1 ctyp2 -> prPrec i 0 (concatD [prt 0 ctyp1, prt 0 ctyp2])
    Michelson.Abs.CTypSeq2 ctyp ctypeseq -> prPrec i 0 (concatD [prt 0 ctyp, prt 0 ctypeseq])

instance Print Michelson.Abs.CTyp where
  prt i = \case
    Michelson.Abs.CUnit -> prPrec i 0 (concatD [doc (showString "unit")])
    Michelson.Abs.CNever -> prPrec i 0 (concatD [doc (showString "never")])
    Michelson.Abs.CBool -> prPrec i 0 (concatD [doc (showString "bool")])
    Michelson.Abs.CInt -> prPrec i 0 (concatD [doc (showString "int")])
    Michelson.Abs.CNat -> prPrec i 0 (concatD [doc (showString "nat")])
    Michelson.Abs.CString -> prPrec i 0 (concatD [doc (showString "string")])
    Michelson.Abs.CChain_id -> prPrec i 0 (concatD [doc (showString "chain_id")])
    Michelson.Abs.CBytes -> prPrec i 0 (concatD [doc (showString "bytes")])
    Michelson.Abs.CMutez -> prPrec i 0 (concatD [doc (showString "mutez")])
    Michelson.Abs.CKey_hash -> prPrec i 0 (concatD [doc (showString "key_hash")])
    Michelson.Abs.CKey -> prPrec i 0 (concatD [doc (showString "key")])
    Michelson.Abs.CSignature -> prPrec i 0 (concatD [doc (showString "signature")])
    Michelson.Abs.CTimestamp -> prPrec i 0 (concatD [doc (showString "timestamp")])
    Michelson.Abs.CAddress -> prPrec i 0 (concatD [doc (showString "address")])
    Michelson.Abs.COption ctyp -> prPrec i 0 (concatD [doc (showString "option"), prt 0 ctyp])
    Michelson.Abs.COr ctyp1 ctyp2 -> prPrec i 0 (concatD [doc (showString "or"), prt 0 ctyp1, prt 0 ctyp2])
    Michelson.Abs.CPair ctypeseq -> prPrec i 0 (concatD [doc (showString "pair"), prt 0 ctypeseq])
