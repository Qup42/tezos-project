(* pretty-printer generated by the BNF converter *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let indent (i: int) : string = "\n" ^ String.make i ' '

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let rec prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let rec prtInt (_:int) (i:int) : doc = render (string_of_int i)



let rec prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let rec prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let rec prtInt _ (AbsTest.Int i) : doc = render i


let rec prtNat _ (AbsTest.Nat i) : doc = render i



let rec prtProg (i:int) (e : AbsTest.prog) : doc = match e with
       AbsTest.Code (instr, instrs) -> prPrec i 0 (concatD [prtInstr 0 instr ; render ";" ; prtInstrListBNFC 0 instrs])


and prtInstr (i:int) (e : AbsTest.instr) : doc = match e with
       AbsTest.IPUSH (ctype, data) -> prPrec i 0 (concatD [render "PUSH" ; prtCType 0 ctype ; prtData 0 data])
  |    AbsTest.IADD  -> prPrec i 0 (concatD [render "DROP"])

and prtInstrListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtInstr 0 x])
  | (_,x::xs) -> (concatD [prtInstr 0 x ; render ";" ; prtInstrListBNFC 0 xs])
and prtData (i:int) (e : AbsTest.data) : doc = match e with
       AbsTest.DInt int -> prPrec i 0 (concatD [prtInt 0 int])


and prtCType (i:int) (e : AbsTest.cType) : doc = match e with
       AbsTest.CInt  -> prPrec i 0 (concatD [render "int"])



