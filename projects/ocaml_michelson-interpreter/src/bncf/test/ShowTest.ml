(* show functions generated by the BNF converter *)


(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string =
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b

let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf ->
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf ->
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf ->
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)

let rec showNat (AbsTest.Nat i) : showable = s2s "Nat " >> showString i
let rec showInt (AbsTest.Int i) : showable = s2s "Int " >> showString i

let rec showProg (e : AbsTest.prog) : showable = match e with
       AbsTest.Code (instr, instrs) -> s2s "Code" >> c2s ' ' >> c2s '(' >> showInstr instr  >> s2s ", " >>  showList showInstr instrs >> c2s ')'


and showInstr (e : AbsTest.instr) : showable = match e with
       AbsTest.IPUSH (ctype, data) -> s2s "IPUSH" >> c2s ' ' >> c2s '(' >> showCType ctype  >> s2s ", " >>  showData data >> c2s ')'
  |    AbsTest.IADD  -> s2s "IADD"


and showData (e : AbsTest.data) : showable = match e with
       AbsTest.DInt int -> s2s "DInt" >> c2s ' ' >> c2s '(' >> showInt int >> c2s ')'


and showCType (e : AbsTest.cType) : showable = match e with
       AbsTest.CInt  -> s2s "CInt"



