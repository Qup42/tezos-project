(* pretty-printer generated by the BNF converter *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let indent (i: int) : string = "\n" ^ String.make i ' '

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let rec prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let rec prtInt (_:int) (i:int) : doc = render (string_of_int i)



let rec prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let rec prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let rec prtStr _ (AbsMichelson.Str i) : doc = render i


let rec prtHex _ (AbsMichelson.Hex i) : doc = render i



let rec prtProg (i:int) (e : AbsMichelson.prog) : doc = match e with
       AbsMichelson.Contract (typ1, typ2, instr, instrs) -> prPrec i 0 (concatD [render "parameter" ; prtTyp 0 typ1 ; render ";" ; render "storage" ; prtTyp 0 typ2 ; render ";" ; render "code" ; render "{" ; prtInstr 0 instr ; render ";" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.Code (instr, instrs) -> prPrec i 0 (concatD [prtInstr 0 instr ; render ";" ; prtInstrListBNFC 0 instrs])


and prtInta (i:int) (e : AbsMichelson.inta) : doc = match e with
       AbsMichelson.IntPos integer -> prPrec i 0 (concatD [prtInt 0 integer])
  |    AbsMichelson.IntNeg integer -> prPrec i 0 (concatD [render "-" ; prtInt 0 integer])


and prtPairSeq (i:int) (e : AbsMichelson.pairSeq) : doc = match e with
       AbsMichelson.DPairSeq1 (data1, data2) -> prPrec i 0 (concatD [prtData 0 data1 ; prtData 0 data2])
  |    AbsMichelson.DPairSeq2 (data, pairseq) -> prPrec i 0 (concatD [prtData 0 data ; prtPairSeq 0 pairseq])


and prtMapSeq (i:int) (e : AbsMichelson.mapSeq) : doc = match e with
       AbsMichelson.DMapSeq1 (data1, data2) -> prPrec i 0 (concatD [render "Elt" ; prtData 0 data1 ; prtData 0 data2 ; render ";"])
  |    AbsMichelson.DMapSeq2 (data1, data2, mapseq) -> prPrec i 0 (concatD [render "Elt" ; prtData 0 data1 ; prtData 0 data2 ; render ";" ; prtMapSeq 0 mapseq])


and prtData (i:int) (e : AbsMichelson.data) : doc = match e with
       AbsMichelson.DInt inta -> prPrec i 0 (concatD [prtInta 0 inta])
  |    AbsMichelson.DStr str -> prPrec i 0 (concatD [prtStr 0 str])
  |    AbsMichelson.DByte hex -> prPrec i 0 (concatD [prtHex 0 hex])
  |    AbsMichelson.DUnit  -> prPrec i 0 (concatD [render "Unit"])
  |    AbsMichelson.DTrue  -> prPrec i 0 (concatD [render "True"])
  |    AbsMichelson.DFalse  -> prPrec i 0 (concatD [render "False"])
  |    AbsMichelson.DPair2 pairseq -> prPrec i 0 (concatD [render "Pair" ; prtPairSeq 0 pairseq])
  |    AbsMichelson.DLeft data -> prPrec i 0 (concatD [render "Left" ; prtData 0 data])
  |    AbsMichelson.DRight data -> prPrec i 0 (concatD [render "Right" ; prtData 0 data])
  |    AbsMichelson.DSome data -> prPrec i 0 (concatD [render "Some" ; prtData 0 data])
  |    AbsMichelson.DNone  -> prPrec i 0 (concatD [render "None"])
  |    AbsMichelson.DBlock datas -> prPrec i 0 (concatD [render "{" ; prtDataListBNFC 0 datas ; render "}"])
  |    AbsMichelson.DMap mapseq -> prPrec i 0 (concatD [render "{" ; prtMapSeq 0 mapseq ; render "}"])
  |    AbsMichelson.DInstr instr -> prPrec i 0 (concatD [prtInstr 0 instr])

and prtDataListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtData 0 x ; render ";" ; prtDataListBNFC 0 xs])
and prtInstr (i:int) (e : AbsMichelson.instr) : doc = match e with
       AbsMichelson.IBLOCK instrs -> prPrec i 0 (concatD [render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IDROP  -> prPrec i 0 (concatD [render "DROP"])
  |    AbsMichelson.IDROP_N integer -> prPrec i 0 (concatD [render "DROP" ; prtInt 0 integer])
  |    AbsMichelson.IDUP  -> prPrec i 0 (concatD [render "DUP"])
  |    AbsMichelson.IDUP_N integer -> prPrec i 0 (concatD [render "DUP" ; prtInt 0 integer])
  |    AbsMichelson.ISWAP  -> prPrec i 0 (concatD [render "SWAP"])
  |    AbsMichelson.IDIG_N integer -> prPrec i 0 (concatD [render "DIG" ; prtInt 0 integer])
  |    AbsMichelson.IDUG_N integer -> prPrec i 0 (concatD [render "DUG" ; prtInt 0 integer])
  |    AbsMichelson.IPUSH (typ, data) -> prPrec i 0 (concatD [render "PUSH" ; prtTyp 0 typ ; prtData 0 data])
  |    AbsMichelson.ISOME  -> prPrec i 0 (concatD [render "SOME"])
  |    AbsMichelson.INONE typ -> prPrec i 0 (concatD [render "NONE" ; prtTyp 0 typ])
  |    AbsMichelson.IUNIT  -> prPrec i 0 (concatD [render "UNIT"])
  |    AbsMichelson.INEVER  -> prPrec i 0 (concatD [render "NEVER"])
  |    AbsMichelson.IIF_NONE (instrs1, instrs2) -> prPrec i 0 (concatD [render "IF_NONE" ; render "{" ; prtInstrListBNFC 0 instrs1 ; render "}" ; render "{" ; prtInstrListBNFC 0 instrs2 ; render "}"])
  |    AbsMichelson.IPAIR  -> prPrec i 0 (concatD [render "PAIR"])
  |    AbsMichelson.IPAIR_N integer -> prPrec i 0 (concatD [render "PAIR" ; prtInt 0 integer])
  |    AbsMichelson.ICAR  -> prPrec i 0 (concatD [render "CAR"])
  |    AbsMichelson.ICDR  -> prPrec i 0 (concatD [render "CDR"])
  |    AbsMichelson.IUNPAIR  -> prPrec i 0 (concatD [render "UNPAIR"])
  |    AbsMichelson.IUNPAIR_N integer -> prPrec i 0 (concatD [render "UNPAIR" ; prtInt 0 integer])
  |    AbsMichelson.ILEFT typ -> prPrec i 0 (concatD [render "LEFT" ; prtTyp 0 typ])
  |    AbsMichelson.IRIGHT typ -> prPrec i 0 (concatD [render "RIGHT" ; prtTyp 0 typ])
  |    AbsMichelson.IIF_LEFT (instrs1, instrs2) -> prPrec i 0 (concatD [render "IF_LEFT" ; render "{" ; prtInstrListBNFC 0 instrs1 ; render "}" ; render "{" ; prtInstrListBNFC 0 instrs2 ; render "}"])
  |    AbsMichelson.INIL typ -> prPrec i 0 (concatD [render "NIL" ; prtTyp 0 typ])
  |    AbsMichelson.ICONS  -> prPrec i 0 (concatD [render "CONS"])
  |    AbsMichelson.IIF_CONS (instrs1, instrs2) -> prPrec i 0 (concatD [render "IF_CONS" ; render "{" ; prtInstrListBNFC 0 instrs1 ; render "}" ; render "{" ; prtInstrListBNFC 0 instrs2 ; render "}"])
  |    AbsMichelson.ISIZE  -> prPrec i 0 (concatD [render "SIZE"])
  |    AbsMichelson.IEMPTY_SET ctyp -> prPrec i 0 (concatD [render "EMPTY_SET" ; prtCTyp 0 ctyp])
  |    AbsMichelson.IEMPTY_MAP (ctyp, typ) -> prPrec i 0 (concatD [render "EMPTY_MAP" ; prtCTyp 0 ctyp ; prtTyp 0 typ])
  |    AbsMichelson.IEMPTY_BIG_MAP (ctyp, typ) -> prPrec i 0 (concatD [render "EMPTY_BIG_MAP" ; prtCTyp 0 ctyp ; prtTyp 0 typ])
  |    AbsMichelson.IMAP instrs -> prPrec i 0 (concatD [render "MAP" ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IITER instrs -> prPrec i 0 (concatD [render "ITER" ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IMEM  -> prPrec i 0 (concatD [render "MEM"])
  |    AbsMichelson.IGET  -> prPrec i 0 (concatD [render "GET"])
  |    AbsMichelson.IGET_N integer -> prPrec i 0 (concatD [render "GET" ; prtInt 0 integer])
  |    AbsMichelson.IUPDATE  -> prPrec i 0 (concatD [render "UPDATE"])
  |    AbsMichelson.IUPDATE_N integer -> prPrec i 0 (concatD [render "UPDATE" ; prtInt 0 integer])
  |    AbsMichelson.IIF (instrs1, instrs2) -> prPrec i 0 (concatD [render "IF" ; render "{" ; prtInstrListBNFC 0 instrs1 ; render "}" ; render "{" ; prtInstrListBNFC 0 instrs2 ; render "}"])
  |    AbsMichelson.ILOOP instrs -> prPrec i 0 (concatD [render "LOOP" ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.ILOOP_LEFT instrs -> prPrec i 0 (concatD [render "LOOP_LEFT" ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.ILAMBDA (typ1, typ2, instrs) -> prPrec i 0 (concatD [render "LAMBDA" ; prtTyp 0 typ1 ; prtTyp 0 typ2 ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IEXEC  -> prPrec i 0 (concatD [render "EXEC"])
  |    AbsMichelson.IAPPLY  -> prPrec i 0 (concatD [render "APPLY"])
  |    AbsMichelson.IDIP instrs -> prPrec i 0 (concatD [render "DIP" ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IDIP_N (integer, instrs) -> prPrec i 0 (concatD [render "DIP" ; prtInt 0 integer ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IFAILWITH  -> prPrec i 0 (concatD [render "FAILWITH"])
  |    AbsMichelson.ICAST  -> prPrec i 0 (concatD [render "CAST"])
  |    AbsMichelson.IRENAME  -> prPrec i 0 (concatD [render "RENAME"])
  |    AbsMichelson.ICONCAT  -> prPrec i 0 (concatD [render "CONCAT"])
  |    AbsMichelson.ISLICE  -> prPrec i 0 (concatD [render "SLICE"])
  |    AbsMichelson.IPACK  -> prPrec i 0 (concatD [render "PACK"])
  |    AbsMichelson.IUNPACK typ -> prPrec i 0 (concatD [render "UNPACK" ; prtTyp 0 typ])
  |    AbsMichelson.IADD  -> prPrec i 0 (concatD [render "ADD"])
  |    AbsMichelson.ISUB  -> prPrec i 0 (concatD [render "SUB"])
  |    AbsMichelson.IMUL  -> prPrec i 0 (concatD [render "MUL"])
  |    AbsMichelson.IEDIC  -> prPrec i 0 (concatD [render "EDIV"])
  |    AbsMichelson.IABS  -> prPrec i 0 (concatD [render "ABS"])
  |    AbsMichelson.ISNAT  -> prPrec i 0 (concatD [render "ISNAT"])
  |    AbsMichelson.IINT  -> prPrec i 0 (concatD [render "INT"])
  |    AbsMichelson.INEG  -> prPrec i 0 (concatD [render "NEG"])
  |    AbsMichelson.ILSL  -> prPrec i 0 (concatD [render "LSL"])
  |    AbsMichelson.ILSR  -> prPrec i 0 (concatD [render "LSR"])
  |    AbsMichelson.IOR  -> prPrec i 0 (concatD [render "OR"])
  |    AbsMichelson.IAND  -> prPrec i 0 (concatD [render "AND"])
  |    AbsMichelson.IXOR  -> prPrec i 0 (concatD [render "XOR"])
  |    AbsMichelson.INOT  -> prPrec i 0 (concatD [render "NOT"])
  |    AbsMichelson.ICOMPARE  -> prPrec i 0 (concatD [render "COMPARE"])
  |    AbsMichelson.IEQ  -> prPrec i 0 (concatD [render "EQ"])
  |    AbsMichelson.INEQ  -> prPrec i 0 (concatD [render "NEQ"])
  |    AbsMichelson.ILT  -> prPrec i 0 (concatD [render "LT"])
  |    AbsMichelson.IGT  -> prPrec i 0 (concatD [render "GT"])
  |    AbsMichelson.ILE  -> prPrec i 0 (concatD [render "LE"])
  |    AbsMichelson.IGE  -> prPrec i 0 (concatD [render "GE"])
  |    AbsMichelson.ISELF  -> prPrec i 0 (concatD [render "SELF"])
  |    AbsMichelson.ISELF_ADDRESS  -> prPrec i 0 (concatD [render "SELF_ADDRESS"])
  |    AbsMichelson.ICONTRACT typ -> prPrec i 0 (concatD [render "CONTRACT" ; prtTyp 0 typ])
  |    AbsMichelson.ITRANSFER_TOKENS  -> prPrec i 0 (concatD [render "TRANSFER_TOKENS"])
  |    AbsMichelson.ISET_DELEGATE  -> prPrec i 0 (concatD [render "SET_DELEGATE"])
  |    AbsMichelson.ICREATE_CONTRACT instrs -> prPrec i 0 (concatD [render "CREATE_CONTRACT" ; render "{" ; prtInstrListBNFC 0 instrs ; render "}"])
  |    AbsMichelson.IIMPLICIT_ACCOUNT  -> prPrec i 0 (concatD [render "IMPLICIT_ACCOUNT"])
  |    AbsMichelson.IVOTING_POWER  -> prPrec i 0 (concatD [render "VOTING_POWER"])
  |    AbsMichelson.INOW  -> prPrec i 0 (concatD [render "NOW"])
  |    AbsMichelson.ILEVEL  -> prPrec i 0 (concatD [render "LEVEL"])
  |    AbsMichelson.IAMOUNT  -> prPrec i 0 (concatD [render "AMOUNT"])
  |    AbsMichelson.IBALANCE  -> prPrec i 0 (concatD [render "BALANCE"])
  |    AbsMichelson.ICHECK_SIGNATURE  -> prPrec i 0 (concatD [render "CHECK_SIGNATURE"])
  |    AbsMichelson.IBLAKE2B  -> prPrec i 0 (concatD [render "BLAKE2B"])
  |    AbsMichelson.IKECCAK  -> prPrec i 0 (concatD [render "KECCAK"])
  |    AbsMichelson.ISHA3  -> prPrec i 0 (concatD [render "SHA3"])
  |    AbsMichelson.ISHA256  -> prPrec i 0 (concatD [render "SHA256"])
  |    AbsMichelson.ISHA512  -> prPrec i 0 (concatD [render "SHA512"])
  |    AbsMichelson.IHASH_KEY  -> prPrec i 0 (concatD [render "HASH_KEY"])
  |    AbsMichelson.ISOURCE  -> prPrec i 0 (concatD [render "SOURCE"])
  |    AbsMichelson.ISENDER  -> prPrec i 0 (concatD [render "SENDER"])
  |    AbsMichelson.IADDRESS  -> prPrec i 0 (concatD [render "ADDRESS"])
  |    AbsMichelson.ICHAIN_ID  -> prPrec i 0 (concatD [render "CHAIN_ID"])
  |    AbsMichelson.ITOTAL_VOTING_POWER  -> prPrec i 0 (concatD [render "TOTAL_VOTING_POWER"])
  |    AbsMichelson.IPAIRING_CHECK  -> prPrec i 0 (concatD [render "PAIRING_CHECK"])
  |    AbsMichelson.ISAPLING_EMPTY_STATE integer -> prPrec i 0 (concatD [render "SAPLING_EMPTY_STATE" ; prtInt 0 integer])
  |    AbsMichelson.ISAPLING_VERIFY_UPDATE  -> prPrec i 0 (concatD [render "SAPLING_VERIFY_UPDATE"])
  |    AbsMichelson.ITICKET  -> prPrec i 0 (concatD [render "TICKET"])
  |    AbsMichelson.IREAD_TICKET  -> prPrec i 0 (concatD [render "READ_TICKET"])
  |    AbsMichelson.ISPLIT_TICKET  -> prPrec i 0 (concatD [render "SPLIT_TICKET"])
  |    AbsMichelson.IJOIN_TICKETS  -> prPrec i 0 (concatD [render "JOIN_TICKETS"])
  |    AbsMichelson.IOPEN_CHEST  -> prPrec i 0 (concatD [render "OPEN_CHEST"])

and prtInstrListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtInstr 0 x])
  | (_,x::xs) -> (concatD [prtInstr 0 x ; render ";" ; prtInstrListBNFC 0 xs])
and prtTypeSeq (i:int) (e : AbsMichelson.typeSeq) : doc = match e with
       AbsMichelson.TTypSeq1 (typ1, typ2) -> prPrec i 0 (concatD [prtTyp 0 typ1 ; prtTyp 0 typ2])
  |    AbsMichelson.TTypSeq2 (typ, typeseq) -> prPrec i 0 (concatD [prtTyp 0 typ ; prtTypeSeq 0 typeseq])


and prtTyp (i:int) (e : AbsMichelson.typ) : doc = match e with
       AbsMichelson.TCtype ctyp -> prPrec i 0 (concatD [prtCTyp 0 ctyp])
  |    AbsMichelson.TOption typ -> prPrec i 0 (concatD [render "option" ; prtTyp 0 typ])
  |    AbsMichelson.TList typ -> prPrec i 0 (concatD [render "list" ; prtTyp 0 typ])
  |    AbsMichelson.TSet ctyp -> prPrec i 0 (concatD [render "set" ; prtCTyp 0 ctyp])
  |    AbsMichelson.TOperation  -> prPrec i 0 (concatD [render "operation"])
  |    AbsMichelson.TContract typ -> prPrec i 0 (concatD [render "contract" ; prtTyp 0 typ])
  |    AbsMichelson.TTicket ctyp -> prPrec i 0 (concatD [render "ticket" ; prtCTyp 0 ctyp])
  |    AbsMichelson.TPair typeseq -> prPrec i 0 (concatD [render "pair" ; prtTypeSeq 0 typeseq])
  |    AbsMichelson.TOr (typ1, typ2) -> prPrec i 0 (concatD [render "or" ; prtTyp 0 typ1 ; prtTyp 0 typ2])
  |    AbsMichelson.TLambda (typ1, typ2) -> prPrec i 0 (concatD [render "lambda" ; prtTyp 0 typ1 ; prtTyp 0 typ2])
  |    AbsMichelson.TMap (ctyp, typ) -> prPrec i 0 (concatD [render "map" ; prtCTyp 0 ctyp ; prtTyp 0 typ])
  |    AbsMichelson.TBig_map (ctyp, typ) -> prPrec i 0 (concatD [render "big_map" ; prtCTyp 0 ctyp ; prtTyp 0 typ])
  |    AbsMichelson.TBls_g1  -> prPrec i 0 (concatD [render "bls12_381_g1"])
  |    AbsMichelson.TBls_g2  -> prPrec i 0 (concatD [render "bls12_381_g2"])
  |    AbsMichelson.TBls_fr  -> prPrec i 0 (concatD [render "bls12_381_fr"])
  |    AbsMichelson.TSapling_transaction integer -> prPrec i 0 (concatD [render "sapling_transaction" ; prtInt 0 integer])
  |    AbsMichelson.TSapling_state integer -> prPrec i 0 (concatD [render "sapling_state" ; prtInt 0 integer])
  |    AbsMichelson.TChest  -> prPrec i 0 (concatD [render "chest"])
  |    AbsMichelson.TChest_key  -> prPrec i 0 (concatD [render "chest_key"])


and prtCTypeSeq (i:int) (e : AbsMichelson.cTypeSeq) : doc = match e with
       AbsMichelson.CTypSeq1 (ctyp1, ctyp2) -> prPrec i 0 (concatD [prtCTyp 0 ctyp1 ; prtCTyp 0 ctyp2])
  |    AbsMichelson.CTypSeq2 (ctyp, ctypeseq) -> prPrec i 0 (concatD [prtCTyp 0 ctyp ; prtCTypeSeq 0 ctypeseq])


and prtCTyp (i:int) (e : AbsMichelson.cTyp) : doc = match e with
       AbsMichelson.CUnit  -> prPrec i 0 (concatD [render "unit"])
  |    AbsMichelson.CNever  -> prPrec i 0 (concatD [render "never"])
  |    AbsMichelson.CBool  -> prPrec i 0 (concatD [render "bool"])
  |    AbsMichelson.CInt  -> prPrec i 0 (concatD [render "int"])
  |    AbsMichelson.CNat  -> prPrec i 0 (concatD [render "nat"])
  |    AbsMichelson.CString  -> prPrec i 0 (concatD [render "string"])
  |    AbsMichelson.CChain_id  -> prPrec i 0 (concatD [render "chain_id"])
  |    AbsMichelson.CBytes  -> prPrec i 0 (concatD [render "bytes"])
  |    AbsMichelson.CMutez  -> prPrec i 0 (concatD [render "mutez"])
  |    AbsMichelson.CKey_hash  -> prPrec i 0 (concatD [render "key_hash"])
  |    AbsMichelson.CKey  -> prPrec i 0 (concatD [render "key"])
  |    AbsMichelson.CSignature  -> prPrec i 0 (concatD [render "signature"])
  |    AbsMichelson.CTimestamp  -> prPrec i 0 (concatD [render "timestamp"])
  |    AbsMichelson.CAddress  -> prPrec i 0 (concatD [render "address"])
  |    AbsMichelson.COption ctyp -> prPrec i 0 (concatD [render "option" ; prtCTyp 0 ctyp])
  |    AbsMichelson.COr (ctyp1, ctyp2) -> prPrec i 0 (concatD [render "or" ; prtCTyp 0 ctyp1 ; prtCTyp 0 ctyp2])
  |    AbsMichelson.CPair ctypeseq -> prPrec i 0 (concatD [render "pair" ; prtCTypeSeq 0 ctypeseq])



