-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Test.Par
  ( happyError
  , myLexer
  , pProg
  ) where

import Prelude

import qualified Test.Abs
import Test.Lex

}

%name pProg Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  ';'    { PT _ (TS _ 1)   }
  'DROP' { PT _ (TS _ 2)   }
  'PUSH' { PT _ (TS _ 3)   }
  'int'  { PT _ (TS _ 4)   }
  L_Int  { PT _ (T_Int $$) }
  L_Nat  { PT _ (T_Nat $$) }

%%

Int :: { Test.Abs.Int }
Int  : L_Int { Test.Abs.Int $1 }

Nat :: { Test.Abs.Nat }
Nat  : L_Nat { Test.Abs.Nat $1 }

Prog :: { Test.Abs.Prog }
Prog : Instr ';' ListInstr { Test.Abs.Code $1 $3 }

ListInstr :: { [Test.Abs.Instr] }
ListInstr
  : {- empty -} { [] }
  | Instr { (:[]) $1 }
  | Instr ';' ListInstr { (:) $1 $3 }

Instr :: { Test.Abs.Instr }
Instr
  : Instr ';' { $1 }
  | 'PUSH' CType Data { Test.Abs.IPUSH $2 $3 }
  | 'DROP' { Test.Abs.IADD }

Data :: { Test.Abs.Data }
Data : Int { Test.Abs.DInt $1 }

CType :: { Test.Abs.CType }
CType : 'int' { Test.Abs.CInt }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

