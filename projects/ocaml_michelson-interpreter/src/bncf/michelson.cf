{-
    Michelson (L)BNF Grammar to be used with the BNF Converter https://github.com/BNFC/bnfc
    Sources for the grammar:
    --https://tezos.gitlab.io/shell/micheline.html#syntax TODO: remove
    https://tezos.gitlab.io/alpha/michelson.html#full-grammar
-}


-- RULES
comment "#" ; -- line comment
--comment "*/" "*/" ; -- block comment

entrypoints Prog,  ; -- if other entrypoints are needed, create identifier for all of them!

-- empty contracts (not) allowed? how many instr needed for minimal contract?
-- "Pair" (parameter, storage) instead of parameter/storage  ?
Contract. Prog ::= "parameter" Typ ";" "storage" Typ ";" "code" "{" [Instr] "}" ;
Code.     Prog ::= [Instr] ;


-- User-Defined token types
-- FIXME Int wird wegen '-' als string gesehen. digit+ aber als int; reicht digit+ fÃ¼r positive/negative integer?
-- FIXME should be fixed in LexMichelson.mll und ParMichelson.mly und AbsMichelson; oder int_of_string erst beim interpretieren
--token Int '-'? digit+ ;
token Str '"' ( (char - ["\"\\"]) | ('\\' ["\"\\rntb"]) )* '"' ; -- should be equivalent to (\" | \r | \n | \t | \b | \\ | [^"\])*
token Hex '0''x' ( digit | ["abcdefABCDEF"] )+ ;

IntPos.  Inta ::= Integer;
IntNeg.  Inta ::= "-" Integer;

-- Data D
terminator Data ";" ; -- FIXME empty data sequence allowed? else add noempty. muss letztes Data ein ; haben? sonst separator
DPairSeq1.   PairSeq  ::= Data Data ;
DPairSeq2.   PairSeq  ::= Data PairSeq ;
DMapSeq1.    MapSeq   ::= "Elt" Data Data ";" ;
DMapSeq2.    MapSeq   ::= "Elt" Data Data ";" MapSeq ;
DInt. Data         ::= Inta ;
DStr. Data         ::= Str ;
DByte. Data        ::= Hex ;
DUnit. Data        ::= "Unit" ;
DTrue. Data        ::= "True" ;
DFalse. Data       ::= "False" ;
DPair2. Data       ::= "Pair" PairSeq;
DLeft.  Data       ::= "Left" Data ;
DRight. Data       ::= "Right" Data ;
DSome. Data        ::= "Some" Data ;
DNone. Data        ::= "None" ;
DBlock. Data       ::= "{" [Data] "}" ;
DMap. Data         ::= "{" MapSeq "}" ;
DInstr. Data ::= Instr ;



-- I Instructions TODO: seperate into core instructions usw.. Also maybe add macros
separator Instr ";" ; -- empty instruction sequence allowed, last instr does does not need to be terminated with ';'
_.                      Instr ::= Instr ";" ; -- but last instr can be terminated with ';' -> remove additional ';'
IBLOCK.                 Instr ::= "{" [Instr] "}" ;
IDROP.                  Instr ::= "DROP" ;
IDROP_N.                Instr ::= "DROP" Integer ;
IDUP.                   Instr ::= "DUP" ;
IDUP_N.                 Instr ::= "DUP" Integer ;
ISWAP.                  Instr ::= "SWAP" ;
IDIG_N.                 Instr ::= "DIG" Integer ;
IDUG_N.                 Instr ::= "DUG" Integer ;
IPUSH.                  Instr ::= "PUSH" Typ Data ;
ISOME.                  Instr ::= "SOME" ;
INONE.                  Instr ::= "NONE" Typ ;
IUNIT.                  Instr ::= "UNIT" ;
INEVER.                 Instr ::= "NEVER" ;
IIF_NONE.               Instr ::= "IF_NONE" "{" [Instr] "}" "{" [Instr] "}" ;
IPAIR.                  Instr ::= "PAIR" ;
IPAIR_N.                Instr ::= "PAIR" Integer ;
ICAR.                   Instr ::= "CAR" ;
ICDR.                   Instr ::= "CDR" ;
IUNPAIR.                Instr ::= "UNPAIR" ;
IUNPAIR_N.              Instr ::= "UNPAIR" Integer ;
ILEFT.                  Instr ::= "LEFT" Typ ;
IRIGHT.                 Instr ::= "RIGHT" Typ ;
IIF_LEFT.               Instr ::= "IF_LEFT" "{" [Instr] "}" "{" [Instr] "}" ;
INIL.                   Instr ::= "NIL" Typ ;
ICONS.                  Instr ::= "CONS" ;
IIF_CONS.               Instr ::= "IF_CONS" "{" [Instr] "}" "{" [Instr] "}" ;
ISIZE.                  Instr ::= "SIZE" ;
IEMPTY_SET.             Instr ::= "EMPTY_SET" CTyp ;
IEMPTY_MAP.             Instr ::= "EMPTY_MAP" CTyp Typ ;
IEMPTY_BIG_MAP.         Instr ::= "EMPTY_BIG_MAP" CTyp Typ ;
IMAP.                   Instr ::= "MAP" "{" [Instr] "}" ;
IITER.                  Instr ::= "ITER" "{" [Instr] "}" ;
IMEM.                   Instr ::= "MEM" ;
IGET.                   Instr ::= "GET" ;
IGET_N.                 Instr ::= "GET" Integer ;
IUPDATE.                Instr ::= "UPDATE" ;
IUPDATE_N.              Instr ::= "UPDATE" Integer ;
IIF.                    Instr ::= "IF" "{" [Instr] "}" "{" [Instr] "}" ;
ILOOP.                  Instr ::= "LOOP" "{" [Instr] "}" ;
ILOOP_LEFT.             Instr ::= "LOOP_LEFT" "{" [Instr] "}" ;
ILAMBDA.                Instr ::= "LAMBDA" Typ Typ "{" [Instr] "}" ;
IEXEC.                  Instr ::= "EXEC" ;
IAPPLY.                 Instr ::= "APPLY" ;
IDIP.                   Instr ::= "DIP" "{" [Instr] "}" ;
IDIP_N.                 Instr ::= "DIP" Integer "{" [Instr] "}" ;
IFAILWITH.              Instr ::= "FAILWITH" ;
ICAST.                  Instr ::= "CAST" ;
IRENAME.                Instr ::= "RENAME" ;
ICONCAT.                Instr ::= "CONCAT" ;
ISLICE.                 Instr ::= "SLICE" ;
IPACK.                  Instr ::= "PACK" ;
IUNPACK.                Instr ::= "UNPACK" Typ ;
IADD.                   Instr ::= "ADD" ;
ISUB.                   Instr ::= "SUB" ;
IMUL.                   Instr ::= "MUL" ;
IEDIC.                  Instr ::= "EDIV" ;
IABS.                   Instr ::= "ABS" ;
ISNAT.                  Instr ::= "ISNAT" ;
IINT.                   Instr ::= "INT" ;
INEG.                   Instr ::= "NEG" ;
ILSL.                   Instr ::= "LSL" ;
ILSR.                   Instr ::= "LSR" ;
IOR.                    Instr ::= "OR" ;
IAND.                   Instr ::= "AND" ;
IXOR.                   Instr ::= "XOR" ;
INOT.                   Instr ::= "NOT" ;
ICOMPARE.               Instr ::= "COMPARE" ;
-- TODO: what is with macro Instrs IFCMPEQ, ect?
-- IMACRO. Instr ::= Macro_Instr
-- MACRO_TOKEN= (CMPEQ | CMPNEQ | CMPLT | CMPGT | CMPLE | CMPGE | IFEQ | IFNEQ | IFLT | IFGT | IFLE | IFGE | IFCMPEQ | IFCMPNEQ | IFCMPLT | IFCMPGT | IFCMPLE | IFCMPGE | FAIL | ASSERT | ASSERT_EQ | ASSERT_NEQ | ASSERT_LT | ASSERT_LE | ASSERT_GT | ASSERT_GE | ASSERT_CMPEQ | ASSERT_CMPNEQ |ASSERT_CMPLT | ASSERT_CMPLE | ASSERT_CMPGT | ASSERT_CMPGE | ASSERT_NONE | ASSERT_SOME | ASSERT_LEFT | ASSERT_RIGHT | SET_CAR | SET_CDR | MAP_CAR | MAP_CDR | IF_SOME) | DII+P | DUU+P | P[AIP]+R | UNP[PAI]+R | C[AD]+R | SET_C[AD]+R | MAP_C[AD]+R
IEQ.                    Instr ::= "EQ" ;
INEQ.                   Instr ::= "NEQ" ;
ILT.                    Instr ::= "LT" ;
IGT.                    Instr ::= "GT" ;
ILE.                    Instr ::= "LE" ;
IGE.                    Instr ::= "GE" ;
ISELF.                  Instr ::= "SELF" ;
ISELF_ADDRESS.          Instr ::= "SELF_ADDRESS" ;
ICONTRACT.              Instr ::= "CONTRACT" Typ ;
ITRANSFER_TOKENS.       Instr ::= "TRANSFER_TOKENS" ;
ISET_DELEGATE.          Instr ::= "SET_DELEGATE" ;
ICREATE_CONTRACT.       Instr ::= "CREATE_CONTRACT" "{" [Instr] "}" ;
IIMPLICIT_ACCOUNT.      Instr ::= "IMPLICIT_ACCOUNT" ;
IVOTING_POWER.          Instr ::= "VOTING_POWER" ;
INOW.                   Instr ::= "NOW" ;
ILEVEL.                 Instr ::= "LEVEL" ;
IAMOUNT.                Instr ::= "AMOUNT" ;
IBALANCE.               Instr ::= "BALANCE" ;
ICHECK_SIGNATURE.       Instr ::= "CHECK_SIGNATURE" ;
IBLAKE2B.               Instr ::= "BLAKE2B" ;
IKECCAK.                Instr ::= "KECCAK" ;
ISHA3.                  Instr ::= "SHA3" ;
ISHA256.                Instr ::= "SHA256" ;
ISHA512.                Instr ::= "SHA512" ;
IHASH_KEY.              Instr ::= "HASH_KEY" ;
ISOURCE.                Instr ::= "SOURCE" ;
ISENDER.                Instr ::= "SENDER" ;
IADDRESS.               Instr ::= "ADDRESS" ;
ICHAIN_ID.              Instr ::= "CHAIN_ID" ;
ITOTAL_VOTING_POWER.    Instr ::= "TOTAL_VOTING_POWER" ;
IPAIRING_CHECK.         Instr ::= "PAIRING_CHECK" ;
-- TODO: https://gitlab.com/morley-framework/morley/-/issues/380  SAPPLING NOT NEEDED?
ISAPLING_EMPTY_STATE.   Instr ::= "SAPLING_EMPTY_STATE" Integer ;
ISAPLING_VERIFY_UPDATE. Instr ::= "SAPLING_VERIFY_UPDATE" ;
ITICKET.                Instr ::= "TICKET" ;
IREAD_TICKET.           Instr ::= "READ_TICKET" ;
ISPLIT_TICKET.          Instr ::= "SPLIT_TICKET" ;
IJOIN_TICKETS.          Instr ::= "JOIN_TICKETS" ;
IOPEN_CHEST.            Instr ::= "OPEN_CHEST" ;


-- Types
TTypSeq1.             TypeSeq  ::= Typ Typ ;
TTypSeq2.             TypeSeq  ::= Typ TypeSeq ;
_.                    Typ ::= "(" Typ ")" ;
TCtype.               Typ ::= CTyp ;  -- TODO: drop token in interpreter (it seems not possible to stop the token from beeing created)
TOption.              Typ ::= "option" Typ ;
TList.                Typ ::= "list" Typ ;
TSet.                 Typ ::= "set" CTyp ;
TOperation.           Typ ::= "operation" ;
TContract.            Typ ::= "contract" Typ ;
TTicket.              Typ ::= "ticket" CTyp ;
TPair.                Typ ::= "pair" TypeSeq ;
TOr.                  Typ ::= "or" Typ Typ ;
TLambda.              Typ ::= "lambda" Typ Typ ;
TMap.                 Typ ::= "map" CTyp Typ ;
TBig_map.             Typ ::= "big_map" CTyp Typ ;
TBls_g1.              Typ ::= "bls12_381_g1" ;
TBls_g2.              Typ ::= "bls12_381_g2" ;
TBls_fr.              Typ ::= "bls12_381_fr" ;
TSapling_transaction. Typ ::= "sapling_transaction" Integer ;
TSapling_state.       Typ ::= "sapling_state" Integer ;
TChest.               Typ ::= "chest" ;
TChest_key.           Typ ::= "chest_key" ;


-- Comparable Types
CTypSeq1.   CTypeSeq ::= CTyp CTyp ;
CTypSeq2.   CTypeSeq ::= CTyp CTypeSeq ;
CUnit.      CTyp ::= "unit" ;
CNever.     CTyp ::= "never" ;
CBool.      CTyp ::= "bool" ;
CInt.       CTyp ::= "int" ;
CNat.       CTyp ::= "nat" ;
CString.    CTyp ::= "string" ;
CChain_id.  CTyp ::= "chain_id" ;
CBytes.     CTyp ::= "bytes" ;
CMutez.     CTyp ::= "mutez" ;
CKey_hash.  CTyp ::= "key_hash" ;
CKey.       CTyp ::= "key" ;
CSignature. CTyp ::= "signature" ;
CTimestamp. CTyp ::= "timestamp" ;
CAddress.   CTyp ::= "address" ;
COption.    CTyp ::= "option" CTyp ;
COr.        CTyp ::= "or" CTyp CTyp ;
CPair.      CTyp ::= "pair" CTypeSeq ;