% APLAS 2021: Regular research papers should not exceed 18 pages in
% the Springer LNCS format(LaTeX template), including bibliography and
% figures.
% Lightweight double-blind: Author names and institutions must be
% omitted and References to the authorsâ€™ own related work should be in
% the third person 
%
\documentclass[runningheads]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{mathpartir}
\usepackage{fixme}
\usepackage{xcolor}
\usepackage{listings}
\lstdefinelanguage{michelson}{
%  basicstyle=\ttfamily,
  morekeywords={parameter,storage,or,unit,mutez,pair,bool,address}, sensitive=false,
  morecomment=[l]{\#},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}
\lstset{language=Caml}
\input{macros}


\begin{document}
%
\title{A Typed Programmatic Interface to Contracts on the Blockchain}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
% ANONYMOUS
% \author{Thi Thu Ha Doan\orcidID{0000-0001-7524-4497}\and
% Peter Thiemann\orcidID{0000-0002-9000-1239}}

%
\authorrunning{~}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
% ANONYMOUS
% \institute{University of Freiburg, Germany \\
% \email{\{doanha,thiemann\}@informatik.uni-freiburg.de}
% }
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  Smart contract applications on the blockchain can only reach their full potential if
  they can be integrated with traditional software systems. Invoking
  contracts and observing the state of the blockchain requires a
  programmatic interface. We propose a typed API for this
  purpose and establish some properties of the combined
  system. Specifically, we provide an execution model that
  enables us to prove type-safe interaction between programs and the 
  blockchain. We establish further properties of the model that
  give rise to requirements on the API. A prototype of the interface
  is implemented in OCaml for the Tezos blockchain.
\end{abstract}

\keywords{smart contract  \and embedded domain specific language \and types.}
%
%
%
\section{Introduction}
\label{sec:introduction}
First generation blockchains were primarily geared towards supporting
cryptocurrencies. The most prominent system of this kind is Bitcoin
\cite{bitcoin-whitepaper}. Though Bitcoin already features a
rudimentary programming language called Script, second generation
blockchains like the Ethereum blockchain \cite{eth-whitepaper} feature
Turing-complete programming facilities, called 
Smart Contracts. They provide robust trustworthy distributed computing
facilities even though the programs run on a peer-to-peer network with
untrusted participants. Each peer in the network runs the same program
and uses cryptographic methods to check the results among the other
peers and to create a persistent ledger of all transactions, the
blockchain, thus ensuring the integrity of the results. Third
generation blockchains, like Tezos \cite{tezos-whitepaper}, are even adaptable to
new requirements without breaking participating peers (no ``hard
forks'' required).

The strength of programs on the blockchain is also their
weakness. They are fully deterministic in that they can only depend on
data that is stored on the chain and on contract invocations, which are
also stored on the chain. Moreover, the entire data as well as all
transactions are public. These properties make it hard to react to
external stimuli like time triggers or events like an exchange rate or
a share price hitting a limit. 

As smart contracts rarely live in isolation, it should be possible to
integrate them with traditional software systems and to enable
triggering contracts from outside the blockchain. Such triggers
require trusted intermediaries that provide so-called oracles \cite{oracle-patterns,call-action-oracle}. A
smart contract registers a request and a callback with an oracle. The
oracle invokes the callback as soon as an answer is available. 

Building such oracles requires programmatic interfaces to implement the interactions. 
However, current blockchains often provide non-programmatic interfaces, 
such as the Ethereum JSON-RPC API and the Tezos RPC API. 
We present a typed API for invoking contracts from OCaml programs. 
Our typed API supports the implementation of application programs/ oracles 
that safely interact with smart contracts on the blockchain. 
Such an API with a reliable computing facility and network 
connectivity is sufficient to self-provision an oracle.
 Moreover, our approach provides a type-safe facility instead of oracles, which are intrinsically untyped as they aim to provide a generic service.

\subsubsection{Contributions}
\label{sec:contributions}

\begin{itemize}
\item An operational semantics for functional programs running
  alongside smart contracts in a blockchain. 
\item Established various properties of the combined system with
  proofs in upcoming techreport.
\item An implementation of a low-level OCaml-API to the Tezos
  blockchain, which corresponds to the operational semantics.\footnote{%
    Available at \url{https://github.com/tezos-project/Tezos-Ocaml-API}.}
\end{itemize}

\section{Motivation}
\label{sec:motivation}

Suppose you want to implement a bidding strategy for an auction that
is deployed on the blockchain as a smart contract.
% Once the contract is deployed, the
% auction is open for bidding, but it should be closed after 48 hours. Such a timeout is a typical task for an oracle. Rather than
% trusting a generic oracle, you prefer to roll your own mechanism that reliably closes the auction
% after 48 hours have passed. So you want to write a program to do so. 
Your bidding strategy may start at a certain amount and increase the bid until a
limit is reached. Of course, you only want to increase your bid if
someone else placed a higher bid. So you want to write a
program to implement this strategy.

This task cannot be implemented as a smart contract without
cooperation of the auction contract because it reacts
on external triggers.
% Closing require scheduling the invocation of a
% contract at a certain time.
Bidding requires watching the current highest bid of the contract and
react if another bidder places a higher bid.
The auction contract could anticipate the need for such observations
by allowing bidders to register callbacks that are invoked when a
higher bid arrives. However, we cannot assume such cooperation of the
auction contract nor would we be willing to pay the the fee for running
that callback.

For concreteness, Listing~\ref{lst:auction-contract-header} shows the
header of an auction contract in Michelson \cite{michelson}. The
\lstinline/parameter/ clause specifies the contract's parameter
type. It is a sum type (indicated by \lstinline/or/) and each
alternative constitutes an entrypoint, named \lstinline/%close/ and
\lstinline/%bid/. The caller selects the entrypoint by injecting the argument into the
\lstinline/left/ or \lstinline/right/ summand. Both entrypoints take a \lstinline/unit/
parameter. The \lstinline/%bid/ entrypoint considers the transferred
tokens as the bid.
The \lstinline/storage/ clause declares the state of the contract,
which is a nested pair type indicating whether bidding is allowed
(\lstinline/bool/), the address of the contract owner (to prohibit
unauthorized calls to \lstinline/%close/), and the bidder's
address. The highest bid corresponds to the token balance of the contract.
\begin{lstlisting}[language=michelson,numbers=none,float,caption={Header of the auction contract},label={lst:auction-contract-header},captionpos=b,emph={close,bid},emphstyle=\underbar]
parameter (or (unit %close)
              (unit %bid)); # bid in transfer
storage (pair bool          # bidding allowed
         (pair address      # contract owner
          address           # highest bidder's address
        ));
\end{lstlisting}

To avoid too much detail, we only outline the implementation of the entrypoints. The
\lstinline/%close/ entrypoint first checks its sender's address
against the owner's address in the store. Then it transfers the funds
to the owner, closes the contract by clearing the bidding flag, and
leaves it to the owner to deliver the
goods.\footnote{For simplicity we elide safeguarding by a third-party oracle.}
The \lstinline/%bid/ entrypoint immediately returns each bid that is not higher
than the existing highest bid. Otherwise, it keeps the funds
transferred, returns the previous highest bid to its owner, and stores
the current bidder as the new highest bidder.


We present some idealized code for % timed contract closing and
strategic bidding as a separate program that interacts with the
blockchain.  The bidding strategy cannot be implemented as a smart
contract.
% A variation of timed contract closing could be
% implemented as Tezos contracts have access to the current time: A
% contract can enforce that bids arriving after a deadline are
% immediately rejected or that the auction cannot be closed before the
% deadline, but it cannot reliably execute the action associated with
% closing the contract at the deadline

In preparation, we need to obtain a typed handle for the contract. We
assume that \lstinline!Cl! is the module containing the contract
library. The respective library function
\lstinline!Cl.make_contract_from_hash!
takes the hash of the contract along with representations of
the types of the parameter and the storage (from module
\lstinline!Ct!). It checks the validity of the hash and the types with
the blockchain and returns a typed
handle, which is indexed with OCaml types corresponding to parameter
and storage type.
\begin{lstlisting}[language=Caml,numbers=none,basicstyle=\small]
# let auction = Cl.make_contract_hash auction_hash
#     ~parameter:(Ct.Or (Ct.Unit, Ct.Unit))
#     ~storage:(Ct.Pair (Ct.Bool, Ct.Pair (Ct.Addr, Ct.Addr))));;
val auction :
  ((unit, unit) Either.t,
   bool * (Cl.Addr.t * Cl.Addr.t)) Cl.contract
\end{lstlisting}

% First the code that creates an auction contract and closes it after 48 hours. 

% \begin{lstlisting}[language=Caml,numbers=none,basicstyle=\small]
% let _ = Cl.set_authority (my_address)
% let initial_store = (true, (my_address, my_address))
% let contract = Cl.originate auction 1 initial_store
% Time.sleep(48 * 3600);               (* 48h in seconds *)
% Cl.call_contract contract (left ()); (* entrypoint %close *)
% \end{lstlisting}

% \lstinline/set_authority/ sets the sender address for
% upcoming operations,  \lstinline/originate/ deploys its argument contract along
% with the provided funds of one token and the \lstinline/initial_store/
% \lstinline/auction_script/ is the contract from Listing~\ref{lst:auction-contract-header}, and 
% \lstinline/call_contract/ invokes a contract with a parameter. The
% \lstinline/initial_store/ sets the bidding flag, and both owner and
% highest bidder to the sender account.


To implement the bidding strategy, we first check the state of the
contract to find the current highest bid. As long as bidding is
allowed and the current bid is below our \lstinline/limit/, we update
our bid by a given amount \lstinline/step/, and then keep watching the state of the contract by
polling it every five minutes. 

\begin{lstlisting}[language=Caml,numbers=none,basicstyle=\small]
let rec poll limit step =
  let (bidding, (_, highest_bidder)) = Cl.get_storage auction;
  let high_bid = Cl.get_balance auction;
  if bidding && high_bid < limit then
    (if highest_bidder <> my_address then  (* entrypoint %bid *)
      try
        Cl.call_contract auction
          (right (min (high_bid + step, limit))) 
      with
      | Cl.FAILWITH message -> poll limit step;
    Time.sleep(5 * 60);
    poll limit step)
\end{lstlisting}

The functions \lstinline/get_storage/ and \lstinline/get_balance/
obtains the storage and current balance, respectively, of a contract from
the blockchain. They never fail. Function \lstinline/call_contract/
takes a typed handle and a parameter of suitable type. It indicates
failure by raising an exception. If failure is caused by the
\lstinline/FAILWITH/ instruction in the contract, then the
corresponding \lstinline/Cl.FAILWITH/ exception is raised, which
carries a string corresponding to the argument of the instruction. In
our particular example, the auction may fail with signaling the message
\lstinline/"closed"/ or \lstinline/"bid to low"/. Our
code ignores this message for simplicity.

This code is idealized in several respects. Originating or running a contract
requires to propose a fee to the blockchain, which may or may not be
accepted.
Starting a contract may also time out for a variety of reasons. So just
invoking a contract with a fixed fee does not guarantee the contract's
execution.  Even if the invocation is locally accepted, it still takes
a couple of cycles before we can be sure the invocation is globally
accepted and incorporated in the blockchain.
Hence, after starting the invocation, we have to observe the fate of
this invocation. If it does not get incorporated, then we need to
analyze the reason and react accordingly. For example, if the
invocation was rejected because of an insufficient fee, we might want
to restart with an increased fee. Or we might decide to wait until the
invocation goes through without increasing the fee.

Hence, we would implement a scheme similar to
the bidding strategy: start with a low fee and increase (or wait) until the
contract is accepted or a fee cap is reached. On the other hand, an
observer function like \lstinline/get_state/ always succeeds.

The low-level interface that we propose in this paper requires the
programmer to be explicit about fees, waiting, and polling the state
of contract invocations. 

In summary, a useful smart-contract-API  has facilities to
\begin{itemize}
\item query the current state of the blockchain (e.g., fees in the
  current block),
\item query storage and balance of a contract (to obtain
  the current highest bid),
\item originate contracts, invoke contracts, and initiate
  transfers. Hence, the API has to run on
  behalf of some account (by holding its private key).
\end{itemize}
These facilities are supported by the (untyped) RPC interface of the Tezos
blockchain, which is the basis of our implementation. 

\section{Execution Model}
\label{sec:execution-model}
The context of our work is the Tezos blockchain \cite{tezos-whitepaper,tezos-intropaper}. Tezos is a self-amending blockchain that improves several aspects compared to established blockchains. Tezos proposes an original consensus algorithm called Liquid Proof of Stake that allows consensus not only on the state of its ledger, like Bitcoin \cite{bitcoin-whitepaper} or Ethereum \cite{eth-whitepaper}, but also on how the economic protocol and nodes should upgrade, and serves as a decentralized smart contract platform that focuses on formal methods to improve security. 

Tezos supports two types of accounts: implicit accounts, which
are associated with a pair of private/public keys, and smart
contracts, which are programmable accounts created by an origination
operation. The address of a smart
contract is a unique public hash that depends on the creation
operation. No key pair is associated with a smart contract. An
implicit account is maintained on the blockchain with 
its public key and balance.
% , and counter, whose job is to preventreplay attacks.
A smart contract account is stored with its script, storage,
and balance. A contract script maps a pair of a parameter and a
storage, which have fixed and monomorphic types, to a pair of a list of
internal operations and an updated storage. An account can
perform three kinds of transactions: (1) transfer tokens to an
implicit account, (2) invoke a smart contract, or (3) originate a new
smart contract. A contract origination specifies the script of the
contract and the initial contents of the contract storage, while a
contract invocation must provide input data. Each transaction contains
a fee to be paid either by payment to a baker or by destruction
(burning). A transaction is injected into the blockchain network via a
node, which then validates the transaction before submitting it to the
network. A transaction may be rejected by the node for a
number of reasons. After validation, the transaction is injected into
a \emph{mempool}, which contains all pending transactions before they can
be included in a block. A pending transaction may simply disappear
from the mempool, for example, a transaction times out when 60 blocks
have passed and it can no longer be included in a block. When a transaction
is included in the blockchain, the affected accounts are updated
according to the transaction result.  


The execution model consists of functional (OCaml) programs that
interact with an abstraction of the Tezos blockchain
\cite{tezos-whitepaper}. As the blockchain is realized by a
peer-to-peer network of 
independent nodes, interaction happens through
\emph{local nodes} that receive requests to originate and invoke
contracts from programs that run on a particular node. We model the blockchain
itself as a separate, abstract global entity that represents the
current consensual state of the system. Our model does not express
low-level details, but relies on nondeterminism to describe
the possible behaviors of the system. In particular, we do
\textbf{not} formalize the execution of the smart contracts
themselves, we rather consider them as black boxes and probe their
observable behavior. Tezos' smart contract language Michelson and its
properties have been formalized elsewhere \cite{DBLP:conf/fm/BernardoCHPT19}.

We write $\emptyset$ for the empty set and $\mathbf{e :: s}$ to
decompose a set nondeterministically into an element $\mathbf{e}$ and a set
$\mathbf{s}$. We generally use lowercase boldface for metavariables
ranging over values of a certain syntactic category, e.g., \PUK\ for
public keys, and the capitalized name for the
corresponding type as well as for the set of these values (as in \TPUK).

\subsection{Local Node}
\label{sec:local-node}

A local node runs on behalf of authorities, which are called
\emph{accounts} in Tezos. An account is represented by a key pair $\Angle{
  \PAK, \PUK
} $, where $\PAK$ is a private key and $\PUK$ the corresponding public
key in a public key encryption scheme.

The local node offers operations to transfer tokens from one account
to another, to invoke a contract, and to originate a contract on the blockchain.
\begin{align*}
  \OP &::= \TRANSFER[\PARAMETER]\NTEZ\PUK\ADDR\MTEZ
  \\&\mid \ORIGINATE\NTEZ\PUK\CODE\INIT\MTEZ
\end{align*}
In the transfer, which also serves as contract invocation, \NTEZ\ is the amount of tokens transferred, \PUK\ is the public key of the
sender, \ADDR\ is either a public 
key for an implicit account (in case of a simple transfer)  or a
public hash for a smart contract (for an invocation), \PARAMETER\ is
the argument passed to the smart contract, 
which is empty for a simple transfer, and \MTEZ\ is
the amount of tokens for the transaction fee. In originate,  \CODE\ is
the script of a smart contract and \INIT\ is the initial value of the
contract's storage. Each operation returns an \emph{operation hash}
\OPH, on which we can query the status of the operation.

The local node offers several ways to query the current state of
the blockchain.
Some \emph{query operators} are defined by the following grammar:
\begin{align*}
  \QOP & ::=
  % \GETCOUNTER\PUK  
  %        \mid
         \GETBALANCE{}%\ADDR
  \mid \GETSTATUS{}%\OPH
  \mid \GETSTORAGE{}%\PUH
  % \mid \GETCODE\PUH 
  % \mid \GETTYPE\PUH
         \mid \GETCONTRACT{}%\OPH
         \mid \dots
\end{align*}
We obtain the balance associated with an implicit account or a
contract by its public key or public hash, respectively; the status of
a submitted operation by its operation hash; the stored value of a
contract by its public hash; and the public hash of a contract by the
operation hash of its originating transaction.

The domain-specific types come with different guarantees. Values of
type \TPUH\ and \TPUK\ as well as \TADDR\ are not necessarily valid,
as there might be no contract associated with a hash / no account
associated with a public key. In contrast, a value of type
$\TCONTRACT\ \TYPE$ is a public hash that is verified to be associated
with a contract with parameter type $\TYPE$. Operation hashes \OPH\
are only returned from blockchain operations. As the surface language
neither contains literals of type \TOPH\ nor are there casts into
that type, all values of \TOPH\ are valid. 

\begin{definition}%[State of a node]
  The \emph{state of a node} is a pair
  $\NODE = [ \EXPRS, \ACCOUNTS
  % , \OPERATIONS
  ]$, where $\EXPRS$ is a
  set of programs and $\ACCOUNTS \subseteq \TPAK \times \TPUK$  is a set of
  implicit accounts.
  % , and
  % $\OPERATIONS \subseteq \ECS \times \TOP $ is a set of pairs of
  % expression contexts and operations.
\end{definition}

\begin{figure}[tp]
\begin{align*}
  \CONSTANT & ::= \INT \mid \FIX
              \mid \OPH \mid \PUH \mid\PUK \mid \CODE \mid
              \NTEZ \mid \SUNIT \mid \FALSE \mid \TRUE \\
  \STATUS & ::= \STATUSPENDING \mid \STATUSINCLUDING (\INT) \mid
            \STATUSTIMEOUT \\
  \ERROR &::= \ERRPRG \mid \ERRBAL \mid \ERRCOUNT \mid \ERRFEE \mid
           \ERRPUK \mid \ERRPUH \mid \ERRARG \mid \ERRINIT\\
	\EXPR & :: =  \CONSTANT \mid \STATUS \mid \ERROR \mid \VARIABLE \mid \lambda \VARIABLE. \EXPR\ 
	\mid \EXPR\EXPR  %\mid \FST\ \EXPR \mid \SND\ \EXPR 	%\mid \NI \EI
  \mid \EXPR\ \PLUS\ \EXPR\ \mid
  % \EXPR\ \MINUS\ \EXPR\ \mid
  \EXPR\ \EQUAL\ \EXPR\
  % \mid  \EXPR\ \LESS\ \EXPR
  \mid \EXPR\ \AND\ \EXPR\ \mid \EXPR\ \OR\ \EXPR\ \mid \NOT\ \EXPR
  \\& \mid (\EXPR,\EXPR)\mid \NIL\ \mid \CONS\ \EXPR\ \EXPR \mid \LEFT\ \EXPR \mid\RIGHT\
  \EXPR \mid \SOME\ \EXPR \mid \NONE
  \mid \MATCH\ \EXPR\ \WITH\ \PATTERN\to\EXPR \dots 
  \\& \mid \RAISE\ \EXPR \mid \TRY\ \EXPR\ \EXCEPT\ \EXPR \mid \CAST\EXPR\TYPE\TYPEU
  \\& \mid \QOP\  \EXPR \mid \TRANSFER[\EXPR]\EXPR\EXPR\EXPR\EXPR
  \\& \mid \ORIGINATE\EXPR\EXPR\EXPR\EXPR\EXPR
  % \\&\mid \CONTRACT\ \TYPE\ \EXPR
  % \\& \mid \TOSTRING\ \EXPR \mid \FROMSTRING\ \TYPE\ \EXPR
  \\
  \PATTERN &::= \VARIABLE \mid (\PATTERN, \PATTERN) \mid \NIL \mid \CONS\ \PATTERN\ \PATTERN \mid \LEFT\ \PATTERN \mid\RIGHT\
             \PATTERN \mid \SOME\ \PATTERN \mid \NONE \\
            &\mid \FALSE \mid \TRUE \mid \STATUS \mid \ERROR
  % \\
  % \QOP & ::= \GETBALANCE{} \mid \GETSTATUS{} \mid \GETSTORAGE{} \mid \GETCODE{} \mid \GETCOUNTER{}
  %        \mid \GETTYPE{}
  \\[2ex]
  \TYPE, \TYPEU & ::=
                  \TPUH \mid
                  \TPUK \mid
                  \TADDR \mid 
                  \TCONTRACT\ \TYPE\ \TYPEU \mid
                  \TCODE\ \TYPE\ \TYPEU \mid
                  \TOPH\ \TYPE\ \TYPEU \mid
                  \TSTATUS \mid \TEXCEPTION \mid \TTEZ \\
  & \mid \TNO \mid \TINT \mid \TUNIT \mid \TBOOL \mid \TSTRING \mid \TYPE\to\TYPEU \mid \TPAIR\ \TYPE\ \TYPEU \mid \TLIST\ \TYPE
    \mid \TSUM\ \TYPE\ \TYPEU \mid \TOPTION\ \TYPE 
\end{align*}
  \caption{Syntax of expressions, \EXPR, and types, \TYPE}
  \label{fig:syntax-expressions}
\end{figure}
All queries and operations are started by programs, i.e., closed
expressions of type unit that run on the
local node. Each program can send transactions on behalf of any
account on the local node.  Figure~\ref{fig:syntax-expressions} defines the syntax of
expressions, which describe the usual constructs of call-by-value PCF
with sum, product, list, and option types, exceptions and fixpoint.
Pattern matching is the only means to decompose values, cf.\ \PATTERN. 

Moreover, there are
domain-specific primitive types and constants \CONSTANT\ to support blockchain
operations, as well as several exceptional values collected in \ERROR.
There is syntax to initiate transfers and to originate contracts as
well as for the queries. Finally, there is a type cast
$\CAST\EXPR\TYPE\TYPEU$, which we describe after discussing types. An
implementation provides all of these types and operations via a library API.

Types (also in Figure~\ref{fig:syntax-expressions}) comprise a
collection of standard base types as well as 
functions, pairs, lists, sums, and option types. These types are
chosen to match with built-in types of Michelson. 
In addition, there
are domain specific types of public hashes $\TPUH$ and public keys $\TPUK$ subsumed by
a type of addresses $\TADDR$. $\TCONTRACT\ \TYPE\ \TYPEU$ is the type of
a contract with parameter type $\TYPE$ and storage type $\TYPEU$. $\CODE\ \TYPE\ \TYPEU$
indicates a Michelson program with parameter type $\TYPE$ and storage
type $\TYPEU$. Tezos tokens have type $\TTEZ$. The type $\TOPH\ \TYPE\
\TYPEU$ signifies operation hashes
returned by blockchain operations. The parameters of the hash carry
the types when originating a contract. Otherwise, they are set to the
irrelevant type $\TNO$. We take the liberty of omitting irrelevant
type parameters, that is, we write $\TOPH$ for $\TOPH\ \TNO\ \TNO$.
Querying the status of an operation
returns a value of type $\TSTATUS$. Exceptions have type
$\TEXCEPTION$. 

\begin{figure}[tp]
\begin{align*}
  \ECN{} & :: = \ECHOLE \mid \SC[\overline\VAL\ \ECN{}\ \overline\EXPR] \mid \RAISE\ \ECN{} \mid \TRY\ \ECN{}\ \EXCEPT\ \EXPR
  \mid \MATCH\ \ECN{}\ \WITH\ \PATTERN\to\EXPR \dots
  \\
  \VAL & ::= \CONSTANT \mid \STATUS \mid \ERROR \mid \lambda x.\EXPR \mid(\VAL, \VAL) \mid
         \NIL \mid \CONS\ \VAL\ \VAL \mid \LEFT\ \VAL \mid \RIGHT\
         \VAL \mid \SOME\ \VAL\mid \NONE
\end{align*}
  \caption{Evaluation contexts and values}
  \label{fig:evaluation-contexts-values}
\end{figure}
Figure~\ref{fig:evaluation-contexts-values} defines evaluation
contexts $\ECS$ and values $\VAL$.
Here $\SC$ ranges over the remaining syntactic constructors, which are
treated uniformly: evaluation proceeds from left to right. Values are
standard for call-by-value lambda calculus.

% \begin{figure}[tp]
%   \begin{align*}
%     \LET\ \mathit{oph} &=  \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
%          & \FIX \lambda f.\lambda x. \MATCH\ \GETSTATUS{\mathit{oph}}\ \WITH \\
%          & \mid \STATUSPENDING \to \text{Time.sleep(1)}; f () \textrm{\qquad(* not yet included,
%            continue waiting *)} \\
%          & \mid \STATUSINCLUDING (n) \to \text{if } n < 50\text{ then
%            Time.sleep(1)};f ()\textrm{\quad(* included with $n$
%            blocks confirmation *)}\\
%          & \mid \STATUSTIMEOUT \to \textrm{(* lost operation, try
%            again *)}
%   \end{align*}
%   \caption{Pseudocode example for a token transfer}
%   \label{fig:pseudocode-example}
% \end{figure}
% Figure~\ref{fig:pseudocode-example} shows an incomplete example
% expression that transfers tokens from $\PUK$ to $\PUK'$ and then
% checks the status of the operation. The outer loop to raise the fee
% and retry is omitted.


Type casts are only applicable to certain pairs of
types governed by a relation $\SubType$, which could also serve as a
subtyping relation. It is given by the axioms
$\inferrule{}{\TPUH \SubType \TADDR}$, $\inferrule{}{\TPUK \SubType
  \TADDR}$, and $\inferrule{}{\TCONTRACT\ \TYPE\ \TYPEU \SubType \TPUH}$.
A cast from $\TYPE$ to $\TYPEU$ is only allowed
if $\TYPE \SubType \TYPEU$ (upcast) or $\TYPEU \SubType \TYPE$
(downcast). Upcasts always succeed, but downcasts may fail at run time.
In particular,  public hashes and public keys can both stand for addresses. Moreover, a smart
contract with parameter type $\TYPE$ is represented by its public hash
at run time. The corresponding downcast must check whether the public
hash is valid and has the expected parameter and storage type.

Figure~\ref{fig:typing-expressions} presents selected typing rules for
expressions. We rely on an external typing judgment
$\JTypeCode\CODE\TYPE$ for the contract language, which we leave
unspecified, and $\JTypeValue\STRING\TYPE$ for serialized values as
stored on the blockchain. The latter judgment states $\STRING$ is
a string parseable as a value of type $\TYPE$.
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule{}{\JTypeExpr\TEnv\INT\TINT}

    \inferrule{}{\JTypeExpr\TEnv\OPH{\TOPH\ \TYPE\ \TYPEU}}

    \inferrule{}{\JTypeExpr\TEnv\PUH{\TPUH}}

    \inferrule{}{\JTypeExpr\TEnv\PUK\TPUK}

    \inferrule{\JTypeCode \CODE{ \TPAIR\ \TYPE_p\
        \TYPE_s}}{\JTypeExpr\TEnv\CODE{\TCODE\ \TYPE_p\ \TYPE_s}}

    % \inferrule{\JTypeExpr\TEnv\EXPR\TADDR}{\JTypeExpr\TEnv{\CONTRACT\
    %     \TYPE\ \EXPR}{\TOPTION (\TCONTRACT\ \TYPE)}}
    %     
    \inferrule{}{\JTypeExpr\TEnv\NTEZ\TTEZ}

    \inferrule{}{\JTypeExpr\TEnv\SUNIT\TUNIT}

    \inferrule{}{\JTypeExpr\TEnv\FALSE\TBOOL}

    \inferrule{}{\JTypeExpr\TEnv\TRUE\TBOOL}

    \inferrule{}{\JTypeExpr\TEnv\STATUSPENDING\TSTATUS}

    \inferrule{}{\JTypeExpr\TEnv\STATUSTIMEOUT\TSTATUS}

    \inferrule{\JTypeExpr\TEnv\EXPR\TINT}{\JTypeExpr\TEnv{\STATUSINCLUDING
        (\EXPR)}\TSTATUS}

    \inferrule{}{\JTypeExpr\TEnv\ERROR\TEXCEPTION}

    \inferrule{}{\JTypeExpr\TEnv\VARIABLE{\TEnv (\VARIABLE)}}

    \inferrule{ \JTypeExpr{\TEnv, \VARIABLE:\TYPE'}\EXPR{\TYPE} }{
      \JTypeExpr\TEnv{\lambda\VARIABLE.\EXPR}{\TYPE'\to\TYPE}}

    \inferrule{
      \JTypeExpr\TEnv\EXPR{\TYPE'\to\TYPE} \\
      \JTypeExpr\TEnv{\EXPR'}{\TYPE'} }{ \JTypeExpr\TEnv{\EXPR\
        \EXPR'}\TYPE }

    \inferrule{
      \JTypeExpr\TEnv\EXPR\TYPE \\
      \JTypeExpr\TEnv{\EXPR'}{\TYPE'} }{ \JTypeExpr\TEnv{(\EXPR,
        \EXPR')}{\TPAIR\ \TYPE\ \TYPE'} }
  % 
    % \inferrule{
    % \JTypeExpr\TEnv{\EXPR}{\TPAIR\ \TYPE\ \TYPE'}
    % }{
    %   \JTypeExpr\TEnv{\FST\ \EXPR}\TYPE
    % }
  %   
    %   \inferrule{
    %   \JTypeExpr\TEnv{\EXPR}{\TPAIR\ \TYPE\ \TYPE'}
    % }{
    %   \JTypeExpr\TEnv{\SND\ \EXPR}{\TYPE'}
    % }

    \inferrule{ \JTypeExpr\TEnv\EXPR\TEXCEPTION }{
      \JTypeExpr\TEnv{\RAISE\ \EXPR}\TYPE }

    \inferrule{
      \JTypeExpr\TEnv\EXPR\TYPE \\
      \JTypeExpr\TEnv{\EXPR'}{\TEXCEPTION\to\TYPE} }{
      \JTypeExpr\TEnv{\TRY\ \EXPR\ \EXCEPT\ \EXPR'}\TYPE }

    \inferrule{
      \JTypeExpr\TEnv\EXPR\TYPE \\
      \TYPE \SubType \TYPEU \vee \TYPEU \SubType \TYPE
    }{
      \JTypeExpr\TEnv{\CAST\EXPR\TYPE\TYPEU}\TYPEU
    }
  \end{mathpar}
  \caption{Typing rules for expressions (excerpt)}
  \label{fig:typing-expressions}
\end{figure}
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule{
      \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
      \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
      \JTypeExpr\TEnv{\EXPR_3}\TPUK \\
      % \JTypeExpr\TEnv{\EXPR_3}{\TCONTRACT\ \TUNIT} \\
      \JTypeExpr\TEnv{\EXPR_4}\TUNIT \\
      \JTypeExpr\TEnv{\EXPR_5}\TTEZ }{
      \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH\
      \TNO\ \TNO
    }

    \inferrule{
      \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
      \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
      \JTypeExpr\TEnv{\EXPR_3}\TCONTRACT\ \TYPE_p\ \TYPE_s \\
      \JTypeExpr\TEnv{\EXPR_4}{\TYPE_p} \\
      \JTypeExpr\TEnv{\EXPR_5}\TTEZ }{
      \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}{\TOPH\
      \TNO\ \TNO}
    }


    \inferrule{
      \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
      \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
      \JTypeExpr\TEnv{\EXPR_3}{\TCODE\ \TYPE_p\ \TYPE_s} \\
      \JTypeExpr\TEnv{\EXPR_4}\TYPE_s \\ % really \TSTRING \\
      \JTypeExpr\TEnv{\EXPR_5}\TTEZ }{
      \JTypeExpr\TEnv{\ORIGINATE{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_4}{\EXPR_5}}{\TOPH\
      \TYPE_p\ \TYPE_s}
    }
  \end{mathpar}
\begin{mathpar}
  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR\TPUK
  % }{
  %   \JTypeExpr\TEnv {\GETCOUNTER\EXPR}\TINT
  % }
  %   
  \inferrule{
    \JTypeExpr\TEnv\EXPR\TADDR
  }{
    \JTypeExpr\TEnv {\GETBALANCE\EXPR}\TTEZ
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TOPH\ \TYPE\ \TYPEU}
  }{
    \JTypeExpr\TEnv {\GETSTATUS\EXPR}\TSTATUS
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TCONTRACT\ \TYPE_p\ \TYPE_s}
  }{
    \JTypeExpr\TEnv {\GETSTORAGE\EXPR}\TYPE_s
  }

  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  % }{
  %   \JTypeExpr\TEnv {\GETCODE\EXPR}?
  % }
  %   
  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  % }{
  %   \JTypeExpr\TEnv {\GETTYPE\EXPR}?
  % }
  %   
  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TOPH\ \TYPE\ \TYPEU}
  }{
    \JTypeExpr\TEnv {\GETCONTRACT\EXPR}{\TCONTRACT\ \TYPE\ \TYPEU}
  }
\end{mathpar}
  \caption{Typing rules for blockchain operations and queries}
  \label{fig:typing-blockchain-operations}
\end{figure}
% Generic rule for transfers
% \begin{mathpar}
%  \inferrule{
%    \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
%    \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
%    \JTypeExpr\TEnv{\EXPR_3}\TADDR \\
%    \JTypeExpr\TEnv{\EXPR_4}\TSTRING \\
%    \JTypeExpr\TEnv{\EXPR_5}\TTEZ
%  }{
%    \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
%  }
% \end{mathpar}

% Conversion to and from serialized storage; deserialization may fail
% with an exception
% \begin{mathpar}
%   \inferrule{
%     \JTypeExpr\TEnv\EXPR\TYPE \\
%     \SERIALIZABLE (\TYPE)
%   }{
%     \JTypeExpr\TEnv{\TOSTRING\ \EXPR}\TSTRING
%   }

%   \inferrule{
%     \JTypeExpr\TEnv{\EXPR}\TSTRING
%   }{
%     \JTypeExpr\TEnv{\FROMSTRING\ \TYPE\ \EXPR}\TYPE
%   }
% \end{mathpar}



\subsection{Global Structures}
\label{sec:global}

Our execution model abstracts from the particulars of the blockchain
implementation, like the peer-to-peer structure or the distributed
consensus protocol. Hence, we represent the blockchain by a few global
entities: managers, contractors, and a pool of operations. 

%\begin{definition}%[Manager]
A \emph{manager} keeps track of a single implicit account. Managers are
represented by a partial map $\MANAGERS : \TPUK \partialto \TBAL
\times \TCOU$. If $\MANAGERS (\PUK) = \Angle{\BAL, \COU}$ is defined, then  $\PUK$ is the
public key of an account, $\BAL$ is its
balance and $\COU$ is its counter whose form is a value-flag pair
$(n,b) \in \Nat\times\TBOOL$, where $n$ is the value of the counter
and ${b}$ is its flag.   The counter is used internally to serialize transactions.
%\end{definition}

%\begin{definition}%[Contractor]
A \emph{contractor} manages a smart contract. Contractors are
represented by a partial map $\CONTRACTORS : \TPUH \partialto
\TCODE \times \TIME  \times \TBAL \times  \TSTORAGE$. If $\CONTRACTORS (\PUH) = \langle
\CODE, \TIME, \BAL, \STORAGE \rangle $ is defined, then $\PUH$ is the
public hash of a contract,
$\CODE$ is its  code,
$\TIME$ is the time when it was accepted,
$\BAL$ is its current balance,
and $\STORAGE$ is its current storage. The hash $\PUH$ is
self-verifying as it is calculated from the fixed components $\CODE$
and $\TIME$. All time stamps will be different in our model.
% \end{definition}

When an operation is started on a node, it enters a \emph{pool} as a
pending operation. A pending operation is either dismissed after some time or
promoted to an included operation, which has become a permanent part
of the blockchain.

 %\begin{definition}%[Pending operation]
%An \emph{operation} is represented by a tuple  $\langle  \OP, \TIME, \STATUS \rangle $, where $\OP$ is an operation, $\TIME$ is the time when the operation was injected, and $\STATUS$ is either $\STATUSPENDING$,$\STATUSINCLUDED\ \TIME'$, or $\STATUSTIMEOUT$.  
%\end{definition}
%\begin{definition}
The pool is a partial map $  \PENDING= \TOPH \partialto
\TOP\times \TTIME \times \TSTATUS$ where
\begin{align*}
  \TSTATUS&= \STATUSPENDING + \STATUSINCLUDED\ \TTIME + \STATUSTIMEOUT
\end{align*}
such that
if $\PENDING(\OPH) = \langle  \OP, \TIME, \STATUS
\rangle $ is defined, then $\OPH$ is the public hash of the operation, $\OP$ is the operation, $\TIME$ is the time when the
operation was injected, and $\STATUS$ is either $\STATUSPENDING$,
$\STATUSINCLUDED\ \TIME'$, or $\STATUSTIMEOUT$.
A pool $\PENDING$ is \emph{well-formed} if, for all $\OPH$, $\PENDING (\OPH) =
\Angle{\OP,\TIME, \STATUSINCLUDED\ \TIME'}$ implies $\TIME' \ge
\TIME$ and $\OPH = \GENERATEOPH (\OP, \TIME)$.
%\end{definition}


A \emph{pending operation} is represented by
$\OPH \mapsto \langle  \OP, \TIME, \STATUSPENDING\rangle $.
Once the operation is accepted, it changes its status to included:
$\OPH \mapsto \langle  \OP, \TIME, \STATUSINCLUDED\ \TIME'\rangle $, where
$\TIME' \ge \TIME$ is  when the operation was included in the
blockchain.  The operation may also be dropped at any time, which is
represented by
$\OPH \mapsto \langle  \OP, \TIME, \STATUSTIMEOUT\rangle $. There are several
causes for dropping, primarily timeout or overflow of the pending
pool which is limited in size in the implementation.


% After some time, a pending operation may be included in the blockchain as an accepted operation.

 % \begin{definition}%[Accepted operation]
% An \emph{accepted operation}  is a tuple $\langle  \OP, \OPH, \TIME, \TIME' \rangle
% $, where $\OP$ is an operation, $\OPH$ is the operation hash, $\TIME$ is the time when the operation was injected, and
% $\TIME'$ is the time when it was included in the blockchain. 
% \end{definition}

%\begin{definition}%[Blockchain]
In summary, the \emph{state of a blockchain} is a tuple
$\BLOCKCHAIN = [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]$ where
$\PENDING$ is a pool of operations, $\MANAGERS$ is a map of managers,
$\CONTRACTORS$ is a map of contractors, and $\TIME$ is the current
time. 
% \end{definition}

We often use the dot notation to project a component from a tuple. For
instance, we write $\BLOCKCHAIN.\MANAGERS$ to access the managers
component. 

%\begin{definition}%[Blockchain system]
A \emph{blockchain configuration} has the form
$\BLOCKCHAIN[ \NODE_1, \dots, \NODE_n]$, for some $n>0$, where $\BLOCKCHAIN$ is a
blockchain and the $\NODE_i$ are local nodes, for $1\le i\le n$.
In a \emph{well-formed configuration}, the accounts on the local nodes are all different and each
local account has a manager in $\BLOCKCHAIN$:
\begin{enumerate}
\item for all $1\le i< j\le n$, $\NODE_i.\ACCOUNTS \cap
  \NODE_j.\ACCOUNTS = \emptyset$;
\item for all $1\le i \le n$, 
    $\forall a \in \NODE_i.\ACCOUNTS \implies a.\PUK \in \DOM( \BLOCKCHAIN.\MANAGERS)$.
\end{enumerate}
%\end{definition}

\section{Operational Semantics}
\label{sec:transitions}

The operational semantics is defined by several kinds of transitions depending on their scope:
\begin{enumerate}
\item $\ExprTrans$ single-step evaluation of an expression in a local node,
\item $\NodeTrans$ internal transitions of a node,
\item $\BlockTrans$ transitions of the blockchain state,
\item $\SystemTrans$ blockchain system transitions.
\end{enumerate}

Evaluation of expressions is standard for call-by-value lambda calculus defined
using evaluation contexts
$\EC{}$. Figure~\ref{fig:expression-reduction} shows some of the
reduction rules. 
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule{}{ \EC{(\lambda x.\EXPR)\VAL} 
      \ExprTrans 
      \EC{\EXPR[\VAL/x]} }

    \inferrule{}{ \EC{\TRY\ \VAL\ \EXCEPT\ \EXPR} \ExprTrans \EC{\VAL} }

    % \inferrule{}{
    % \EC{\FST (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_1}
    % }
  %   
    %   \inferrule{}{
    %   \EC{\SND (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_2}
    % }
  %   
    \inferrule{\TYPE \SubType \TYPEU}{ \EC{\CAST\VAL\TYPE\TYPEU} \ExprTrans \EC{\VAL}}

    \inferrule{ \TRY \notin \EC[F]{} }{ \EC{\TRY\ {\EC[F]{\RAISE\
            \VAL}}\ \EXCEPT\ \EXPR} \ExprTrans \EC{\EXPR\ \VAL} }
    %
    % \inferrule{}{ \EC{\MATCH\ (\VAL_1, \VAL_2) \WITH\ (x_1,
    %     x_2)\to\EXPR \mid \dots} \ExprTrans \EC{\EXPR[\VAL_1,
    %     \VAL_2/x_1, x_2]} }
    % \inferrule{}{ \EC{\MATCH\ \NIL\ \WITH\ \NIL\to\EXPR \mid \dots}
    %   \ExprTrans \EC{\EXPR} }
    % \inferrule{}{ \EC{\MATCH\ (\CONS\ \VAL_1\ \VAL_2)\ \WITH\ (\CONS\
    %     x_1\ x_2)\to\EXPR \mid \dots} \ExprTrans
    %   \EC{\EXPR[\VAL_1,\VAL_2/x_1, x_2]} }
    % \inferrule{}{ \EC{\MATCH\ \NONE\ \WITH\ \NONE\to\EXPR \mid \dots}
    %   \ExprTrans \EC{\EXPR} }
    % \inferrule{}{ \EC{\MATCH\ (\SOME\ \VAL)\ \WITH\ (\SOME\ x)\to\EXPR
    %     \mid \dots} \ExprTrans \EC{\EXPR[\VAL/x]} }
    % \inferrule{}{ \EC{\MATCH\ (\LEFT\ \VAL)\ \WITH\ (\LEFT\ x)\to\EXPR
    %     \mid \dots} \ExprTrans \EC{\EXPR[\VAL/x]} }
    % \inferrule{}{ \EC{\MATCH\ (\RIGHT\ \VAL)\ \WITH\ (\RIGHT\
    %     x)\to\EXPR \mid \dots} \ExprTrans \EC{\EXPR[\VAL/x]} }
  \end{mathpar}
  \caption{Select expression reduction rules (pattern matching omitted)}
  \label{fig:expression-reduction}
\end{figure}
The internal transitions of a node are just evaluation of expressions.
\begin{mathpar}
  \inferrule[Node-Eval]
  {
    \EXPR \ExprTrans \EXPR'
  }{
    [\EC\EXPR :: \EXPRS, \ACCOUNTS] \NodeTrans{}
    [\EC{\EXPR'} :: \EXPRS, \ACCOUNTS]
  }
\end{mathpar}
The remaining transitions affect a local node in the context of the
blockchain. To this end, any local node may be selected.
\begin{mathpar}
  \inferrule[Config-System]{
    \NODE\|\BLOCKCHAIN \SystemTrans \NODE'\|\BLOCKCHAIN'
}{
    \BLOCKCHAIN[\NODE :: \overline{\NODE}] \SystemTrans
    \BLOCKCHAIN'[\NODE' :: \overline{\NODE}]
  }

  \inferrule[Config-Node]
  {\NODE \NodeTrans \NODE'}
  { {\BLOCKCHAIN[\NODE :: \overline\NODE]}
    \SystemTrans
    {\BLOCKCHAIN[\NODE' :: \overline\NODE]}}

  \inferrule[Config-Block]
  {\BLOCKCHAIN \BlockTrans \BLOCKCHAIN'}
  { \BLOCKCHAIN[{\overline\NODE}]
    \SystemTrans
    \BLOCKCHAIN'[{\overline\NODE}]}
\end{mathpar}


\begin{figure}[tp]
\begin{mathpar}
  \inferrule[Node-Inject]{
    \Angle{\PAK,\PUK} \in \ACCOUNTS \\
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKARG (\CONTRACTORS, \PUH, \PARAMETER) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUH (\CONTRACTORS, \PUH) \\
    \CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ) \\
    \OPH = \GENERATEOPH (\OP, \TIME) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ    
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] } \SystemTrans \\
   { [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
     [ \OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     ::\PENDING,
     \UPDATECOU(\MANAGERS, \PUK, \TRUE),
     \CONTRACTORS,
     \TIME]
   }
 }

  \inferrule[Node-Reject]{
    \NEG\ \CHECKBAL (\BLOCKCHAIN.\MANAGERS, \OP.\PUK, \OP.\NTEZ, \OP.\MTEZ) \\
    }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      } \SystemTrans
    { [\EC{\RAISE\ \ERRBAL} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
  }

  \inferrule[Block-Accept]{
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
    \TIME - \hat\TIME \le 60
  }{
    { 
      [\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSPENDING}
     ::\PENDING, \MANAGERS,
      \CONTRACTORS, \TIME]}
    \BlockTrans 
    {
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING}, \\
      { \UPDATESUCC (\MANAGERS, \PUK, \NTEZ, \MTEZ), 
       \UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER), \TIME +1]
    }
  }

    \inferrule[Block-Timeout]{
    \TIME-\hat\TIME > 60
  }{ 
    {[\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSPENDING}
     ::\PENDING, \MANAGERS,
      \CONTRACTORS, \TIME]}
    \BlockTrans \\
    { 
      [\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSTIMEOUT}
     :: \PENDING,  \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
      \CONTRACTORS, \TIME]}
  }
\end{mathpar}
  
  \caption{Lifecycle transitions of a transaction}
  \label{fig:lifecycle-transaction}
\end{figure}
Figure~\ref{fig:lifecycle-transaction} shows the transitions to start
and finalize a transfer transaction, namely a smart contract invocation.
\TirName{Node-Inject} affects a local node and the blockchain. It
nondeterminstically selects a program that wants to do a transfer
operation. It
checks whether the sender of the transfer is a valid local account, whether
the balance is sufficient to pay the fee and the transferred amount,
whether there is an active transition for this sender (chkCount),
whether the public hash is associated with a smart contract on the blockchain, whether the type of the input parameter matchs with the smart contract's parameter type (chkArg), and whether the fee is
sufficient. If these conditions are fulfilled, the transition forges
an operation hash and returns it to the local node. 
The pending operation enters the pool and the sender's counter is set
to indicate an ongoing transition.

We give just one example \TirName{Node-Reject} of the numerous
transitions that cover the cases where one of the 
premises of \TirName{Node-Inject} is not fulfilled. Each of them
raises an exception that describes which condition was violated.

Acceptance or rejection of a pending operation happens on the
blockchain independent of any local node. In our model, these
transitions are nondeterministic so that acceptance can happen any
time in the next 60 cycles \TirName{Block-Accept}. Afterwards, a
pending operation can only time out \TirName{Block-Timeout}.
If the transaction is accepted, then the sender's counter is reset,
the balances of sender is adjusted (updSucc), the smart contract's storage and balance are updated (updConstr), and the time stamp increases.

Whereas \TirName{Node-Inject} and \TirName{Block-Accept} are
particular to the transfer operation, the timeout transition applies
to all operations. It just changes the state of the operation and
resets the sender's counter, thus rolling back the transaction.

% \begin{itemize}
% \item library call \texttt{call\_contract} with \texttt{confirmations:None} corresponds to
%   \begin{enumerate}
%   \item{} first \TirName{Node-Op'}, \TirName{Node-Inject'}
%   \item{} first \TirName{Node-Op'}, \TirName{Node-Reject(balance,count,pubkey,fee)}
%   \end{enumerate}
% \item afterwards must check the status to find whether the
%   transfer is still pending or \TirName{Block-Accept''} or
%   \TirName{Block-Timeout''} has happened.
% \item no further transfer is possible before the status is resolved to
%   accept or timeout.
% \end{itemize}

\subsection{Cast Reductions}
\label{sec:special-reductions}

\begin{figure}[tp]
\begin{mathpar}
  \inferrule[Contract-Yes]{
    \JTypeCode\CODE{\TPAIR\ \TYPE\ \TYPEU} \\
    \BLOCKCHAIN.\CONTRACTORS (\PUH) =  \Angle{\CODE, \tilde\TIME, \NTEZ', \STRING'}
    %
    }{
    { [\EC{\CAST\PUH\TPUH{\TCONTRACT\ \TYPE}}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\PUH} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }

  % \inferrule[Contract-Implicit?]{
  %   \PUK \in \DOM(\BLOCKCHAIN.\MANAGERS)
  %   %
  %   }{
  %   { [\EC{\CONTRACT\ \TUNIT\ \PUK}  :: \EXPRS, \ACCOUNTS] \|
  %     \BLOCKCHAIN
  %   }
  %   \SystemTrans
  %   { [\EC{\SOME\ \PUK} :: \EXPRS, \ACCOUNTS] \|
  %     \BLOCKCHAIN
  %  }
  % }
  %
  \inferrule[Contract-No]{
    % \ADDR \in \DOM (\BLOCKCHAIN.\MANAGERS) \Rightarrow \TYPE\ne\TUNIT \\
    \BLOCKCHAIN.\CONTRACTORS (\PUH) = \Angle{\CODE, \tilde\TIME,
      \NTEZ', \STRING'} \Rightarrow {}
        \JTypeCode\CODE{\TPAIR\ \TYPE'\ \TYPEU} \wedge \TYPE \ne \TYPE' \\
    }{
    { [\EC{\CAST\PUH\TPUH{\TCONTRACT\ \TYPE}}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\RAISE\ \ERRPRG} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }
\end{mathpar}
  \caption{Cast reductions (excerpt)}
  \label{fig:cast-reductions}
\end{figure}
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule[Block-Originate]{
      \Angle{\PAK,\PUK} \in \ACCOUNTS \\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
      \CHECKCOU (\MANAGERS, \PUK) \\
      \CHECKPRG (\CODE) \\
      \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ)  \\
      \CHECKINIT (\CODE, \STRING) \\
      % \OPH = \GENERATEOPH(\PUK, \CODE, \STRING, \NTEZ, \MTEZ, \TIME)
      % \\
      \OPH = \GENERATEOPH(\OP, \TIME) \\
      \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ }{ [\EC\OP :: \EXPRS,
      \ACCOUNTS
      ] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \to \\
      [\EC{\OPH} :: \EXPRS, \ACCOUNTS] \| [\OPH \mapsto \Angle{\OP,
        \TIME, \STATUSPENDING} ::\PENDING,
      \UPDATECOU(\MANAGERS,\PUK,\TRUE), \CONTRACTORS, \TIME] }

  \inferrule[Block-Accept]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \PUH = \GENERATEHASH(\CODE, \TIME) \\
    \TIME-\hat\TIME  \le 60
  }{
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING} :: \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    \BlockTrans \\
     [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, \UPDATESUCC
      (\MANAGERS, \PUK, \NTEZ, \MTEZ),\\ \PUH \mapsto  \Angle{\CODE, \TIME, \NTEZ, \STRING} :: \CONTRACTORS, \TIME+1]
  }

    \inferrule[Block-Accept-Query]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \PENDING (\OPH) =  \Angle{\OP,
      \hat\TIME, \STATUSINCLUDING\ \tilde\TIME} \\
    \PUH = \GENERATEHASH (\CODE, \tilde\TIME)
    % \CONTRACTORS (\PUH) =  \Angle{\CODE, \tilde\TIME, \NTEZ', \STRING'}
  }{
      [\EC{\GETCONTRACT\ \OPH}  :: \EXPRS, \ACCOUNTS] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    \SystemTrans 
     [\EC{ \PUH}  :: \EXPRS, \ACCOUNTS] \|  [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}
  \caption{Smart contract origination}
  \label{fig:contract-origination}
\end{figure}
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule[Query-Balance-Implicit]{
      % \BLOCKCHAIN =
      % [\PENDING, \PUK \mapsto \Angle{\BAL, \COU} :: \MANAGERS,
      % \CONTRACTORS, \TIME]
      \BLOCKCHAIN.\MANAGERS (\PUK) = \Angle{\BAL,\COU}
    }{[\EC{\GETBALANCE\PUK} :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN
      \SystemTrans\ [\EC{\BAL} ::\EXPRS, \ACCOUNTS] \| \BLOCKCHAIN}

    \inferrule[Query-Balance-Fail]{ \PUK \notin \DOM
      (\BLOCKCHAIN.\MANAGERS) \ }{[\EC{\GETBALANCE\PUK} :: \EXPRS,
      \ACCOUNTS] \| \BLOCKCHAIN \SystemTrans {[\EC{\RAISE\ \ERRPUK}
        ::\EXPRS, \ACCOUNTS] \| \BLOCKCHAIN}}
  \end{mathpar}
  \caption{Example queries}
  \label{fig:example-queries}
\end{figure}


Figure~\ref{fig:cast-reductions} contains the most interesting
example of cast reductions, from a public hash to a typed
contract. These reductions force the local node to obtain information
from the blockchain. The cast succeeds \TirName{Contract-Yes} on \PUH, if there is a
contractor for \PUH\ such that the stored code has the parameter type
expected by the cast. The cast fails \TirName{Contract-No}, if \PUH\
is invalid or if the types do not match.




\subsection{Smart Contracts}
\label{sec:smart-contracts}

The invocation of smart contracts is similar to a transfer, so we
elide the details. Figure~\ref{fig:contract-origination} contains the
transition \TirName{Block-Originate} to originate a smart contract. The basic scheme is similar
to the transfer. The preconditions for the operation are checked, but
there are extra preconditions for origination:  the program must be
well-formed and typed, the initial storage value must match its
type. The operation ends up in the pool in pending status.

Acceptance of origination is slightly different as for transfers as
shown in \TirName{Block-Accept}. We calculate the public hash \PUH\ of the
contract from the code and the current time stamp and create a new
contractor at that address.  

We obtain the handle of the contract through a query, once the
contract is accepted on the blockchain in
\TirName{Block-Accept-Query}. The query's argument is the operation
hash, which is used to obtain the code and the time stamp of its
acceptance. From this information, we can re-calculate the public
hash. 

\subsection{Queries}
\label{sec:queries}


We conclude with two example transitions for a simple query in
Figure~\ref{fig:example-queries}. To obtain the balance of an implicit
account \PUK, we obtain the account info from the manager and extract
the balance (\TirName{Query-Balance-Implicit}). If the account is
unknown, then we raise an exception
(\TirName{Query-Balance-Fail}). Other queries are implemented analogously.

\section{Properties}
\label{sec:properties}

\subsection{Properties of blockchain state transitions}

Running a program that starts with valid references to accounts,
operations, and contracts does not get corrupted by a transition.
\begin{proposition}
  The following properties are preserved by a step on a well-formed
  configuration $ [\EXPRS, \ACCOUNTS] \| \BLOCKCHAIN$:
  \begin{itemize}
  \item for all $\OPH$ in $\EXPRS$, $\OPH \in \DOM (\BLOCKCHAIN.\PENDING)$,
  \item for all $\PUK$ in $\EXPRS$, $\PUK \in \DOM (\BLOCKCHAIN.\MANAGERS)$,
  \item for all $\PUH$ in $\EXPRS$, $\PUH \in \DOM (\BLOCKCHAIN.\CONTRACTORS)$.
  \end{itemize}
\end{proposition}

\begin{proposition}
If $[\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \BlockTrans{}
[\PENDING', \MANAGERS', \CONTRACTORS', \TIME']$, then
\begin{enumerate}
\item $\TIME \le \TIME'$
\item\label{item:1} $\DOM (\PENDING) \subseteq \DOM(\PENDING')$
\item invariant for the pool: if  $\PENDING (\OPH) = \Angle{\OP,
    \hat\TIME, \STATUS}$, then $\OPH = \GENERATEOPH (\OP,
  \hat\TIME)$. 
\item\label{item:7} for all $\OPH \in \DOM(P)$, if 
  $\PENDING (\OPH) = \Angle{\OP,  \hat\TIME, \STATUS}$, then either
  \begin{itemize}
  \item     $\PENDING'    (\OPH) = \PENDING (\OPH)$; or
  \item $\STATUS  = \STATUSPENDING$ and $\PENDING' (\OPH) =
    \Angle{\OP, \hat\TIME, \STATUSTIMEOUT}$; or
  \item  $\STATUS  = \STATUSPENDING$, $\TIME - \hat\TIME
    \le 60 $, 
    $\PENDING' (\OPH) =       \Angle{\OP, \hat\TIME, \STATUSINCLUDED\
      \TIME}$, and $\TIME'=\TIME+1$.
  \end{itemize}
 \item\label{item:2} for all $\OPH \in \DOM(P)$ and $\PENDING (\OPH) = \Angle{\OP,  \hat\TIME, \STATUS}$, 
    \begin{itemize}
    	\item  if $\STATUS=\STATUSPENDING$ and $\MANAGERS(\OP.\PUK) =  \Angle{\BAL, \COU}$ then  
  $\COU.b = \TRUE$ and $\BAL \ge \OP.\NTEZ + \OP.\MTEZ$;
\item if $\STATUS=\STATUSINCLUDED\ \hat\TIME$, then $\hat\TIME<\TIME'$.
    \end{itemize}
 \item\label{item:3} $ \DOM (\MANAGERS) \subseteq \DOM (\MANAGERS')$
 \item\label{item:4} for all $\PUK \in \DOM (\MANAGERS)$\\
   if $\MANAGERS (\PUK) =
   \Angle{\BAL, \COU}$, 
   then $\MANAGERS' (\PUK) =
   \Angle{\BAL', \COU'}$ and
   \begin{itemize}
   \item if $\COU.b=\TRUE$ and $\COU'.b=\FALSE$, then $\COU.n' \in \{
     \COU.n,  \COU.n+1\}$,
   \item otherwise $\COU.n = \COU'.n$
   \item If $\COU.n = \COU'.n$, then $\BAL = \BAL'$.
   % \item if $\COU.b= \FALSE$, then $n' = n$
   % \item if $\COU.b= \TRUE$ and $b'=\TRUE$, then $n' =n$
   \end{itemize}

 \item\label{item:5} $ \DOM (\CONTRACTORS) \subseteq \DOM (\CONTRACTORS')$
   \begin{itemize}
   \item for all $\PUH \in \DOM (\CONTRACTORS)$,
     $\CONTRACTORS (\PUH).\CODE = \CONTRACTORS' (\PUH).\CODE$
   \end{itemize}
 \item\label{item:6} invariant for contractors:
   for all $\PUH \in \DOM (\CONTRACTORS)$,
   $\CONTRACTORS (\PUH) = \Angle{ \CODE, \tilde\TIME, \BAL, \STORAGE}$
   implies that $\PUH = \GENERATEHASH (\CODE, \tilde\TIME)$.
\end{enumerate}
\end{proposition}
Establishing items~\ref{item:7} and~\ref{item:4} relies on the preimage resistance of the
various hash functions used to calculate operation hashes and public
hashes: we always feed a fresh timestamp into the hash
functions for operations and code. Items~\ref{item:1}--\ref{item:2} describe an invariant and
the lifecycle of 
operations. Items~\ref{item:3} and \ref{item:4} describe the lifecycle
of a transfer and items~\ref{item:5} and~\ref{item:6} describe
invariants for contractors. The invariants establish the
self-verifying property common of blockchain entities.

The proofs of these properties refer to all transitions with the detailed specifications of the related functions, such as chkCount and updSucc. Due to page limitations, not all transitions and their associated functions are presented in this paper, so the full proofs will be provided in an upcoming technical report. In this paper, we only provide the proofs for Proposition 2 at items 4 and 7.  

\begin{proof}[4]
 After feeding into a node, the status of the operation is \STATUSPENDING\ according to the transition \TirName{Node-Inject}. This operation could either be accepted by the blockchain on the condition that the elapsed time is less than 60 ($\TIME - \hat\TIME \le 60$), and then its status is \STATUSINCLUDED\ \TIME \ (the transition \TirName{Block-Accept}) or it is timed out with the status \STATUSTIMEOUT\ (\TirName{Block-Timeout}). When an operation is accepted or timed out, its status is never changed. Therefore, there are the following three cases:
 
 \begin{itemize}
 \item if the operation remains the same (still in \STATUSPENDING, \STATUSINCLUDED\ or \STATUSTIMEOUT), then we have $\PENDING' (\OPH) = \PENDING (\OPH)$; 
 \item if the operation is \STATUSPENDING\ and times out, then we have $\PENDING' (\OPH) = \Angle{\OP, \hat\TIME, \STATUSTIMEOUT}$ according to the transition \TirName{Block-Timeout}; 
 \item if the operation is \STATUSPENDING, the time condition is satisfied, and then the operation is accepted, then we have $\PENDING' (\OPH) = \Angle{\OP, \hat\TIME, \STATUSINCLUDED\ \TIME }$, and $\TIME'=\TIME +1$ because the timestamp is incremented by one according to the transition \TirName{Block-Accept}.
 \end{itemize}

\end{proof}

\begin{proof}[7]To prove this point, let us consider the two related functions. The function $\UPDATECOU(\MANAGERS, \PUK, \BOOLEAN)$ updates the flag of the counter of the account associated with the public key $\PUK$. Its specification is as follows:
 \begin{itemize}
   \item[] \UPDATECOU($\PUK \mapsto \langle \BAL, (\NAT, \hat\BOOLEAN) \rangle$, \BOOLEAN) = $\PUK \mapsto \langle \BAL, (\NAT, \BOOLEAN) \rangle $
 \end{itemize}
    
    The function $\UPDATESUCC(\MANAGERS, \PUK, \NTEZ, \MTEZ)$ updates the balance and the counter of the account associated with the public key $\PUK$. Its specification is as follows:
 \begin{itemize}
   \item[]  \UPDATESUCC($\PUK \mapsto \Angle{\BAL, (\NAT, \TRUE)}$, \NTEZ, \MTEZ) = $ \PUK \mapsto \Angle{\BAL - \NTEZ - \MTEZ, (\NAT + 1, \FALSE)}$    
 \end{itemize}
    
\noindent if $\MANAGERS (\PUK) =
   \Angle{\BAL, \COU}$, 
   then $\MANAGERS' (\PUK) =
   \Angle{\BAL', \COU'}$ and we have the following points:
 \begin{itemize}
   \item[-] $\COU.b=\TRUE$ means that the operation is injected and its status is \STATUSPENDING\ at the time \TIME \ according to the transition \TirName{Node-Inject}.  After that, there are only two cases where the counter's flag is reset to False. (1) If the operation is accepted, the counter's flag is reset ($\COU'.b=\FALSE$) according to the transition \TirName{Block-Accept} and the counter's value is incremented by 1 according to the specification of the function \UPDATESUCC\ ($\COU.n' =\COU.n+1$). (2) In another case, if the operation is timed out, the counter's flag is also reset to False, but the value of the counter remains the same ($\COU.n' =\COU$) according to the transition \TirName{Block-timeout}. That is, if $\COU.b=\TRUE$ and $\COU'.b=\FALSE$, then $\COU.n' \in \{\COU.n, \COU.n+1\}$;
   \item[-] otherwise, if the operation is still \STATUSPENDING, the counter's value remains the same. This means $\COU.n = \COU'.n$; 
   \item[-] and then $\COU.n = \COU'.n$ means that the operation is either still \STATUSPENDING\ or that it has timed out. Therefore, the balance of the account remains the same because the balance is only changed when the operation is accepted. This means $\BAL = \BAL'$.
 \end{itemize}
\end{proof}


\subsection{Typing related properties}
% , the parameter type and the storage type.
To describe the typing of contracts we maintain an environment
$\Delta ::= \EmptyEnv \mid \PUH: \TYPE, \Delta$ that associates a
public hash with a type.
We define typing for blockchains, local nodes, and configurations.
\begin{mathpar}
  \inferrule{
    \DOM (\Delta) = \DOM (\BLOCKCHAIN.\CONTRACTORS) \\
    (\forall\PUH\in\DOM (\Delta)) \\
    \Delta (\PUH) = \TPAIR\ \TYPE_p\ \TYPE_s \\
    \JTypeCode{\BLOCKCHAIN.\CONTRACTORS (\PUH).\CODE} {\TPAIR\ \TYPE_p\ \TYPE_s}
    \\
    \JTypeValue{\BLOCKCHAIN.\CONTRACTORS (\PUH).\STORAGE}{ \TYPE_s}
  }{\JTypeBlockchain\Delta\BLOCKCHAIN}
\end{mathpar}
The type for a hash is a pair type, which coincides with the type of
the code stored at that hash. The storage at that hash has the type
expected by the code.
\begin{mathpar}
  \inferrule{
    \JTypeExpr\cdot{ \EXPR_i}\TUNIT  }{
    \JTypeNode{[\overline{\EXPR}, \ACCOUNTS]}
  }

  \inferrule{\JTypeBlockchain\Delta\BLOCKCHAIN \\
    \JTypeNode{\NODE_i}
  }{\JTypeConfig\Delta{\BLOCKCHAIN[\overline\NODE]}}
\end{mathpar}

\begin{lemma}[Preservation]
  If $\BLOCKCHAIN[\overline\NODE] \SystemTrans{} \BLOCKCHAIN'[\overline\NODE']$ and
  $\JTypeBlockchain\Delta \BLOCKCHAIN$, then there is some
  $\Delta' \supseteq \Delta$ such that
  $\JTypeBlockchain{\Delta'}{ \BLOCKCHAIN'}$.
\end{lemma}
This lemma includes the standard preservation for the lambda calculus part.
\begin{lemma}[Progress]
  If $\JTypeConfig\Delta{\BLOCKCHAIN[\overline\NODE]}$, then either
  all expressions in all nodes are unit values or there is a
  configuration $\BLOCKCHAIN'[\overline\NODE']$ such that
  $\BLOCKCHAIN[\overline\NODE] \SystemTrans \BLOCKCHAIN'[\overline\NODE']$.
\end{lemma}
The consistency lemma says that all committed transactions respect the
typing.
\begin{lemma}[Consistency]
Consider a blockchain state with $\JTypeBlockchain\Delta {[\PENDING, \MANAGERS, \CONTRACTORS,
\TIME]}$.

For all $\OPH\in\DOM (\PENDING)$,
if  $\PENDING (\OPH) =  \Angle{\OP, \hat\TIME, \STATUS}$
\begin{itemize}
\item if $\OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ$, then
  $\PUK, \PUK' \in \DOM (\MANAGERS)$;
\item if $\OP = \TRANSFER[\PARAMETER]\NTEZ\PUK\PUH\MTEZ$, then
  \begin{itemize}
  \item $\PUK \in \DOM (\MANAGERS)$ and $\PUH\in\DOM (\CONTRACTORS)$,
  \item $\JTypeValue\PARAMETER{ \TYPE_p}$ where $\Delta (\PUH)  =\TPAIR\ \TYPE_p\ \TYPE_s$;
  \end{itemize}
\item if $\OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ$ and $\STATUS =
  \STATUSINCLUDED\ \TIME'$, then
  \begin{itemize}
  \item $\PUK \in \DOM (\MANAGERS)$ and  $\PUH =\GENERATEHASH (\CODE, \TIME') \in \DOM (\CONTRACTORS)$,
  \item $\Delta (\PUH)  =\TPAIR\ \TYPE_p\ \TYPE_s$,  $\JTypeCode\CODE{
      \TPAIR\ \TYPE_p\ \TYPE_s}$ and $\JTypeValue\STRING{ \TYPE_s}$.
  \end{itemize}
\end{itemize}
\end{lemma}

\begin{proof} Consider the proof of the second item of Lemma 3, which specifies the property on type for a smart contract invocation. A smart contract call \OP\ has the form \TRANSFER [\PARAMETER]\NTEZ\PUK\PUH\MTEZ. If $\PENDING (\OPH) = \Angle{\OP, \hat\TIME, \STATUS }$, then the operation $\OP$ is injected into the node. According to the transition \TirName{Node-Inject} for a smart contract invocation, the public key is valid and the public hash must be associated with a smart contract on the blockchain. This means $\PUK \in \DOM (\MANAGERS)$ and $\PUH\in \DOM (\CONTRACTORS)$. The chkArg function checks whether the type of the input parameter \PARAMETER\ matches the parameter type of the smart contract. If the casted type of the smart contract is $\Delta (\PUH) =\TPAIR\ \TYPE_p\ \TYPE_s$, then the type of the parameter  must be $\TYPE_p$. This means $\JTypeValue\PARAMETER {\TYPE_p}$.
\end{proof}

\section{Related Work}
\label{sec:related work}
The inability to access external data sources limits the potential of
smart contracts. Oracles
\cite{oracle-patterns,call-action-oracle,oracles-study} can help
overcome this limitation by providing a bridge between the outside
sources and the blockchain network. A blockchain oracle is used to
provide external data to smart contracts. Several researches have been
done to provide oracle solutions for blockchain. Adler et al
\cite{blockchain-oracles} propose a framework to explain blockchain
oracles and various key aspects of oracles. This framework aims to
provide developers with a guide for incorporating oracles into
blockchain-based applications. Practically, the decentralized oracle
network Chainlink \cite{chainlink-whitepaper} is being developed to
provide reliable, tamper-proof input for smart contracts on any
blockchain. For a specific application, a system called Town Crier
\cite{town-crier} provides an authenticated data feed, sourced from
HTTPS-enabled data websites, for smart contracts on Ethereum. George
and Lesaege \cite{oracle-real-value} construct an oracle that can
estimate the value of a real quantity, such as $R$.  
For application to prediction markets, there are Truthcoin system
\cite{truthcoin-whitepaper} and Astraea, a trustless decentralized
oracle \cite{astraea}.   

The main problems with using a blockchain oracle are the untrusted
data provided maliciously or inaccurately \cite{trustworthy}. Ma at el
\cite{reliable-oracle} propose an oracle equipped with 
verification and disputation mechanisms. Similarly, Lo et al
\cite{reliablity-oracles} provide a framework for performing
reliability analysis of various blockchain oracle platforms. Closely
following our work, Nielsen and Spitters \cite{interact-coq} present a
model-executable specification of smart-contract execution in
Coq. Their formalizations target Ethereum and Tezos.  

\section{Conclusion}
\label{sec:conclusion}

We present a first step towards a typed API for smart contracts on the
Tezos blockchain. Our formalization enables us to establish basic
properties of the interaction between ordinary programs and smart
contracts. We see ample scope for future work to provide a
higher-level interface that exploits the similarities between
blockchain programming and concurrent programs.


\bibliographystyle{splncs04}
\bibliography{bio}


\end{document}

