\documentclass[a4paper]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{mathpartir}
\usepackage{fixme}

\input{macros}

\title{Blockchain System}

\author{}
\institute{}

\date{\today}

\begin{document}
\maketitle
\pagestyle{plain}

\section{Definitions}
\begin{definition}%[Set]
Let $\mathbf{Elt}$ be the set of (concrete) elements. Let $\emptyset$ be an empty set and $\mathbf{e}$ $\in$  $\mathbf{Elt}$. A set of elements is expressed as the following syntax:
\\
$\mathbf{s} :: = \emptyset \mid \mathbf{e} \mid \mathbf{s :: s}$
\end{definition}

\subsection{Local Node}
\label{sec:local-node}


\begin{definition}%[Account]
  An implicit \emph{account} is represented by a key pair $\langle
  %\ALS,
  \PAK, \PUK
  %, \PKH
  \rangle $, where
  $\PAK$ is its private key and $\PUK$ is its public key.
\end{definition}


\begin{definition}%[Operation]
  \emph{Operations} are defined by the following grammar:
  \begin{align*}
    \OP &::= \TRANSFER[\PARAMETER]\NTEZ\PUK\ADDR\MTEZ
    \\&\mid \ORIGINATE\NTEZ\PUK\CODE\INIT\MTEZ
  \end{align*}
  where \NTEZ\ and \MTEZ\ are tokens, \ADDR\ is either a public
  key for an implicit account  or a public hash for a smart contract,
  \PARAMETER\ is an argument passed to the smart contract's script,
  which is empty if it is a transfer to an implicit account, \CODE\ is
  a script of the smart contract, \INIT\ is an initial value of the
  contract's storage. 
\end{definition}

\begin{definition}%[Query]
\emph{Queries} are defined by the following grammar:
\begin{align*}
  \QRY & ::= \GETBALANCE\ADDR
  \\&\mid \GETSTATUS\OPH
  \\&\mid \GETSTORAGE\PUH
  \\&\mid \GETCODE\PUH 
  \\&\mid \GETCOUNTER\PUK
\end{align*}
\end{definition}

\begin{definition}%[Program]
\emph{Expressions} are defined by the following grammar:
\begin{align*}
  \CONSTANT & ::= \ADDR \mid \OPH \mid \PUH \mid\PUK \mid \CODE \mid
              \NTEZ \mid \SUNIT \mid \FALSE \mid \TRUE \\
  \STATUS & ::= \STATUSPENDING \mid \STATUSINCLUDING (\dots) \mid
            \STATUSTIMEOUT \\
  \ERROR &::= \ERRPRG \mid \ERRBAL \mid \ERRCOUNT \mid \ERRFEE \mid
           \ERRPUK \mid \ERRPUH \mid \ERRARG\\
	\EXPR & :: =  \CONSTANT \mid \STATUS \mid \ERROR \mid \VARIABLE \mid \lambda \VARIABLE. \EXPR\ 
	\mid \EXPR\EXPR \mid (\EXPR,\EXPR) \mid \FST\ \EXPR \mid \SND\ \EXPR 	%\mid \NI \EI
	\\&\mid \EXPR\ \PLUS\ \EXPR\ \mid \EXPR\ \MINUS\ \EXPR\ \mid \EXPR\ \EQUAL\ \EXPR\ \mid \EXPR\ \LESS\ \EXPR
	\\&\mid \EXPR\ \AND\ \EXPR\ \mid \EXPR\ \OR\ \EXPR\ \mid \NOT\ \EXPR
  \\&\mid \NIL\ \mid \CONS\ \EXPR\ \EXPR \mid \LEFT\ \EXPR \mid\RIGHT\
  \EXPR \mid \SOME\ \EXPR \mid \NONE
  \\& \mid \RAISE\ \EXPR \mid \TRY\ \EXPR\ \EXCEPT\ \EXPR
  \\& \mid \MATCH\ \EXPR\ \WITH\ \PATTERN\to\EXPR \dots
  \\& \mid \TRANSFER[\EXPR]\EXPR\EXPR\EXPR\EXPR
  \\& \mid \ORIGINATE\EXPR\EXPR\EXPR\EXPR\EXPR
  \\&\mid \QOP\  \EXPR\\
  \QOP & ::= balance \mid status \mid storage \mid code \mid counter
\end{align*}
We let $\EXPRS$ range over sets of expressions.

We let $\ECS$ range over evaluation contexts. They are defined as
follows.
\begin{align*}
  \EC{} & :: = \SC[\overline\VAL\ \EC{}\ \overline\EXPR] \mid \RAISE\ \EC{} \mid \TRY\ \EC{}\ \EXCEPT\ \EXPR
  \mid \MATCH\ \EC{}\ \WITH\ \PATTERN\to\EXPR \dots
\end{align*}
Here $\SC$ ranges over the remaining syntactic constructors, which are
treated uniformly: evaluation proceeds from left to right.
\begin{align*}
  \VAL & ::= \CONSTANT \mid \STATUS \mid \ERROR \mid \lambda x.\EXPR \mid(\VAL, \VAL) \mid
         \NIL \mid \CONS\ \VAL\ \VAL \mid \LEFT\ \VAL \mid \RIGHT\
         \VAL \mid \SOME\ \VAL\mid \NONE
\end{align*}
\end{definition}

Example pseudo code
\begin{align*}
  \OPH &=  \TRANSFER[\EXPR]\EXPR\EXPR\EXPR\EXPR \\
       & \MATCH\ {status\ \OPH}\ \WITH \\
       & \mid \STATUSPENDING \to \textrm{not yet included, continue waiting} \\
       & \mid \STATUSINCLUDING (n) \to \textrm{included with $n$
         blocks confirmation}\\
       & \mid \STATUSTIMEOUT \to \textrm{lost, try again}
\end{align*}
Grammar of types
\begin{align*}
  \TYPE & ::= \TADDR \mid \TOPH \mid \TPUH \mid \TPUK \mid \TCODE\ \TYPE \mid
          \TINT \mid \TUNIT \mid \TBOOL \mid \TSTRING \mid \TSTATUS \\
  & \mid \TYPE\to\TYPE \mid \TPAIR\ \TYPE\ \TYPE \mid \TLIST\ \TYPE
    \mid \TSUM\ \TYPE\ \TYPE \mid \TOPTION\ \TYPE \mid \TEXCEPTION
\end{align*}

\begin{definition}%[State of a node]
  The \emph{state of a node} is a tuple
  $\NODE = [ \EXPRS, \ACCOUNTS, \OPERATIONS]$, where $\EXPRS$ is a
  set of programs, $\ACCOUNTS \subseteq \TPAK \times \TPUK$  is a set of
  implicit accounts, and
  $\OPERATIONS \subseteq \ECS \times \TOP $ is a set of pairs of
  expression contexts and operations.
\end{definition}


\subsection{Global}
\label{sec:global}



\begin{definition}%[Manager]
A \emph{manager} manages a single implicit account. Managers are
represented by a partial mapping $\MANAGERS : \TPUK \partialto \TBAL
\times \TCOU$. If $\MANAGERS (\PUK) = \Angle{\BAL, \COU}$ is defined, then  $\PUK$ is the
public key of an account, $\BAL$ is its
balance and $\COU$ is its counter whose form is a value-flag pair
$(n,b) \in \Nat\times\TBOOL$, where $n$ is the value of the counter
and ${b}$ is its flag.   
\end{definition}

\begin{definition}%[Contractor]
  A \emph{contractor} manages a smart contract. Contractors are
  represented by a partial mapping $\CONTRACTORS : \TPUH \partialto
  \TBAL \times \TCODE \times \TSTORAGE$. If $\CONTRACTORS (\PUH) = \langle
  \BAL, \CODE, \STORAGE \rangle $ is defined, then $\PUH$ is the
  public hash of a contract, $\BAL$ is its current balance, $\CODE$ is its
  code, and $\STORAGE$ is its current storage.
\end{definition}

When an operation is injected in a node, it enters a \emph{pending
  pool}. Later on, such a pending operation is either dismissed or
promoted to an accepted operation.

 \begin{definition}%[Pending operation]
An \emph{operation} is represented by a tuple  $\langle  \OP, \TIME, \STATUS
\rangle $, where $\OP$ is an operation, $\TIME$ is the time when the
operation was injected, and $\STATUS$ is either $\STATUSPENDING$,
$\STATUSINCLUDING\ \TIME'$, or $\STATUSTIMEOUT$.  
\end{definition}
\begin{definition}
  The pool of operations is defined as a partial mapping from
  operation hashes $\OPH$:
  \begin{align*}
    \PENDING &= \TOPH \partialto \TOP\times \TTIME \times \TSTATUS \\
    \TSTATUS&= (\STATUSPENDING + \STATUSINCLUDED\ \TTIME + \STATUSTIMEOUT)
  \end{align*}
  
  A pool $\PENDING$ is \emph{well-formed} if, for all $\OPH$, if $\PENDING (\OPH) =
  \Angle{\OP,\TIME, \STATUSINCLUDED\ \TIME'}$, 
  then $\TIME' > \TIME$.
\end{definition}


A \emph{pending operation} is represented by
$\langle  \OP, \TIME, \STATUSPENDING\rangle $,
where $\OP$ is an operation, $\OPH$ is the operation hash,
and $\TIME$ is the time when the operation was injected.
Once it is accepted, it changes to an \emph{accepted operation}:
$\langle  \OP, \TIME, \STATUSINCLUDED\ \TIME'\rangle $, where
$\TIME'> \TIME$ is the  when the operation was included in the
blockchain.  The operation can also be dropped at any time, which is
represented by
$\langle  \OP, \TIME, \STATUSTIMEOUT\rangle $. There are several
causes for dropping, primarily timeout or overflow of the pending
pool which is limited in size in the implementation.


% After some time, a pending operation may be included in the blockchain as an accepted operation.

 % \begin{definition}%[Accepted operation]
% An \emph{accepted operation}  is a tuple $\langle  \OP, \OPH, \TIME, \TIME' \rangle
% $, where $\OP$ is an operation, $\OPH$ is the operation hash, $\TIME$ is the time when the operation was injected, and
% $\TIME'$ is the time when it was included in the blockchain. 
% \end{definition}

\begin{definition}%[Blockchain]
  The \emph{state of a blockchain} is a tuple
  $\BLOCKCHAIN = [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]$ where
  $\PENDING$ is a pool of operations, $\MANAGERS$ is a map of managers,
  $\CONTRACTORS$ is a map of contractors, and $\TIME$ is the current
  time. 
\end{definition}

Properties of blockchain state transitions

If $[\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \BlockTrans{}
[\PENDING', \MANAGERS', \CONTRACTORS', \TIME']$, then
\begin{itemize}
\item $\TIME \le \TIME'$
\item $\DOM (\PENDING) \subseteq \DOM(\PENDING')$
\item for all $\OPH \in \DOM(P)$, if  $\PENDING (\OPH) = \Angle{\OP,
    \TIME, \STATUS}$, then either
  \begin{itemize}
  \item     $\PENDING'    (\OPH) = \PENDING (\OPH)$; or
  \item $\STATUS  = \STATUSPENDING$ and $\PENDING' (\OPH) =
    \Angle{\OP, \TIME, \STATUSTIMEOUT}$; or
  \item  $\STATUS  = \STATUSPENDING$, $\BLOCKCHAIN'.\TIME - \TIME
    \le 60 $, and
    $\PENDING' (\OPH) =       \Angle{\OP, \TIME, \STATUSINCLUDED\
      \BLOCKCHAIN.\TIME}$.
  \end{itemize}
    
 \item $ \DOM (\MANAGERS) \subseteq \DOM (\MANAGERS')$
 \item for all $\PUK \in \DOM (\MANAGERS)$ if $\MANAGERS (\PUK) =
   \Angle{\BAL, \COU}$ where $\COU = (n, b)$
   \begin{itemize}
   \item if $b= \FALSE$, then $n' = n$
   \item if $b= \TRUE$ and $b'=\TRUE$, then $n' =n$
   \item if $b=\TRUE$ and $b'=\FALSE$, then $n' \in \{ n,  n+1\}$
   \end{itemize}

 \item $ \DOM (\CONTRACTORS) \subseteq \DOM (\CONTRACTORS')$

\end{itemize}



\begin{definition}%[Blockchain system]
A \emph{blockchain configuration} is a pair
$ \NODE \| \BLOCKCHAIN$ where
\fxnote[inline]{Should the model contain multiple nodes?}
\begin{enumerate}
\item $\NODE = [\EXPRS, \ACCOUNTS, \OPERATIONS]$ is the state of a node, and
\item $\BLOCKCHAIN = [\PENDING, \MANAGERS, \CONTRACTORS,
  \TIME]$ is the state of a blockchain  
  such that
  \begin{itemize}
  \item
    $\forall c \in \ACCOUNTS \implies \exists k\in \MANAGERS, k.\PUK =
    c.\PUK$;
  \end{itemize}
\end{enumerate}
\end{definition}

\section{Transitions}
\label{sec:transitions}

We distinguish several kinds of transitions depending on their scope:
\begin{enumerate}
\item $\ExprTrans$ single-step evaluation of expressions in the node state,
\item $\NodeTrans$ internal transitions of a node,
\item $\BlockTrans$ transitions of the blockchain state,
\item $\SystemTrans$ blockchain system transitions.
\end{enumerate}

Evaluation of expressions is standard call-by-value lambda calculus defined
using evaluation contexts $\EC{}$.
\begin{mathpar}
  \inferrule{}{
    \EC{(\lambda x.\EXPR)\VAL} \ExprTrans \EC{\EXPR[\VAL/x]}
  }

  \inferrule{}{
    \EC{\FST (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_1}
  }

  \inferrule{}{
    \EC{\SND (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_2}
  }

  \inferrule{
    \TRY \notin \EC[F]{}
  }{
    \EC{\TRY\ {\EC[F]{\RAISE\ \VAL}}\ \EXCEPT\ \EXPR} \ExprTrans
    \EC{\EXPR\ \VAL}
  }

  \inferrule{}{
    \EC{\MATCH\ \NIL\ \WITH\ \NIL\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR}
  }

  \inferrule{}{
    \EC{\MATCH\ (\CONS\ \VAL_1\ \VAL_2)\ \WITH\ (\CONS\ x_1\ x_2)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL_1,\VAL_2/x_1, x_2]}
  }

  \inferrule{}{
    \EC{\MATCH\ \NONE\ \WITH\ \NONE\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR}
  }

  \inferrule{}{
    \EC{\MATCH\ (\SOME\ \VAL)\ \WITH\ (\SOME\ x)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL/x]}
  }

  \inferrule{}{
    \EC{\MATCH\ (\LEFT\ \VAL)\ \WITH\ (\LEFT\ x)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL/x]}
  }

  \inferrule{}{
    \EC{\MATCH\ (\RIGHT\ \VAL)\ \WITH\ (\RIGHT\ x)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL/x]}
  }
\end{mathpar}

The internal transitions of a node are just evaluation of expressions.
\begin{mathpar}
  \inferrule[Node-Eval]
  {
    \EXPR \ExprTrans \EXPR'
  }{
    [\EC\EXPR :: \EXPRS, \ACCOUNTS, \OPERATIONS] \NodeTrans{}
    [\EC{\EXPR'} :: \EXPRS, \ACCOUNTS, \OPERATIONS]
  }
\end{mathpar}
% \begin{mathpar}
%   \inferrule[Node-Op]
%     {
%     \Angle{\PAK,\OP.\PUK} \in \ACCOUNTS
%   }{
%     [\EC\OP :: \EXPRS, \ACCOUNTS, \OPERATIONS] \NodeTrans{}
%     [\EXPRS, \ACCOUNTS, (\EC{},\OP):: \OPERATIONS]
%   }
% \end{mathpar}

\begin{mathpar}
  \inferrule[Node-Inject-NEW]{
    \Angle{\PAK,\OP.\PUK} \in \ACCOUNTS \\
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUB (\MANAGERS, \PUK') \\
    \CHECKGAS (\PUK, \PUK', \NTEZ, \MTEZ) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \OPH = \GENERATEOPH (\PUK, \PUK', \NTEZ, \MTEZ, \TIME)
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] } \SystemTrans \\
   { [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
     [ \OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     ::\PENDING,
     \UPDATECOU(\MANAGERS, \PUK, \TRUE),
     \CONTRACTORS,
     \TIME]
   }
  }
\end{mathpar}


\begin{mathpar}
  \inferrule[Node-Inject]{
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUB (\MANAGERS, \PUK') \\
    \CHECKGAS (\PUK, \PUK', \NTEZ, \MTEZ) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \OPH = \GENERATEOPH (\PUK, \PUK', \NTEZ, \MTEZ, \TIME)
  }{
   { [\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \| [\PENDING,
     \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] } \SystemTrans \\
   { [\EC{\OPH}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
     [ \Angle{\OP,\OPH, \TIME}
     ::\PENDING,
     \ACCEPTED,
     \UPDATECOU(\MANAGERS, \PUK, \TRUE),
     \CONTRACTORS,
     \TIME]
   }
  }
\end{mathpar}


\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \TIME'-\TIME < 60
  }{
    { % [\EC{?\OPH}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans  \\
    { % [\EC{\OPH}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \Angle{\OP,\OPH, \TIME,\TIME'} :: \ACCEPTED,
      \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ),
      \CONTRACTORS, \TIME'+1]}
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Block-Timeout]{
    \OP = \TRANSFER[\STRING]\NTEZ\PUK\ADDR\MTEZ \\
    \TIME'-\TIME \ge 60
  }{ % [\EC{?\OPH}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans 
    { % [\EC{\RAISE timeout}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \UPDATECOU(\MANAGERS, \PUK, \FALSE),
      \CONTRACTORS, \TIME']}
  }
\end{mathpar}

\begin{itemize}
\item library call \texttt{call\_contract} with \texttt{confirmations:None} corresponds to
  \begin{enumerate}
  \item{} first \TirName{Node-Op'}, \TirName{Node-Inject'}
  \item{} first \TirName{Node-Op'}, \TirName{Node-Reject(balance,count,pubkey,fee)}
  \end{enumerate}
\item afterwards must check the status to find whether the
  transfer is still pending or \TirName{Block-Accept''} or
  \TirName{Block-Timeout''} has happened.
\item no further transfer is possible before the status is resolved to
  accept or timeout.
\end{itemize}


\subsection{Transitions on Nodes}
\label{sec:transitions-nodes}

Each node has (nondeterministic) rules to propose an operation.
When an operation $\OP$ appears, we check that the account is local by
looking up its public key $\OP.\PUK$ in the local accounts $\ACCOUNTS$ and
consider it signed with the corresponding private key $\PAK$.

\iffalse 
\begin{mathpar}

 \inferrule[Node-Op]
  {
    \Angle{\PAK,\OP.\PUK} \in \ACCOUNTS
  }{
    [\EXPRS, \ACCOUNTS, \OPERATIONS]
    \NodeTrans{}
    [\EXPRS, \ACCOUNTS, \OP:: \OPERATIONS]
  }
  
  \inferrule[Node-Oph]
  {
   \\
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS, \OPERATIONS]
    \NodeTrans{}
    [\EC\OPH :: \EXPRS, \ACCOUNTS, \OPERATIONS]
  }
\end{mathpar}
\fi

\begin{mathpar}
  \inferrule[Node-System]
  {\NODE \NodeTrans \NODE'}
  { {\NODE :: \overline\NODE \| \BLOCKCHAIN}
    \SystemTrans
    {\NODE' :: \overline\NODE \| \BLOCKCHAIN}}

  \inferrule[Block-System]
  {\BLOCKCHAIN \BlockTrans \BLOCKCHAIN'}
  { {\overline\NODE \| \BLOCKCHAIN}
    \SystemTrans
    {\overline\NODE\| \BLOCKCHAIN'}}
\end{mathpar}

\subsection{Transfers}
\iffalse 
Rule 1 [injected]:

\begin{mathpar}
  \inferrule{
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUB (\MANAGERS, \PUK') \\
    \CHECKGAS (\PUK, \PUK', \NTEZ, \MTEZ) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \OPH = \GENERATEOPH (\PUK, \PUK', \NTEZ, \MTEZ, \TIME)
  }{
   { [\ACCOUNTS, \OP :: \OPERATIONS] \| [\PENDING,
     \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] } \SystemTrans \\
   { [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
     [ \Angle{\OP,\OPH, \TIME}
     ::\PENDING,
     \ACCEPTED,
     \UPDATECOU(\MANAGERS, \PUK, \TRUE),
     \CONTRACTORS,
     \TIME]
   }
  }
\end{mathpar}
~\\
~\\
\fi
Rule 1 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \OP.\PUK) \\
    % \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
  }{
    { [\EC\OP  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    }
    \SystemTrans
    { [\EC{\RAISE\ \ERRCOUNT} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [ \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
   }
  }
\end{mathpar}
~\\
~\\
Rule 2 [rejected of balance]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKBAL (\BLOCKCHAIN.\MANAGERS, \OP.\PUK, \OP.\NTEZ, \OP.\MTEZ) \\
    % \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    } \SystemTrans
    { [\EC{\RAISE\ \ERRBAL} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [ \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
   }
  }
\end{mathpar}
~\\
~\\
Rule 3 [rejected of public key]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKPUB (\BLOCKCHAIN.\MANAGERS, \OP.\ADDR) \\
    % \OP = \TRANSFER\NTEZ\PUK{\ADDR}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    } \SystemTrans
   { [\EC{\RAISE\ \ERRPUK} :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
     % [ \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
   }
  }
\end{mathpar}
~\\
~\\
Rule 4 [rejected of fee]:\todo{Q: is this a local test? move to node transitions?}
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKGAS (\PUK, \ADDR, \NTEZ, \MTEZ) \\
    \OP = \TRANSFER\NTEZ\PUK{\ADDR}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    } \SystemTrans
    { [\EC{\RAISE\ \ERRFEE} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      % [ \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
   }
  }
\end{mathpar}
\iffalse 
Rule 6 [included]:
\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \TIME'-\TIME < 60
  }{
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans  \\
    {[\PENDING, \Angle{\OP,\OPH, \TIME,\TIME'} :: \ACCEPTED,
      \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ),
      \CONTRACTORS, \TIME'+1]}
  }
\end{mathpar}
Rule 7 [timeout]: (applies to both, implicit transfers and contract invocations)
\begin{mathpar}
  \inferrule[Block-Timeout]{
    \OP = \TRANSFER[\STRING]\NTEZ\PUK\ADDR\MTEZ \\
    \TIME'-\TIME \ge 60
  }{
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans
    {[\PENDING, \ACCEPTED, \UPDATECOU(\MANAGERS, \PUK, \FALSE),
      \CONTRACTORS, \TIME']}
  }
\end{mathpar}
\fi
\subsection{Smart Contracts}
A. Originate
~\\
~\\
Rule 1 [injected]:

\begin{mathpar}
  \inferrule[Block-Originate]{
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ)  \\
    \CHECKPRG (\CODE, \STRING) \\\\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \OPH = \GENERATEOPH(\PUK, \CODE, \NTEZ, \MTEZ, \STRING,\TIME) 
  }{
    [\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS
      ] \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] \to \\
    [\EC{\OPH}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\Angle{\OP, \OPH,\TIME} :: \PENDING, \ACCEPTED, \UPDATECOU(\MANAGERS,\PUK,\TRUE), \CONTRACTORS, \TIME]
  }
\end{mathpar}
~\\
~\\
Rule 2 [rejected of code]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKPRG (\CODE, \STRING) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [
     \EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS
      ] \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] \to 
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}
~\\
~\\
Rule 3 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\MANAGERS, \PUK) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [
      \EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS
      ] \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] \to
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}
~\\
~\\
Rule 4 [rejected of balance]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [
      \EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS
      ] \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] \to 
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}
~\\
~\\
Rule 5 [rejected of fee]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [
      \EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS
      ] \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] \to 
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}


~\\
~\\
Rule 6 [included]:
\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \TIME'-\TIME < 60
  }{
      [\Angle{\OP, \OPH,\TIME} :: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME']
    \SystemTrans
      [\PENDING, \Angle{\OP, \OPH,\TIME,\TIME'} ::  \ACCEPTED, \UPDATESUCC
      (\MANAGERS, \PUK, \NTEZ, \MTEZ), \\ \Angle{\GENERATEHASH(\CODE, \INIT, \TIME, \TIME'), \NTEZ, \CODE, \STRING} :: \CONTRACTORS, \TIME'+1]
  }
\end{mathpar}
~\\
~\\
Rule 7 [timeout]:
\begin{mathpar}
  \inferrule[Block-Timeout]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \TIME'-\TIME \ge 60
}{
      [\Angle{\OP, \OPH,\TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']  
      \BlockTrans \    
      [\Angle{\OP, \OPH,\TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME'] 
  }

\end{mathpar}
~\\
~\\
B. \textbf{Transfer}
~\\
~\\
Rule 1 [injected]:
\begin{mathpar}
  \inferrule[Block-Call]{
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUH (\CONTRACTORS, \PUH) \\
    \CHECKARG (\CONTRACTORS, \PUH, \PARAMETER) \\
    \CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ) \\
    \OP =  \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
    \OPH = \GENERATEOPH (\PUK,\PUH, \PARAMETER,\NTEZ, \MTEZ, \TIME)
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans \\
    [\EC{\OPH}  :: \EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\Angle{\OP, \OPH, \TIME} :: \PENDING, \ACCEPTED, \UPDATECOU(\MANAGERS, \PUK, \TRUE), \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Rule 2 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\MANAGERS, \PUK) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Rule 3 [rejected of balance]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Rule 4 [rejected of public hash]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKPUH (\CONTRACTORS, \PUH)\\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Rule 5 [rejected of argument]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKARG (\CONTRACTORS, \PUH, \PARAMETER)\\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Rule 6 [rejected of fee]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ)\\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Rule 7 [included]:
\begin{mathpar}
  \inferrule{
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK\PUH\MTEZ \\
    \TIME'-\TIME < 60
  }{
    [\Angle{\OP, \OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
    \CONTRACTORS, \TIME']
    \BlockTrans \\
    [\PENDING,
    \Angle{\OP,\OPH, \TIME, \TIME'} :: \ACCEPTED,
    \UPDATESUCC (\MANAGERS, \PUK, '', \NTEZ, \MTEZ),
    \UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER),
    \TIME'+1]
  }
\end{mathpar}
\section{Queries}
Query 1 [balance of an account]:
\begin{mathpar}
  \inferrule{
    \BLOCKCHAIN = 
      [\PENDING, \ACCEPTED,  \Angle{\PUK, \BAL, \COU} :: \MANAGERS, \CONTRACTORS, \TIME]
  }{[\epsilon[\GETBALANCE\PUK] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\BAL] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 2 [balance of smart contract]:
\begin{mathpar}
  \inferrule{
    \BLOCKSYSTEM = 
      [\PENDING, \ACCEPTED,  \MANAGERS, \Angle{\PUH, \BAL, \CODE, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\epsilon[\GETBALANCE\PUH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\BAL] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 3 [storage]:
\begin{mathpar}
  \inferrule{
    \BLOCKSYSTEM = 
      [\PENDING, \ACCEPTED,  \MANAGERS, \Angle{\PUH, \BAL, \CODE, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\epsilon[\GETSTORAGE\PUH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\STORAGE] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 4 [code]:
\begin{mathpar}
  \inferrule{
    \BLOCKSYSTEM = 
      [\PENDING, \ACCEPTED,  \MANAGERS, \Angle{\PUH, \BAL, \CODE, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\epsilon[\GETCODE\PUH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\CODE] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 5 [counter]:
\begin{mathpar}
  \inferrule{
    \BLOCKSYSTEM = 
      [\PENDING, \ACCEPTED,  \Angle{\PUK, \BAL, \COU} :: \MANAGERS, \CONTRACTORS, \TIME]
  }{[\epsilon[\GETCOUNTER\PUK] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\COU] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 6 [fail of a query for an account]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKPUB (\MANAGERS, \PUK) \
  }{[\epsilon[\GETBALANCE\PUK/\GETCOUNTER\PUK] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| [\PENDING, \ACCEPTED,  \MANAGERS, \CONTRACTORS, \TIME]
    \NodeTrans\\ [\epsilon[\RAISE\ \ERRPUK] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| [\PENDING, \ACCEPTED,  \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Query 7 [fail of a query for an account]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKPUB (\CONTRACTORS, \PUH) 
  }{[\epsilon[\GETBALANCE\PUH/\GETSTORAGE\PUH/\GETCODE\PUH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| [\PENDING, \ACCEPTED,  \MANAGERS, \CONTRACTORS, \TIME]
    \NodeTrans\\ [\epsilon[\RAISE\ \ERRPUH] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| [\PENDING, \ACCEPTED,  \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
~\\
~\\
Query 8 [status-pending]:
\begin{mathpar}
  \inferrule{
    \BLOCKSYSTEM = 
      [\Angle{\OP, \OPH, \TIME'} :: \PENDING, \ACCEPTED,  \MANAGERS, \CONTRACTORS, \TIME]
  }{[\epsilon[\GETSTATUS\OPH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\STATUSPENDING] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 9 [status-including]:
\begin{mathpar}
  \inferrule{
    \BLOCKSYSTEM = 
      [\PENDING, \Angle{\OP, \OPH, \TIME', \TIME''} :: \ACCEPTED,  \MANAGERS, \CONTRACTORS, \TIME] \\
    $n$ = \TIME\ - \TIME''
  }{[\epsilon[\GETSTATUS\OPH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN
    \NodeTrans\ [\epsilon[\STATUSINCLUDING($n$)] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| \BLOCKCHAIN}
\end{mathpar}
~\\
~\\
Query 10 [status-timeout]:
\begin{mathpar}
  \inferrule{ 
    \NEG\ \CHECKEXIST (\OPH, \PENDING, \ACCEPTED)
  }{[\epsilon[\GETSTATUS\OPH] :: \EXPRS, \ACCOUNTS, \OPERATIONS]  \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]
    \NodeTrans\ [\epsilon[\STATUSTIMEOUT] ::\EXPRS, \ACCOUNTS, \OPERATIONS]  \| [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
\section{Functions}
\begin{enumerate}
    \item Function \CHECKPUB (\PUK, \MANAGERS)\ checks whether a public key \PUK\ exists in \MANAGERS.
    \item Function \CHECKPUH (\PUH, \CONTRACTORS)\ checks whether a public hash \PUH\ exists in \CONTRACTORS.
    \item Function \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) checks whether the balance of the account that associates with the public key \PUK\ is greater or equal to \NTEZ\ plus \MTEZ.
    \item Function \CHECKCOU (\MANAGERS, \PUK)\ checks whether the current counter of an account that associates with the public key \PUK\ is unlocked (its flag is False).
    \item Function \CHECKEXIST (\ADDR, \PENDING, \ACCEPTED)\ checks whether an address  \ADDR\ exists in either \PENDING\ or \ACCEPTED.
    \item Function \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ) updates the balance and the counter of the account that associates with the public key \PUK\ and the balance of the account that associates with the public key \PUK', where
    \begin{itemize}
        \item[]  $\langle  \PUK, \BAL, (\NTEZ, \TRUE) \rangle $ $\Rightarrow$ $\langle  \PUK, \BAL - \NTEZ - \MTEZ, (\NTEZ + 1, \FALSE) \rangle $      
        \item[] $\langle  \PUK', \BAL', \COU' \rangle$ $\Rightarrow$ $\langle  \PUK', \BAL' + \NTEZ, \COU' \rangle $         
    \end{itemize}
    
    \item Function \UPDATECOU(\MANAGERS, \PUK, \BOOLEAN) updates the counter flag (True $=$ locked, False $=$ unlocked) of the account that associates with the public key \PUK, where
    \begin{itemize}
        \item[]  $\langle  \PUK, \BAL, (\NTEZ, \BOOLEAN') \rangle $ $\Rightarrow$ $\langle  \PUK, \BAL, (\NTEZ, \BOOLEAN) \rangle $ 
    \end{itemize}
    
    \item Function  \UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER) updates the contractor that associates with the public hash \PUH\, where
    \begin{itemize}
        \item[] $\langle  \PUH, \BAL, \CODE, \STORAGE, \rangle $ $\Rightarrow$ $\langle  \PUH, \BAL + \NTEZ, \CODE, \\ \UPDATESTORAGE(\STORAGE,\CODE,\PARAMETER) \rangle $
    \end{itemize}
    
    \item Function \CHECKPRG (\CODE, {\INIT /\PARAMETER}) checks whether the code \CODE\ and the initil stogare's valude (or the input parameter \PARAMETER) are well type.
   % \item Function \CHECKGAS(\CODE, \INIT, \MTEZ) checks whether the gas that is consumed to run the code \CODE\ for the initial value \INIT\ is less or equal to \MTEZ.
    \item Function \CHECKGAS (...) checks whether the fee that is consumed to emit the opertion is less or equal to the fee \MTEZ. 
    %run the code \CODE\ that associates with the public hash \PUH\ for the paremeter \PARAMETER\ is less or equal to \MTEZ.
    \item Function \GENERATEOPH (\PUK, {\ADDR /\CODE}, \NTEZ, \MTEZ, {\INIT /\PARAMETER}, \TIME) generates an operation hash.

    \item Function \GENERATEHASH (\CODE, \INIT, \TIME, \TIME')  generates the public hash of a smart contract.
     
    \item Function \UPDATESTORAGE(\STORAGE, \CODE,  \PARAMETER) returns the new storage by running the code \CODE\ on the  storage  \STORAGE\ with  the input parameter \PARAMETER.
\end{enumerate}
\end{document}