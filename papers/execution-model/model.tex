\documentclass[a4paper]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{mathpartir}
\usepackage{fixme}
\usepackage{xcolor}
\usepackage{listings}
\lstdefinelanguage{michelson}{
%  basicstyle=\ttfamily,
  morekeywords={parameter,storage,or,unit,mutez,pair,bool,address}, sensitive=false,
  morecomment=[l]{\#},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}
\lstset{language=michelson}
\input{macros}

\title{A Typed Programmatic Interface to Contracts on the Blockchain}

\author{Thi Thu Ha Doan\and
Peter Thiemann\orcidID{0000-0002-9000-1239}}
\institute{University of Freiburg, Germany\\
\email{\{doanha,thiemann\}@informatik.uni-freiburg.de}
}

\date{\today}

\begin{document}
\maketitle
\pagestyle{plain}
\begin{abstract}
  Smart contract applications on the block chain can only reach their full potential if
  they can be integrated with traditional software systems. Invoking
  contracts and observing the state of the blockchain requires a
  programmatic interface. We propose a typed API for this
  purpose and establish some properties of the combined
  system. Specifically, we provide an execution model that
  enables us to prove type-safe interaction between programs and the 
  blockchain. We establish further properties of the model that
  give rise to requirements on the API. A prototype of the interface
  is implemented in OCaml for the Tezos blockchain.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Smart contracts rarely live in isolation. To reach their full
potential, it should be possible to integrate them with traditional
software systems and to enable input from outside the blockchain. Such
input requires trusted intermediaries that run so-called oracles \cite{oracles}. A
smart contract registers a request and a callback with an oracle. The
oracle invokes the callback as soon as an answer is available. 

We present two examples where integration of smart contracts is needed
and propose a typed API for making such integration type safe.

\section{Motivation}
\label{sec:motivation}

Suppose you want to run an auction on the blockchain using a smart
contract. Once to the contract is deployed, the
auction is open for bidding, but it should be closed after 48 hours,
say. Such a timeout is a typical task for an oracle. Rather than
trusting a generic oracle, you prefer to roll your own mechanism that reliably closes the auction
after 48 hours have passed. So you want to write a program to do so. 

As a bidder, you may want to implement a bidding
strategy that starts at a certain amount and increases the bid until a
limit is reached. Of course, you only want to increase if
someone else placed a higher bid. So you also want to write a
program to implement this strategy.

Neither task can be implemented as a smart contract alone because they react
to external triggers. Closing requires to schedule the activation of a
contract at a certain time and bidding 
requires to watch the current highest bid of the contract and
react if another bidder places a higher bid.

For concreteness, Listing~\ref{lst:auction-contract-header} shows the
header of an auction contract in Michelson \cite{michelson}. The
\lstinline/parameter/ clause specifies the contract's parameter
type. It is a sum type (indicated by \lstinline/or/) and each
alternative constitutes an entrypoint, named \lstinline/%close/ and
\lstinline/%bid/. Entrypoint \lstinline/%close/ takes a \texttt{unit}
parameter and \lstinline/%bid/ takes an amount of tokens \texttt{mutez}.
The \lstinline/storage/ clause declares the state of the contract,
which is a nested pair type indicating whether bidding is allowed, the address of the
contract owner (to prohibit unauthorized calls to \lstinline/%close/),
the highest bid, and the bidder's address.
\begin{lstlisting}[numbers=none,float,caption={Header of the auction contract},label={lst:auction-contract-header},captionpos=b,emph={close,bid},emphstyle=\underbar]
parameter (or (unit %close)
              (mutez %bid)); # participant's bid
storage (pair
          (pair bool address)  # bidding allowed, contract owner
          (pair mutez address) # highest bid, bidder's address
        );
\end{lstlisting}


There are two purposes for calling an auction contract: (1) a bid by a bidder, or (2) a contract closing by the contract owner. Michelson supports multiple entrypoints, distinguished by \texttt{or}. The contract's storage contains two pairs, the first pair containing the flag indicating whether bidding is allowed or the contract is closed and the address of the contract owner, and the second pair containing the current highest bid and the address of the bidder. Michelson is stack-based. It takes a pair of the parameter and the current storage as inputs and returns the updated storage and a list of internal operations. When a bidder invokes the contract to bid, its bid and address are updated in the storage if the bid is higher than the current highest bid, otherwise they are discharged. The closing of the contract is called by the contract owner when it reaches 48 hours.




Although contract closing  and bidding strategy tasks are not able to be implemented in a smart contract, they could be in programs that interact with smart contracts on the blockchain. We call the function that deploys a contract \texttt{originate-contract}, and  it returns the contract's address on the blockchain.  The function that invokes a contract is \texttt{call-contract}. \texttt{get-state} function queries data on the blockchain and returns the storage of a contract. The owner could first deploy the contract, wait 48 hours, and then call the contract with the entrypoint \texttt{Unit} to close the contract.

\begin{lstlisting}[numbers=none]
address = originate-contract(script);
Time.sleep(to-second(48));
call-contract(address, Unit);
\end{lstlisting}
where \texttt{script} is the contract's script and \texttt{to-second} function converts hour to second.

The bidding strategy could be implemented by first calling a contract with a minimum amount, watching the state of the contract, say every 5 minutes. If the bidder is not the current highest bidder and bidding is allowed, the bid has not reached the limit. He emits a contract call with a higher bid.

\begin{lstlisting}[numbers=none]
while get-state(address).flag = true and 
get-state(address).highestBid > bid and bid < limit do
    bid = bid + a;
    call_contract(address, bid); 
    Time.speep(5);
done;
\end{lstlisting}


On another level, running a contract requires to propose a fee to the
blockchain, which may or may not be accepted. In any case, starting a
contract may timeout for a range of different reasons. So just
starting a contract with a fixed fee does not guarantee the contract's execution.
This scenario can also be addressed by a program that tries to run the
contract with successively increasing fees until the blockchain
accepts the contract invocation. The program can also calculate the
required fee by observing the current state of the blockchain.


(From this scenario we see the required functionality for a
programmatic interface to a blockchain:)

\begin{itemize}
\item query certain components like the state of a contract (to obtain
  the current highest bid, to check the fees of the last block)
\item invoke contracts and initiate transfers
\end{itemize}

\section{Definitions}
\begin{definition}%[Set]
Let $\mathbf{Elt}$ be the set of (concrete) elements. Let $\emptyset$ be an empty set and $\mathbf{e}$ $\in$  $\mathbf{Elt}$. A set of elements is expressed as the following syntax:
\\
$\mathbf{s} :: = \emptyset \mid \mathbf{e} \mid \mathbf{s :: s}$
\end{definition}

\subsection{Local Node}
\label{sec:local-node}


\begin{definition}%[Account]
  An implicit \emph{account} is represented by a key pair $\langle
  %\ALS,
  \PAK, \PUK
  %, \PKH
  \rangle $, where
  $\PAK$ is its private key and $\PUK$ is its public key.
\end{definition}


\begin{definition}%[Operation]
  \emph{Operations} are defined by the following grammar:
  \begin{align*}
    \OP &::= \TRANSFER[\PARAMETER]\NTEZ\PUK\ADDR\MTEZ
    \\&\mid \ORIGINATE\NTEZ\PUK\CODE\INIT\MTEZ
  \end{align*}
  where \NTEZ\ and \MTEZ\ are tokens, \ADDR\ is either a public
  key for an implicit account  or a public hash for a smart contract,
  \PARAMETER\ is an argument passed to the smart contract's script,
  which is empty if it is a transfer to an implicit account, \CODE\ is
  a script of the smart contract, \INIT\ is an initial value of the
  contract's storage. 
\end{definition}

\begin{definition}%[Query]
\emph{Queries} are defined by the following grammar:
\begin{align*}
  \QRY & ::=
  \GETCOUNTER\PUK  
  \\&\mid \GETBALANCE\ADDR
  \\&\mid \GETSTATUS\OPH
  \\&\mid \GETSTORAGE\PUH
  % \\&\mid \GETCODE\PUH 
  % \\&\mid \GETTYPE\PUH
  \\&\mid \GETCONTRACT\OPH
\end{align*}
\end{definition}

\begin{definition}%[Program]
\emph{Expressions} are defined by the following grammar:
\begin{align*}
  \CONSTANT & ::= \INT %\mid \ADDR
              \mid \OPH \mid \PUH \mid\PUK \mid \CODE \mid
              \NTEZ \mid \SUNIT \mid \FALSE \mid \TRUE \\
  \STATUS & ::= \STATUSPENDING \mid \STATUSINCLUDING (\INT) \mid
            \STATUSTIMEOUT \\
  \ERROR &::= \ERRPRG \mid \ERRBAL \mid \ERRCOUNT \mid \ERRFEE \mid
           \ERRPUK \mid \ERRPUH \mid \ERRARG \mid \ERRINIT\\
	\EXPR & :: =  \CONSTANT \mid \STATUS \mid \ERROR \mid \VARIABLE \mid \lambda \VARIABLE. \EXPR\ 
	\mid \EXPR\EXPR \mid (\EXPR,\EXPR) \mid \FST\ \EXPR \mid \SND\ \EXPR 	%\mid \NI \EI
	\\&\mid \EXPR\ \PLUS\ \EXPR\ \mid \EXPR\ \MINUS\ \EXPR\ \mid \EXPR\ \EQUAL\ \EXPR\ \mid \EXPR\ \LESS\ \EXPR
	\\&\mid \EXPR\ \AND\ \EXPR\ \mid \EXPR\ \OR\ \EXPR\ \mid \NOT\ \EXPR
  \\&\mid \NIL\ \mid \CONS\ \EXPR\ \EXPR \mid \LEFT\ \EXPR \mid\RIGHT\
  \EXPR \mid \SOME\ \EXPR \mid \NONE
  \\& \mid \RAISE\ \EXPR \mid \TRY\ \EXPR\ \EXCEPT\ \EXPR
  \\& \mid \MATCH\ \EXPR\ \WITH\ \PATTERN\to\EXPR \dots
  \\& \mid \TRANSFER[\EXPR]\EXPR\EXPR\EXPR\EXPR
  \\& \mid \ORIGINATE\EXPR\EXPR\EXPR\EXPR\EXPR
  \\&\mid \QOP\  \EXPR \mid \CONTRACT\ \TYPE\ \EXPR \mid \TOSTRING\
  \EXPR \mid \FROMSTRING\ \TYPE\ \EXPR\\
  \QOP & ::= balance \mid status \mid storage \mid code \mid counter \mid type
\end{align*}
We let $\EXPRS$ range over sets of expressions.

We let $\ECS$ range over evaluation contexts. They are defined as
follows.
\begin{align*}
  \EC{} & :: = \SC[\overline\VAL\ \EC{}\ \overline\EXPR] \mid \RAISE\ \EC{} \mid \TRY\ \EC{}\ \EXCEPT\ \EXPR
  \mid \MATCH\ \EC{}\ \WITH\ \PATTERN\to\EXPR \dots
\end{align*}
Here $\SC$ ranges over the remaining syntactic constructors, which are
treated uniformly: evaluation proceeds from left to right.
\begin{align*}
  \VAL & ::= \CONSTANT \mid \STATUS \mid \ERROR \mid \lambda x.\EXPR \mid(\VAL, \VAL) \mid
         \NIL \mid \CONS\ \VAL\ \VAL \mid \LEFT\ \VAL \mid \RIGHT\
         \VAL \mid \SOME\ \VAL\mid \NONE
\end{align*}
\end{definition}

Example pseudo code
\begin{align*}
  \OPH &=  \TRANSFER[\EXPR]\EXPR\EXPR\EXPR\EXPR \\
       & \MATCH\ {status\ \OPH}\ \WITH \\
       & \mid \STATUSPENDING \to \textrm{not yet included, continue waiting} \\
       & \mid \STATUSINCLUDING (n) \to \textrm{included with $n$
         blocks confirmation}\\
       & \mid \STATUSTIMEOUT \to \textrm{lost, try again}
\end{align*}
Grammar of types
\begin{align*}
  \TYPE, \TYPEU & ::= \TADDR \mid \TOPH \mid
                  \TCONTRACT\ \TYPE \mid
                  % \TPUH\ \TYPE \mid
                  \TPUK \mid
                  \TCODE\ \TYPE\ \TYPEU \mid \TTEZ \mid
          \TINT \mid \TUNIT \mid \TBOOL \mid \TSTRING \mid \TSTATUS \\
  & \mid \TYPE\to\TYPEU \mid \TPAIR\ \TYPE\ \TYPEU \mid \TLIST\ \TYPE
    \mid \TSUM\ \TYPE\ \TYPEU \mid \TOPTION\ \TYPE \mid \TEXCEPTION
\end{align*}

Typing rules, relying on an external typing judgment
$\JTypeCode\CODE\TYPE$ for the contract language and
$\JTypeValue\STRING\TYPE$ for serialized values as stored on the blockchain.
\begin{mathpar}
  \inferrule{}{\JTypeExpr\TEnv\INT\TINT}

  \inferrule{}{\JTypeExpr\TEnv\OPH\TOPH}

  \inferrule{}{\JTypeExpr\TEnv\PUH{\TADDR}}

  \inferrule{}{\JTypeExpr\TEnv\PUK\TPUK}

  \inferrule{\JTypeCode \CODE{ \TPAIR\ \TYPE_p\
      \TYPE_s}}{\JTypeExpr\TEnv\CODE{\TCODE\ \TYPE_p\ \TYPE_s}}

  \inferrule{\JTypeExpr\TEnv\EXPR\TADDR}{\JTypeExpr\TEnv{\CONTRACT\ \TYPE\ \EXPR}{\TOPTION
      (\TCONTRACT\ \TYPE)}}

  \inferrule{}{\JTypeExpr\TEnv\NTEZ\TTEZ}

  \inferrule{}{\JTypeExpr\TEnv\SUNIT\TUNIT}

  \inferrule{}{\JTypeExpr\TEnv\FALSE\TBOOL}

  \inferrule{}{\JTypeExpr\TEnv\TRUE\TBOOL}

  \inferrule{}{\JTypeExpr\TEnv\STATUSPENDING\TSTATUS}

  \inferrule{}{\JTypeExpr\TEnv\STATUSTIMEOUT\TSTATUS}

  \inferrule{}{\JTypeExpr\TEnv{\STATUSINCLUDING (\INT)}\TSTATUS}

  \inferrule{}{\JTypeExpr\TEnv\ERROR\TEXCEPTION}

  \inferrule{}{\JTypeExpr\TEnv\VARIABLE{\TEnv (\VARIABLE)}}

  \inferrule{
    \JTypeExpr{\TEnv, \VARIABLE:\TYPE'}\EXPR{\TYPE}
  }{
    \JTypeExpr\TEnv{\lambda\VARIABLE.\EXPR}{\TYPE'\to\TYPE}}

  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TYPE'\to\TYPE} \\
    \JTypeExpr\TEnv{\EXPR'}{\TYPE'}
  }{
    \JTypeExpr\TEnv{\EXPR\ \EXPR'}\TYPE
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR\TYPE \\
    \JTypeExpr\TEnv{\EXPR'}{\TYPE'}
  }{
    \JTypeExpr\TEnv{(\EXPR, \EXPR')}{\TPAIR\ \TYPE\ \TYPE'}
  }

  \inferrule{
    \JTypeExpr\TEnv{\EXPR}{\TPAIR\ \TYPE\ \TYPE'}
  }{
    \JTypeExpr\TEnv{\FST\ \EXPR}\TYPE
  }

  \inferrule{
    \JTypeExpr\TEnv{\EXPR}{\TPAIR\ \TYPE\ \TYPE'}
  }{
    \JTypeExpr\TEnv{\SND\ \EXPR}{\TYPE'}
  }
  \\\\
  \inferrule{
    \JTypeExpr\TEnv\EXPR\TEXCEPTION
  }{
    \JTypeExpr\TEnv{\RAISE\ \EXPR}\TYPE
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR\TYPE \\
    \JTypeExpr\TEnv{\EXPR'}{\TEXCEPTION\to\TYPE}
  }{
    \JTypeExpr\TEnv{\TRY\ \EXPR\ \EXCEPT\ \EXPR'}\TYPE
  }
  \\\\
  % too generic
  % \inferrule{
  %   \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
  %   \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
  %   \JTypeExpr\TEnv{\EXPR_3}\TADDR \\
  %   \JTypeExpr\TEnv{\EXPR_4}\TSTRING \\
  %   \JTypeExpr\TEnv{\EXPR_5}\TTEZ
  % }{
  %   \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
  % }
  %   
  \inferrule{
    \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
    \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
    % \JTypeExpr\TEnv{\EXPR_3}\TPUK \\
    \JTypeExpr\TEnv{\EXPR_3}{\TCONTRACT\ \TUNIT} \\
    % \JTypeExpr\TEnv{\EXPR_4}\TSTRING \\
    \JTypeExpr\TEnv{\EXPR_5}\TTEZ
  }{
    \JTypeExpr\TEnv{\TRANSFER{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
  }

  \inferrule{
    \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
    \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
    \JTypeExpr\TEnv{\EXPR_3}\TCONTRACT\ \TYPE \\
    \JTypeExpr\TEnv{\EXPR_4}{\TYPE} \\
    \JTypeExpr\TEnv{\EXPR_5}\TTEZ
  }{
    \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
  }


  \inferrule{
    \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
    \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
    \JTypeExpr\TEnv{\EXPR_3}{\TCODE\ \TYPE_p\ \TYPE_s} \\
    \JTypeExpr\TEnv{\EXPR_4}\TYPE_s \\ % really \TSTRING \\
    \JTypeExpr\TEnv{\EXPR_5}\TTEZ
  }{
    \JTypeExpr\TEnv{\ORIGINATE{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_4}{\EXPR_5}}\TOPH 
  }
\end{mathpar}

Types for queries
\begin{mathpar}
  \inferrule{
    \JTypeExpr\TEnv\EXPR\TPUK
  }{
    \JTypeExpr\TEnv {\QRY\ \GETCOUNTER\EXPR}\TINT
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR\TADDR
  }{
    \JTypeExpr\TEnv {\QRY\ \GETBALANCE\EXPR}\TTEZ
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR\TOPH
  }{
    \JTypeExpr\TEnv {\QRY\ \GETSTATUS\EXPR}\TSTATUS
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  }{
    \JTypeExpr\TEnv {\QRY\ \GETSTORAGE\EXPR}\TSTRING
  }

  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  % }{
  %   \JTypeExpr\TEnv {\QRY\ \GETCODE\EXPR}?
  % }
  %   
  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  % }{
  %   \JTypeExpr\TEnv {\QRY\ \GETTYPE\EXPR}?
  % }
  %   
  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TOPH}
  }{
    \JTypeExpr\TEnv {\QRY\ \GETCONTRACT\EXPR}\TPUH
  }
\end{mathpar}

Conversion to and from serialized storage; deserialization may fail
with an exception
\begin{mathpar}
  \inferrule{
    \JTypeExpr\TEnv\EXPR\TYPE \\
    \SERIALIZABLE (\TYPE)
  }{
    \JTypeExpr\TEnv{\TOSTRING\ \EXPR}\TSTRING
  }

  \inferrule{
    \JTypeExpr\TEnv{\EXPR}\TSTRING
  }{
    \JTypeExpr\TEnv{\FROMSTRING\ \TYPE\ \EXPR}\TYPE
  }
\end{mathpar}

\begin{definition}%[State of a node]
  The \emph{state of a node} is a tuple
  $\NODE = [ \EXPRS, \ACCOUNTS
  % , \OPERATIONS
  ]$, where $\EXPRS$ is a
  set of programs and $\ACCOUNTS \subseteq \TPAK \times \TPUK$  is a set of
  implicit accounts.
  % , and
  % $\OPERATIONS \subseteq \ECS \times \TOP $ is a set of pairs of
  % expression contexts and operations.
\end{definition}


\subsection{Global}
\label{sec:global}



\begin{definition}%[Manager]
A \emph{manager} manages a single implicit account. Managers are
represented by a partial mapping $\MANAGERS : \TPUK \partialto \TBAL
\times \TCOU$. If $\MANAGERS (\PUK) = \Angle{\BAL, \COU}$ is defined, then  $\PUK$ is the
public key of an account, $\BAL$ is its
balance and $\COU$ is its counter whose form is a value-flag pair
$(n,b) \in \Nat\times\TBOOL$, where $n$ is the value of the counter
and ${b}$ is its flag.   
\end{definition}

\begin{definition}%[Contractor]
  A \emph{contractor} manages a smart contract. Contractors are
  represented by a partial mapping $\CONTRACTORS : \TPUH \partialto
  \TCODE \times \TIME  \times \TBAL \times  \TSTORAGE$. If $\CONTRACTORS (\PUH) = \langle
  \CODE, \TIME, \BAL, \STORAGE \rangle $ is defined, then $\PUH$ is the
  public hash of a contract,
  $\CODE$ is its  code,
  $\TIME$ is the time when it was accepted,
  $\BAL$ is its current balance,
  and $\STORAGE$ is its current storage.
\end{definition}

When an operation is injected in a node, it enters a \emph{pending
  pool}. Later on, such a pending operation is either dismissed or
promoted to an accepted operation.

 %\begin{definition}%[Pending operation]
%An \emph{operation} is represented by a tuple  $\langle  \OP, \TIME, \STATUS \rangle $, where $\OP$ is an operation, $\TIME$ is the time when the operation was injected, and $\STATUS$ is either $\STATUSPENDING$,$\STATUSINCLUDED\ \TIME'$, or $\STATUSTIMEOUT$.  
%\end{definition}
\begin{definition}
  The pool of operations, $\PENDING$, is defined as a partial mapping from
  operation hashes $\OPH$: 
  \begin{align*}
    \PENDING &= \TOPH \partialto \TOP\times \TTIME \times \TSTATUS \\
    \TSTATUS&= \STATUSPENDING + \STATUSINCLUDED\ \TTIME + \STATUSTIMEOUT
  \end{align*}
  
  if $\PENDING(\OPH) = \langle  \OP, \TIME, \STATUS
\rangle $ is defined, then $\OPH$ is the public hash of the operation, $\OP$ is the operation, $\TIME$ is the time when the
operation was injected, and $\STATUS$ is either $\STATUSPENDING$,
$\STATUSINCLUDED\ \TIME'$, or $\STATUSTIMEOUT$.
A pool $\PENDING$ is \emph{well-formed} if, for all $\OPH$, $\PENDING (\OPH) =
  \Angle{\OP,\TIME, \STATUSINCLUDED\ \TIME'}$ implies $\TIME' \ge
  \TIME$ and $\OPH = \GENERATEOPH (\OP, \TIME)$.
\end{definition}


A \emph{pending operation} is represented by
$\OPH \mapsto \langle  \OP, \TIME, \STATUSPENDING\rangle $,
where $\OP$ is an operation, $\OPH$ is the operation hash,
and $\TIME$ is the time when the operation was injected.
Once it is accepted, it changes to an \emph{accepted operation}:
$\OPH \mapsto \langle  \OP, \TIME, \STATUSINCLUDED\ \TIME'\rangle $, where
$\TIME' \ge \TIME$ is  when the operation was included in the
blockchain.  The operation can also be dropped at any time, which is
represented by
$\OPH \mapsto \langle  \OP, \TIME, \STATUSTIMEOUT\rangle $. There are several
causes for dropping, primarily timeout or overflow of the pending
pool which is limited in size in the implementation.


% After some time, a pending operation may be included in the blockchain as an accepted operation.

 % \begin{definition}%[Accepted operation]
% An \emph{accepted operation}  is a tuple $\langle  \OP, \OPH, \TIME, \TIME' \rangle
% $, where $\OP$ is an operation, $\OPH$ is the operation hash, $\TIME$ is the time when the operation was injected, and
% $\TIME'$ is the time when it was included in the blockchain. 
% \end{definition}

\begin{definition}%[Blockchain]
  The \emph{state of a blockchain} is a tuple
  $\BLOCKCHAIN = [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]$ where
  $\PENDING$ is a pool of operations, $\MANAGERS$ is a map of managers,
  $\CONTRACTORS$ is a map of contractors, and $\TIME$ is the current
  time. 
\end{definition}
\begin{definition}%[Blockchain system]
A \emph{blockchain configuration} is a pair
$ \NODE \| \BLOCKCHAIN$ where
\fxnote[inline]{Should the model contain multiple nodes?}
\begin{enumerate}
\item $\NODE = [\EXPRS, \ACCOUNTS]$ is the state of a node, and
\item $\BLOCKCHAIN = [\PENDING, \MANAGERS, \CONTRACTORS,
  \TIME]$ is the state of a blockchain  
  such that
  \begin{itemize}
  \item
    $\forall a \in \ACCOUNTS \implies a.\PUK \in \DOM( \MANAGERS)$;
  \end{itemize}
\end{enumerate}
\end{definition}
\begin{definition}
  Preserved by a step on a well-formed configuration $ [\EXPRS, \ACCOUNTS] \|
  [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]$:
  \todo[inline]{Is this preserved?}
  \begin{itemize}
  \item for all $\OPH$ in $\EXPRS$, $\OPH \in \DOM (\PENDING)$,
  \item for all $\PUK$ in $\EXPRS$, $\PUK \in \DOM (\MANAGERS)$,
  \item for all $\PUH$ in $\EXPRS$, $\PUH \in \DOM (\CONTRACTORS)$.
  \end{itemize}
\end{definition}

\clearpage{}
\subsection{Properties of blockchain state transitions}

If $[\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \BlockTrans{}
[\PENDING', \MANAGERS', \CONTRACTORS', \TIME']$, then
\begin{itemize}
\item $\TIME \le \TIME'$
\item $\DOM (\PENDING) \subseteq \DOM(\PENDING')$
\item for all $\OPH \in \DOM(P)$, if 
  $\PENDING (\OPH) = \Angle{\OP,  \hat\TIME, \STATUS}$, then either
  \begin{itemize}
  \item     $\PENDING'    (\OPH) = \PENDING (\OPH)$; or
  \item $\STATUS  = \STATUSPENDING$ and $\PENDING' (\OPH) =
    \Angle{\OP, \hat\TIME, \STATUSTIMEOUT}$; or
  \item  $\STATUS  = \STATUSPENDING$, $\TIME - \hat\TIME
    \le 60 $, and
    $\PENDING' (\OPH) =       \Angle{\OP, \hat\TIME, \STATUSINCLUDED\
      \TIME}$.
  \end{itemize}
 \item for all $\OPH \in \DOM(P)$ and $\PENDING (\OPH) = \Angle{\OP,  \hat\TIME, \STATUSPENDING}$, 
    \begin{itemize}
    	\item  if $\MANAGERS(\OP.\PUK) =  \Angle{\BAL, \COU}$ then  
  $\COU.b = \TRUE$.
    \end{itemize}
 \item $ \DOM (\MANAGERS) \subseteq \DOM (\MANAGERS')$
 \item for all $\PUK \in \DOM (\MANAGERS)$\\
   if $\MANAGERS (\PUK) =
   \Angle{\BAL, \COU}$, 
   then $\MANAGERS' (\PUK) =
   \Angle{\BAL', \COU'}$ and
   \begin{itemize}
   \item if $\COU.b=\TRUE$ and $\COU'.b=\FALSE$, then $\COU.n' \in \{
     \COU.n,  \COU.n+1\}$,
   \item otherwise $\COU.n = \COU'.n$
   \item If $\COU.n = \COU'.n$, then $\BAL = \BAL'$.
   % \item if $\COU.b= \FALSE$, then $n' = n$
   % \item if $\COU.b= \TRUE$ and $b'=\TRUE$, then $n' =n$
   \end{itemize}

 \item $ \DOM (\CONTRACTORS) \subseteq \DOM (\CONTRACTORS')$
   \begin{itemize}
   \item for all $\PUH \in \DOM (\CONTRACTORS)$,
     $\CONTRACTORS (\PUH).\CODE = \CONTRACTORS' (\PUH).\CODE$
   \end{itemize}
 \item invariant for contractors:
   for all $\PUH \in \DOM (\CONTRACTORS)$,
   $\CONTRACTORS (\PUH) = \Angle{ \CODE, \TIME, \BAL, \STORAGE}$
   implies that $\PUH = \GENERATEHASH (\CODE, \TIME)$.
\end{itemize}

\subsection{Typing related properties}

To describe contracts we associate each public hash to a pair of
types, the parameter type and the storage type.
\begin{align*}
  \Delta & ::= \EmptyEnv \mid \PUH: \TPAIR\ \TYPE\ \TYPE, \Delta
\end{align*}

Define $ \Delta \vdash \CONTRACTORS$ by
\begin{itemize}
\item $\DOM (\Delta) = \DOM (\CONTRACTORS)$
\item $\JTypeCode{\CONTRACTORS (\PUH).\CODE} {\Delta (\PUH)}$
\item $\JTypeValue{\CONTRACTORS (\PUH).\STORAGE}{ \TYPE_s}$ where
  $\Delta (\PUH) = \TPAIR\ \TYPE_p\ \TYPE_s$. 
\end{itemize}

Preservation

If $[\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \BlockTrans{}
[\PENDING', \MANAGERS', \CONTRACTORS', \TIME']$
and $\Delta \vdash \CONTRACTORS$, \\
then
there is some $\Delta' \supseteq \Delta$ such that $\Delta' \vdash
\CONTRACTORS'$. 

Consider a blockchain state  $[\PENDING, \MANAGERS, \CONTRACTORS,
\TIME]$ where $\Delta \vdash \CONTRACTORS$.

For all $\OPH\in\DOM (\PENDING)$,
if  $\PENDING (\OPH) =  \Angle{\OP, \hat\TIME, \STATUS}$
\begin{itemize}
\item if $\OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ$, then
\begin{itemize}
  \item
  $\PUK, \PUK' \in \DOM (\MANAGERS)$
\end{itemize}
\item if $\OP = \TRANSFER[\PARAMETER]\NTEZ\PUK\PUH\MTEZ$, then
  \begin{itemize}
  \item $\PUK \in \DOM (\MANAGERS)$ and $\PUH\in\DOM (\CONTRACTORS)$
  \item $\PARAMETER : \TYPE_p$ where $\Delta (\PUH)  =\TPAIR\ \TYPE_p\ \TYPE_s$. 
  \end{itemize}
  
\item if $\OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ$ and $\STATUS =
  \STATUSINCLUDED\ \TIME'$, then
   \begin{itemize}
   \item $\PUK \in \DOM (\MANAGERS)$
  \item $\CODE : \TPAIR\ \TYPE_p\ \TYPE_s$
  \item $\STRING : \TYPE_s$
  \item if $\STATUS =
  \STATUSINCLUDED\ \TIME'$, then $\PUH =\GENERATEHASH (\CODE, \hat\TIME) \in \DOM (\CONTRACTORS)$ and $\Delta (\PUH)  =\TPAIR\ \TYPE_p\ \TYPE_s$ (or $\CONTRACTORS(\PUH).\CODE = \CODE$).

  \end{itemize}
  
 \item if $st = \STATUSPENDING$ and $\MANAGERS(\PUK) = \Angle{\BAL,
     \COU}$, then $\BAL \ge \NTEZ +  \MTEZ$ 
\end{itemize}

\section{Transitions}
\label{sec:transitions}

We distinguish several kinds of transitions depending on their scope:
\begin{enumerate}
\item $\ExprTrans$ single-step evaluation of expressions in the node state,
\item $\NodeTrans$ internal transitions of a node,
\item $\BlockTrans$ transitions of the blockchain state,
\item $\SystemTrans$ blockchain system transitions.
\end{enumerate}

Evaluation of expressions is standard call-by-value lambda calculus defined
using evaluation contexts $\EC{}$.
\begin{mathpar}
  \inferrule{}{
    \EC{(\lambda x.\EXPR)\VAL} \ExprTrans \EC{\EXPR[\VAL/x]}
  }

  \inferrule{}{
    \EC{\FST (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_1}
  }

  \inferrule{}{
    \EC{\SND (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_2}
  }

  \inferrule{
    \TRY \notin \EC[F]{}
  }{
    \EC{\TRY\ {\EC[F]{\RAISE\ \VAL}}\ \EXCEPT\ \EXPR} \ExprTrans
    \EC{\EXPR\ \VAL}
  }

  \inferrule{}{
    \EC{\MATCH\ \NIL\ \WITH\ \NIL\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR}
  }

  \inferrule{}{
    \EC{\MATCH\ (\CONS\ \VAL_1\ \VAL_2)\ \WITH\ (\CONS\ x_1\ x_2)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL_1,\VAL_2/x_1, x_2]}
  }

  \inferrule{}{
    \EC{\MATCH\ \NONE\ \WITH\ \NONE\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR}
  }

  \inferrule{}{
    \EC{\MATCH\ (\SOME\ \VAL)\ \WITH\ (\SOME\ x)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL/x]}
  }

  \inferrule{}{
    \EC{\MATCH\ (\LEFT\ \VAL)\ \WITH\ (\LEFT\ x)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL/x]}
  }

  \inferrule{}{
    \EC{\MATCH\ (\RIGHT\ \VAL)\ \WITH\ (\RIGHT\ x)\to\EXPR \mid \dots}
    \ExprTrans
    \EC{\EXPR[\VAL/x]}
  }
\end{mathpar}

The internal transitions of a node are just evaluation of expressions.
\begin{mathpar}
  \inferrule[Node-Eval]
  {
    \EXPR \ExprTrans \EXPR'
  }{
    [\EC\EXPR :: \EXPRS, \ACCOUNTS] \NodeTrans{}
    [\EC{\EXPR'} :: \EXPRS, \ACCOUNTS]
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Node-Inject]{
    \Angle{\PAK,\PUK} \in \ACCOUNTS \\
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUB (\MANAGERS, \PUK') \\
    \CHECKGAS (\PUK, \PUK', \NTEZ, \MTEZ) \\
    %\OPH = \GENERATEOPH (\PUK, \PUK','', \NTEZ, \MTEZ, \TIME) \\
    \OPH = \GENERATEOPH (\OP, \TIME) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ    
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] } \SystemTrans \\
   { [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
     [ \OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     ::\PENDING,
     \UPDATECOU(\MANAGERS, \PUK, \TRUE),
     \CONTRACTORS,
     \TIME]
   }
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \TIME - \hat\TIME \le 60
  }{
    { 
      [\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSPENDING}
     ::\PENDING, \MANAGERS,
      \CONTRACTORS, \TIME]}
    \BlockTrans  \\
    { 
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, 
      \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ),
      \CONTRACTORS, \TIME +1]}
  }
\end{mathpar}

The timeout transition applies to all operations.
\begin{mathpar}
  \inferrule[Block-Timeout]{
    % \OP = \TRANSFER[\STRING]\NTEZ\PUK\ADDR\MTEZ \\
    \TIME-\hat\TIME > 60
  }{ 
    {[\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSPENDING}
     ::\PENDING, \MANAGERS,
      \CONTRACTORS, \TIME]}
    \BlockTrans \\
    { 
      [\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSTIMEOUT}
     :: \PENDING, \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
      \CONTRACTORS, \TIME]}
  }
\end{mathpar}

% \begin{itemize}
% \item library call \texttt{call\_contract} with \texttt{confirmations:None} corresponds to
%   \begin{enumerate}
%   \item{} first \TirName{Node-Op'}, \TirName{Node-Inject'}
%   \item{} first \TirName{Node-Op'}, \TirName{Node-Reject(balance,count,pubkey,fee)}
%   \end{enumerate}
% \item afterwards must check the status to find whether the
%   transfer is still pending or \TirName{Block-Accept''} or
%   \TirName{Block-Timeout''} has happened.
% \item no further transfer is possible before the status is resolved to
%   accept or timeout.
% \end{itemize}

\subsection{Special reductions}
\label{sec:special-reductions}



\begin{mathpar}
  \inferrule[Contract?]{
    \JTypeCode\CODE{\TPAIR\ \TYPE\ \TYPEU} \\
    \BLOCKCHAIN.\CONTRACTORS (\PUH) =  \Angle{\CODE, \tilde\TIME, \NTEZ', \STRING'}
    %
    }{
    { [\EC{\CONTRACT\ \TYPE\ \PUH}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\SOME\ \PUH} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }

  \inferrule[Contract-Implicit?]{
    \PUK \in \DOM(\BLOCKCHAIN.\MANAGERS)
    %
    }{
    { [\EC{\CONTRACT\ \TUNIT\ \PUK}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\SOME\ \PUK} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }

  \inferrule[Contract-No?]{
    \ADDR \in \DOM (\BLOCKCHAIN.\MANAGERS) \Rightarrow \TYPE\ne\TUNIT \\
    \BLOCKCHAIN.\CONTRACTORS (\ADDR) = \Angle{\CODE, \tilde\TIME,
      \NTEZ', \STRING'} \Rightarrow {}
        \JTypeCode\CODE{\TPAIR\ \TYPE'\ \TYPEU} \wedge \TYPE \ne \TYPE' \\
    }{
    { [\EC{\CONTRACT\ \TYPE\ \ADDR}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\NONE} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }
\end{mathpar}



\subsection{Transitions on Nodes}
\label{sec:transitions-nodes}

Each node has (nondeterministic) rules to propose an operation.
When an operation $\OP$ appears, we check that the account is local by
looking up its public key $\OP.\PUK$ in the local accounts $\ACCOUNTS$ and
consider it signed with the corresponding private key $\PAK$.

\begin{mathpar}
  \inferrule[Node-System]
  {\NODE \NodeTrans \NODE'}
  { {\NODE :: \overline\NODE \| \BLOCKCHAIN}
    \SystemTrans
    {\NODE' :: \overline\NODE \| \BLOCKCHAIN}}

  \inferrule[Block-System]
  {\BLOCKCHAIN \BlockTrans \BLOCKCHAIN'}
  { {\overline\NODE \| \BLOCKCHAIN}
    \SystemTrans
    {\overline\NODE\| \BLOCKCHAIN'}}
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of counter]{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \OP.\PUK) \\
    }{
    { [\EC\OP  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\RAISE\ \ERRCOUNT} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of balance]{
    \NEG\ \CHECKBAL (\BLOCKCHAIN.\MANAGERS, \OP.\PUK, \OP.\NTEZ, \OP.\MTEZ) \\
    }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      } \SystemTrans
    { [\EC{\RAISE\ \ERRBAL} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
  }
\end{mathpar}

\subsection{An Implicit Account Transfer}
\iffalse 
\fi

\begin{mathpar}
  \inferrule[rejected of public key]{
    \NEG\ \CHECKPUB (\BLOCKCHAIN.\MANAGERS, \PUK') \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    } \SystemTrans
   { [\EC{\RAISE\ \ERRPUK} :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
    }
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of fee]{
    \NEG\ \CHECKGAS (\BLOCKCHAIN.\MANAGERS, \PUK,\PUK',\NTEZ, \MTEZ) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
     } \SystemTrans
    { [\EC{\RAISE\ \ERRFEE} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
  }
\end{mathpar}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse 
Rule 6 [included]:
\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \TIME'-\TIME < 60
  }{
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans  \\
    {[\PENDING, \Angle{\OP,\OPH, \TIME,\TIME'} :: \ACCEPTED,
      \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ),
      \CONTRACTORS, \TIME'+1]}
  }
\end{mathpar}
Rule 7 [timeout]: (applies to both, implicit transfers and contract invocations)
\begin{mathpar}
  \inferrule[Block-Timeout]{
    \OP = \TRANSFER[\STRING]\NTEZ\PUK\ADDR\MTEZ \\
    \TIME'-\TIME \ge 60
  }{
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans
    {[\PENDING, \ACCEPTED, \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
      \CONTRACTORS, \TIME']}
  }
\end{mathpar}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Smart Contracts}
A. Originate

\begin{mathpar}
  \inferrule[Block-Originate]{
   \Angle{\PAK,\PUK} \in \ACCOUNTS \\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPRG (\CODE) \\
    \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ)  \\
    \CHECKINIT (\CODE, \STRING) \\
    %\OPH = \GENERATEOPH(\PUK, \CODE, \STRING, \NTEZ, \MTEZ, \TIME) \\
    \OPH = \GENERATEOPH(\OP, \TIME) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ    
  }{
    [\EC\OP  :: \EXPRS, \ACCOUNTS,
      ] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \to \\
    [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
      [\OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     ::\PENDING, \UPDATECOU(\MANAGERS,\PUK,\TRUE), \CONTRACTORS, \TIME]
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of code]{
    \NEG\ \CHECKPRG (\CODE) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRPRG] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}

\iffalse 
Rule 3 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \PUK) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRCOUNT] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}


\begin{mathpar}
  \inferrule[rejected of balance]{
    \NEG\ \CHECKBAL (\BLOCKCHAIN.\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRBAL] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}
\fi

\begin{mathpar}
  \inferrule[rejected of fee]{
    \NEG\ \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRFEE] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of initial storage]{
    \NEG\ \CHECKINIT (\CODE, \INIT) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRINIT] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \PUH = \GENERATEHASH(\CODE, \TIME) \\
    \TIME-\hat\TIME  \le 60
  }{
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING} :: \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    \BlockTrans \\
     [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, \UPDATESUCC
      (\MANAGERS, \PUK, \NTEZ, \MTEZ),\\ \PUH \mapsto  \Angle{\CODE, \TIME, \NTEZ, \STRING} :: \CONTRACTORS, \TIME+1]
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[Block-Accept-Query]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \PENDING (\OPH) =  \Angle{\OP,
       \hat\TIME, \STATUSINCLUDING\ \tilde\TIME} \\
    \CONTRACTORS (\PUH) =  \Angle{\CODE, \tilde\TIME, \NTEZ', \STRING'}
  }{
      [\EC{\QRY\ \GETCONTRACT\ \OPH}  :: \EXPRS, \ACCOUNTS] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    \SystemTrans 
     [\EC{ \PUH}  :: \EXPRS, \ACCOUNTS] \|  [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}

% \begin{mathpar}
%   \inferrule[Block-Timeout]{
%     %\OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
%     \TIME-\hat\TIME > 60
% }{
%       [ \OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING}
%      ::\PENDING, \MANAGERS,
%       \CONTRACTORS, \TIME]  
%       \BlockTrans \\    
%       [ \OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSTIMEOUT}
%      :: \PENDING, \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
%       \CONTRACTORS, \TIME] 
%   }

% \end{mathpar}
~\\
~\\
B. \textbf{Transfer}

\begin{mathpar}
  \inferrule[Block-Call]{
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\ 
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUH (\CONTRACTORS, \PUH) \\
    \CHECKARG (\CONTRACTORS, \PUH, \PARAMETER) \\
    \CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ) \\
%    \OPH = \GENERATEOPH (\PUK,\PUH, \PARAMETER,\NTEZ, \MTEZ, \TIME) \\
    \OPH = \GENERATEOPH (\OP, \TIME) \\
    \OP =  \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\    
  }{ [\EC\OP  :: \EXPRS, \ACCOUNTS,
      ] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]     
    \SystemTrans \\
    [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
      [\OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     :: \PENDING, \UPDATECOU(\MANAGERS, \PUK, \TRUE), \CONTRACTORS, \TIME]}
\end{mathpar}

\iffalse 
Rule 2 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \PUK) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN      
    \SystemTrans
   [\EC[\RAISE\ \ERRCOUNT] :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN }
\end{mathpar}
~\\
~\\
Rule 3 [rejected of balance]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
\fi


\begin{mathpar}
  \inferrule[rejected of public hash]{
    \NEG\ \CHECKPUH (\BLOCKCHAIN.\CONTRACTORS, \PUH) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ
  }{[\EC\OP  :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN    
    \SystemTrans
    [\EXPRS[\RAISE\ \ERRPUH], \ACCOUNTS] \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of argument]{
    \NEG\ \CHECKARG (\BLOCKCHAIN.\CONTRACTORS, \PUH, \PARAMETER)\\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ
  }{[\EC\OP  :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN    
    \SystemTrans
    [\EXPRS[\RAISE\ \ERRARG], \ACCOUNTS] \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of fee]{
    \NEG\ \CHECKGAS (\BLOCKCHAIN.\CONTRACTORS, \PUH, \PARAMETER, \MTEZ) \\ \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ 
  }{[\EC\OP  :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN    
    \SystemTrans
    [\EXPRS[\RAISE\ \ERRFEE], \ACCOUNTS] \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[block Accept]{
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK\PUH\MTEZ \\
    \TIME-\hat\TIME \le 60
  }{
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING} :: \PENDING, \MANAGERS,
    \CONTRACTORS, \TIME]
    \BlockTrans \\
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, 
    \UPDATESUCC (\MANAGERS, \PUK, '', \NTEZ, \MTEZ), \\
    \UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER),
    \TIME+1]
  }
\end{mathpar}
\section{Queries}
\begin{mathpar}
  \inferrule[counter]{
    \BLOCKSYSTEM = 
      [\PENDING, \PUK \mapsto \Angle{\BAL, \COU} :: \MANAGERS, \CONTRACTORS, \TIME]
  }{[\EC{\GETCOUNTER\PUK} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\COU} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[balance of an implicit account]{
    \BLOCKCHAIN = 
      [\PENDING, \PUK \mapsto \Angle{\BAL, \COU} :: \MANAGERS, \CONTRACTORS, \TIME]
  }{[\EC{\GETBALANCE\PUK} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\BAL} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
\inferrule[balance of smart contract]{
    \BLOCKSYSTEM = 
      [\PENDING,  \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETBALANCE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\BAL} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[storage]{
    \BLOCKSYSTEM = 
      [\PENDING, \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETSTORAGE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\STORAGE} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[code]{
    \BLOCKSYSTEM = 
      [\PENDING,  \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETCODE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\CODE} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[type]{
    \BLOCKSYSTEM = 
      [\PENDING,  \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETTYPE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\Delta (\PUH)} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}



\begin{mathpar}
  \inferrule[fail of a query for an implicit account]{
    \NEG\ \CHECKPUB (\BLOCKCHAIN.\MANAGERS, \PUK) \
  }{[\EC{\GETBALANCE\PUK/\GETCOUNTER\PUK} :: \EXPRS, \ACCOUNTS]  \| 
  \BLOCKCHAIN 
    \NodeTrans {[\EC{\RAISE\ \ERRPUK} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}}
\end{mathpar}

\begin{mathpar}
  \inferrule[fail of a query for a smart contract]{
    \NEG\ \CHECKPUH (\BLOCKCHAIN.\CONTRACTORS, \PUH) 
  }{[\EC{\GETBALANCE\PUH/\GETSTORAGE\PUH/\GETCODE\PUH/\GETTYPE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\\ [\EC{\RAISE\ \ERRPUH} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[status-pending]{
    \BLOCKSYSTEM = 
      [\OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING} :: \PENDING,  \CONTRACTORS, \TIME]
  }{[\EC{\GETSTATUS\OPH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\STATUSPENDING} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[status-including]{
    \BLOCKSYSTEM = 
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME'} :: \PENDING,  \CONTRACTORS, \TIME] \\
    $n$ \ = \TIME\ - \TIME'
  }{[\EC{\GETSTATUS\OPH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\STATUSINCLUDING($n$)} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[status-timeout]{ 
   \BLOCKSYSTEM = 
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSTIMEOUT} :: \PENDING, \CONTRACTORS, \TIME]
  }{[\EC{\GETSTATUS\OPH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \NodeTrans\ [\EC{\STATUSTIMEOUT} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}
\section{Functions}
\begin{enumerate}
    \item Function $\CHECKPUB(\MANAGERS, \PUK)$ checks whether a public key $\PUK$ exists in $\MANAGERS$.
    \begin{itemize}
    \item[] $\CHECKPUB(\MANAGERS, \PUK)$ = $\TRUE$ iff $\PUK \in \DOM(\MANAGERS)$
    \end{itemize}
    \item Function $\CHECKPUH(\CONTRACTORS, \PUH)$ checks whether a public hash $\PUH$ exists in $\CONTRACTORS$.
     \begin{itemize}
    \item[] $\CHECKPUH(\CONTRACTORS, \PUH)$ = $\TRUE$ iff $\PUH \in \DOM(\CONTRACTORS)$
    \end{itemize}
    \item Function $\CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ)$ checks whether the balance of the account that associates with the public key $\PUK$ is greater or equal to $\NTEZ$ plus $\MTEZ$.
    \begin{itemize}
    \item[] $\MANAGERS(\PUK)$ = $\Angle{\BAL, \COU}$ and $\BAL \ge \NTEZ + \MTEZ$
    \end{itemize}
    \item Function $\CHECKCOU (\MANAGERS, \PUK)$ checks whether the current counter of an account that associates with the public key $\PUK$ is unlocked (its flag is False).
    \begin{itemize}
    \item[] $\MANAGERS(\PUK)$ = $\Angle{\BAL, \COU}$ and $\COU.b = \FALSE$
    \end{itemize}
   % \item Function \CHECKEXIST (\OPH, \PENDING, \ACCEPTED)\ checks whether an operation  \OPH\ exists in either \PENDING\ or \ACCEPTED.
    \item Function $\UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ)$ updates the balance and the counter of the account that associates with the public key $\PUK$ and the balance of the account that associates with the public key $\PUK'$, where
    \begin{itemize}
        \item[]  $\PUK \mapsto \Angle{\BAL, (\hat\NTEZ, \TRUE)}$ $\Rightarrow$ $ \PUK \mapsto \Angle{\BAL - \NTEZ - \MTEZ, (\hat\NTEZ + 1, \FALSE)}$     
        \item[] $\PUK' \mapsto \langle  \BAL', \COU' \rangle$ $\Rightarrow$ $\PUK' \mapsto \langle \BAL' + \NTEZ, \COU' \rangle $         
    \end{itemize}
    
    \item Function $\UPDATECOU(\MANAGERS, \PUK, \BOOLEAN)$ updates the counter flag (True $=$ locked, False $=$ unlocked) of the account that associates with the public key $\PUK$, where
    \begin{itemize}
        \item[]  $ \PUK \mapsto \langle \BAL, (\NTEZ, \hat\BOOLEAN) \rangle $ $\Rightarrow$ $\PUK \mapsto \langle \BAL, (\NTEZ, \BOOLEAN) \rangle $ 
    \end{itemize}
    
    \item Function  $\UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER)$ updates the contractor that associates with the public hash $\PUH$, where
    \begin{itemize}
        \item[] $\PUH  \mapsto \langle   \CODE, \TIME, \BAL, \STORAGE, \rangle $ $\Rightarrow$ $\PUH  \mapsto \langle  \BAL + \NTEZ, \CODE, \\ \UPDATESTORAGE(\STORAGE,\CODE,\PARAMETER) \rangle $
    \end{itemize}
    
     \item Function $\UPDATESTORAGE(\STORAGE, \CODE,  \PARAMETER)$ returns the new storage by running the code $\CODE$ on the  current storage  $\STORAGE$ with  the input parameter $\PARAMETER$.
    
    \item Function $\CHECKPRG (\CODE)$ checks whether the code $\CODE$ is well type.
    
    \begin{itemize}
        \item[] $\CHECKPRG (\CODE) = \TRUE$ iff $\CODE : \TPAIR\ \TYPE_p\ \TYPE_s$
    \end{itemize}
    \item Function $\CHECKINIT (\CODE, \INIT)$ checks whether the initil stogare valude is well type with corresponding to the code $\CODE$.
    \begin{itemize}
        \item[] $\CHECKINIT (\CODE, \INIT) = \TRUE$ iff $\CODE : \TPAIR\ \TYPE_p\ \TYPE_s$ and $\STRING : \TYPE_s$
    \end{itemize}
    
    \item Function $\CHECKARG (\CONTRACTORS, \PUH, \PARAMETER)$ checks whether the input parameter  $\PARAMETER$ to the smart contract $\PUH$ in $\CONTRACTORS$ is well type with corresponding to its code.
    \begin{itemize}
        \item[] $\CHECKARG (\CONTRACTORS, \PUH, \PARAMETER) = \TRUE$ iff $\Delta (\PUH) =
  \TPAIR\ \TYPE_p\ \TYPE_s$ and $\PARAMETER : \TYPE_p$
    \end{itemize}
   
   % \item Function \CHECKGAS(\CODE, \INIT, \MTEZ) checks whether the gas that is consumed to run the code \CODE\ for the initial value \INIT\ is less or equal to \MTEZ.
    \item Function  $\CHECKGAS (\MANAGERS, \PUK,\NTEZ, \MTEZ)$/ $\CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ)$ / $\CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ)$ check whether the fee that is consumed to emit the opertion is less or equal to the fee \MTEZ. 
    %run the code \CODE\ that associates with the public hash \PUH\ for the paremeter \PARAMETER\ is less or equal to \MTEZ.
    \item Function \GENERATEOPH (\PUK, {\ADDR /\CODE},{\INIT /\PARAMETER}, \NTEZ, \MTEZ,  \TIME) generates an operation hash.

    \item Function \GENERATEHASH (\CODE, \TIME)  generates the public hash of a smart contract.
     
   
\end{enumerate}
\end{document}