\documentclass[a4paper]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{mathpartir}
\usepackage{fixme}
\usepackage{xcolor}
\usepackage{listings}
\lstdefinelanguage{michelson}{
%  basicstyle=\ttfamily,
  morekeywords={parameter,storage,or,unit,mutez,pair,bool,address}, sensitive=false,
  morecomment=[l]{\#},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}
\lstset{language=Caml}
\input{macros}

\title{A Typed Programmatic Interface to Contracts on the Blockchain}

\author{Thi Thu Ha Doan\and
Peter Thiemann\orcidID{0000-0002-9000-1239}}
\institute{University of Freiburg, Germany\\
\email{\{doanha,thiemann\}@informatik.uni-freiburg.de}
}

\date{\today}

\begin{document}
\maketitle
\pagestyle{plain}
\begin{abstract}
  Smart contract applications on the block chain can only reach their full potential if
  they can be integrated with traditional software systems. Invoking
  contracts and observing the state of the blockchain requires a
  programmatic interface. We propose a typed API for this
  purpose and establish some properties of the combined
  system. Specifically, we provide an execution model that
  enables us to prove type-safe interaction between programs and the 
  blockchain. We establish further properties of the model that
  give rise to requirements on the API. A prototype of the interface
  is implemented in OCaml for the Tezos blockchain.
\end{abstract}

\section{Introduction}
\label{sec:introduction}


{[Ultra-brief intro to blockchain]}

Smart contracts rarely live in isolation. To reach their full
potential, it should be possible to integrate them with traditional
software systems and to enable input from outside the blockchain. Such
input requires trusted intermediaries that run so-called oracles \cite{oracle-patterns, call-action-oracle}. A
smart contract registers a request and a callback with an oracle. The
oracle invokes the callback as soon as an answer is available. 

We present two examples where integration of smart contracts is needed
and propose a typed API for making such integration type safe.

\subsubsection{Contributions}
\label{sec:contributions}

\begin{itemize}
\item An operational semantics for functional programs running
  alongside smart contracts in a blockchain. 
\item Established various properties of the combined system withs
  proofs in upcoming techreport.
\item An implementation of a low-level OCaml-API to the Tezos
  blockchain, which corresponds to the operational semantics.
\end{itemize}

\section{Motivation}
\label{sec:motivation}

Suppose you want to run an auction on the blockchain using a smart
contract. Once to the contract is deployed, the
auction is open for bidding, but it should be closed after 48 hours,
say. Such a timeout is a typical task for an oracle. Rather than
trusting a generic oracle, you prefer to roll your own mechanism that reliably closes the auction
after 48 hours have passed. So you want to write a program to do so. 

As a bidder, you may want to implement a bidding
strategy that starts at a certain amount and increases the bid until a
limit is reached. Of course, you only want to increase your bid if
someone else placed a higher bid. So you also want to write a
program to implement this strategy.

Neither task can be implemented as a smart contract alone because both react
to external triggers. Closing requires to schedule the invocation of a
contract at a certain time. Bidding 
requires to watch the current highest bid of the contract and
react if another bidder places a higher bid.

For concreteness, Listing~\ref{lst:auction-contract-header} shows the
header of an auction contract in Michelson \cite{michelson}. The
\lstinline/parameter/ clause specifies the contract's parameter
type. It is a sum type (indicated by \lstinline/or/) and each
alternative constitutes an entrypoint, named \lstinline/%close/ and
\lstinline/%bid/. The caller selects the entrypoint by injecting the argument into the
\lstinline/left/ or \lstinline/right/ summand. Both entrypoints take a \lstinline{unit}
parameter. The \lstinline/%bid/ entrypoint considers the transferred
tokens as the bid.
The \lstinline/storage/ clause declares the state of the contract,
which is a nested pair type indicating whether bidding is allowed
(\lstinline{bool}), the address of the contract owner (to prohibit
unauthorized calls to \lstinline/%close/), and the bidder's
address. The highest bid corresponds to the token balance of the contract.
\begin{lstlisting}[language=michelson,numbers=none,float,caption={Header of the auction contract},label={lst:auction-contract-header},captionpos=b,emph={close,bid},emphstyle=\underbar]
parameter (or (unit %close)
              (unit %bid)); # bid in transfer
storage (pair bool          # bidding allowed
         (pair address      #  contract owner
          address           # highest bidder's address
        ));
\end{lstlisting}

To avoid too much detail, we just outline the implementation of the entrypoints. The
\lstinline/%close/ entrypoint first checks its sender's address
against the owner's address in the store. Then it transfers the funds
to the owner, closes the contract by clearing the bidding flag, and
leaves it to the owner to deliver the
goods.\footnote{For simplicity we elide safeguarding by a third-party oracle.}
The \lstinline/%bid/ entrypoint immediately returns each bid that is not higher
than the existing highest bid. Otherwise, it keeps the funds
transferred, returns the previous highest bid to its owner, and stores
the current bidder as the new highest bidder.


Timed contract closing and strategic bidding cannot be implemented in
a smart contract, but could be implemented in separate programs that
interact with the blockchain. We present some idealized code for these tasks.

First the code that creates an auction contract and closes it after 48 hours. 
\begin{lstlisting}[language=Caml,numbers=none,basicstyle=\small]
let _ = Cl.set_authority (my_address)
let initial_store = (true, (my_address, my_address))
let contract = Cl.originate(auction_script, 1, initial_store)
Time.sleep(48 * 3600);               (* 48h in seconds *)
Cl.call_contract(contract, left ()); (* entrypoint %close *)
\end{lstlisting}
We assume that \lstinline/Cl/ is the module containing the contract
library, \lstinline{set_authority} sets the sender address for
upcoming operations,  \lstinline/originate/ deploys its argument contract along
with the provided funds of one token and the \lstinline/initial_store/, 
\lstinline{auction_script} is the contract from Listing~\ref{lst:auction-contract-header}, and 
\lstinline{call_contract} invokes a contract with a parameter. The
\lstinline{initial_store} sets the bidding flag, and both owner and
highest bidder to the sender account.


To implement the bidding strategy, we first check the state of the
contract to find the current highest bid. As long as bidding is
allowed and the current bid is below our \lstinline/limit/, we update
our bid by a given amount \lstinline/step/, and then keep watching the state of the contract by
polling it every five minutes. 
\begin{lstlisting}[numbers=none,basicstyle=\small]
let rec poll (limit, step, ((bidding, _), (high_bid, _))) =
  if bidding and high_bid < limit then
    Cl.call_contract (contract, 
      right (min (high_bid + step, limit))); (* entrypoint %bid *)
    Time.sleep(5 * 60);
    let state = Cl.get_state (contract);
    poll (limit, step, state)
in
poll (limit, step, Cl.get_state (contract))
\end{lstlisting}
The \lstinline{get_state} function obtains the storage of a contract from
the blockchain.

This code is idealized in several respects. Originating or running a contract
requires to propose a fee to the blockchain, which may or may not be
accepted.
Starting a contract may also time out for a variety of reasons. So just
invoking a contract with a fixed fee does not guarantee the contract's
execution.  Even if the invocation is locally accepted, it still takes
a couple of cycles before we can be sure the invocation is globally
accepted and incorporated in the blockchain.
Hence, after starting the invocation, we have to observe the fate of
this invocation. If it does not get incorporated, then we need to
analyse the reason and react accordingly. For example, if the
invocation was rejected because of an insufficient fee, we might want
to restart with an increased fee. Or we might decide to wait until the
invocation goes through without increasing the fee.

Hence, we would implement a scheme similar to
the bidding strategy: start with a low fee and increase (or wait) until the
contract is accepted or a fee cap is reached. On the other hand, an
observer function like \lstinline/get_state/ always succeeds.

The low-level interface that we propose in this paper requires the
programmer to be explicit about fees, waiting, and polling the state
of contract invocations. 

In summary, a useful smart-contract-API  has facilities to
\begin{itemize}
\item query the current state of the blockchain (e.g., fees in the
  current block),
\item query storage and balance of a contract (to obtain
  the current highest bid),
\item originate contracts, invoke contracts, and initiate
  transfers. Hence, the API has to run on
  behalf of some account (by holding its private key).
\end{itemize}
All these facilities are supported by the (untyped) RPC interface of the Tezos
blockchain, which is the basis of our implementation. 

\section{Execution Model}
\label{sec:execution-model}
The context of our work is the Tezos blockchain \cite{tezos-whitepaper,tezos-intropaper}. Tezos is a self-amending blockchain that improves several aspects compared to established blockchains. Tezos proposes an original consensus algorithm called Liquid Proof of Stake that allows consensus not only on the state of its ledger, like Bitcoin \cite{bitcoin-whitepaper} or Ethereum \cite{eth-whitepaper}, but also on how the economic protocol and nodes should upgrade, and serves as a decentralized smart contract platform that focuses on formal methods to improve security. 

In Tezos, there are two types of accounts: implicit accounts, which are associated with a pair of private/public keys, and smart contracts, which are a programmable account created by an origination operation and have no corresponding secret key. The address of a smart contract is a unique public hash that depends on the creation operation. An implicit account is maintained on the blockchain with its public key, balance, and counter, whose job is to prevent replay attacks. A smart contract account is stored with its script, storage, and balance. A contract script maps a pair of a parameter and a storage, which have fixed and monomorphic types to a pair of a list of internal operations and an updated storage. An implicit account performs three kinds of transactions: (1) transfer tokens to another implicit account, (2) invoke a smart contract, or (3) originate a new smart contract. A contract origination specifies the script of the contract and the initial contents of the contract storage, while a contract invocation must provide input data. Each transaction contains a fee to be paid either by payment to a baker or by destruction (burning). A transaction is injected into the blockchain network via a node, which then validates the transaction before submitting it to the network. Generally, a transaction can be rejected by the node for a number of reasons. Once the transaction is valid, it is injected into the mempool, which contains all pending transactions before they can be included in a block. On the other hand, a pending transaction can be lost in the mempool. A transaction is timed out when 60 blocks have passed and it can no longer be included in a block. When a transaction is included in a blockchain, the related accounts are updated according to the transaction result. 


The execution model is an abstraction of the Tezos blockchain \cite{tezos-whitepaper}
augmented with functional (OCaml) programs that interact with the
blockchain. As the blockchain is realized by a peer-to-peer network of
independent nodes, interaction happens through
\emph{local nodes} that receive requests to originate and invoke
contracts from programs that run on a particular node. We model the blockchain
itself as a separate, abstract global entity that represents the
current consensual state of the system. Our model does not express
low-level details, but relies on nondeterminism to describe
the possible behaviors of the system. In particular, we do
\textbf{not} formalize the execution of the smart contracts
themselves, we rather consider them as black boxes that execute in a
safe-safe way. Tezos' smart contract language Michelson and its
properties have been formalized elsewhere \cite{type-safe-michelson}.

We write $\emptyset$ for the empty set and $\mathbf{e :: s}$ to
decompose a set into an element $\mathbf{e}$ and a set
$\mathbf{s}$. We generally use lowercase boldface for metavariables
ranging over values of a certain syntactic category, e.g., \PUK\ for
public keys, and the capitalized name for the
corresponding type as well as the set of these values (as in \TPUK).

\subsection{Local Node}
\label{sec:local-node}

A local node runs on behalf of authorities, which are called
\emph{accounts} in Tezos. An account is represented by a key pair $\Angle{
  \PAK, \PUK
} $, where $\PAK$ is a private key and $\PUK$ the corresponding public
key in a public key encryption scheme.

The local node offers operations to transfer tokens from one account
to another, to invoke a contract, and to originate a contract on the blockchain.
\begin{align*}
  \OP &::= \TRANSFER[\PARAMETER]\NTEZ\PUK\ADDR\MTEZ
  \\&\mid \ORIGINATE\NTEZ\PUK\CODE\INIT\MTEZ
\end{align*}
In the transfer, \NTEZ\ is the amount of tokens transferred, \PUK\ is the public key of the
sender, \ADDR\ is either a public 
key for an implicit account (in case of a simple transfer)  or a
public hash for a smart contract (for an invocation), \PARAMETER\ is
the argument passed to the smart contract, 
which is empty for a simple transfer, and \MTEZ\ is
the amount of tokens for the transaction fee. In originate,  \CODE\ is
the script of a smart contract and \INIT\ is the initial value of the
contract's storage. Each operation returns an \emph{operation hash}
\OPH, on which we can query the status of the operation.

The local node offers several ways to query the current state of
the blockchain.
\emph{Queries} are defined by the following grammar:
\begin{align*}
  \QRY & ::=
  % \GETCOUNTER\PUK  
  %        \mid
         \GETBALANCE\ADDR
  \mid \GETSTATUS\OPH
  \mid \GETSTORAGE\PUH
  % \mid \GETCODE\PUH 
  % \mid \GETTYPE\PUH
  \mid \GETCONTRACT\OPH
\end{align*}
We obtain the balance associated with an implicit account or a
contract by its public key or public hash, respectively; the status of
a submitted operation by its operation hash; the stored value of a
contract by its public hash; and the code of a contract by the
operation hash of its originating transaction.

The domain-specific types come with different guarantees. Values of
type \TPUH\ and \TPUK\ as well as \TADDR\ are not necessarily valid,
as there might be no contract associated with a hash / no account
associated with a public key. In contrast, a value of type
$\TCONTRACT\ \TYPE$ is a public hash that is verified to be associated
with a contract with parameter type $\TYPE$. Operation hashes \OPH\
are only returned from blockchain operations. As the surface language
neither contains literals of type \TOPH\ nor are there casts into
that type, all values of \TOPH\ are valid. 

\begin{definition}%[State of a node]
  The \emph{state of a node} is a pair
  $\NODE = [ \EXPRS, \ACCOUNTS
  % , \OPERATIONS
  ]$, where $\EXPRS$ is a
  set of programs and $\ACCOUNTS \subseteq \TPAK \times \TPUK$  is a set of
  implicit accounts.
  % , and
  % $\OPERATIONS \subseteq \ECS \times \TOP $ is a set of pairs of
  % expression contexts and operations.
\end{definition}

\begin{figure}[tp]
\begin{align*}
  \CONSTANT & ::= \INT \mid \FIX
              \mid \OPH \mid \PUH \mid\PUK \mid \CODE \mid
              \NTEZ \mid \SUNIT \mid \FALSE \mid \TRUE \\
  \STATUS & ::= \STATUSPENDING \mid \STATUSINCLUDING (\INT) \mid
            \STATUSTIMEOUT \\
  \ERROR &::= \ERRPRG \mid \ERRBAL \mid \ERRCOUNT \mid \ERRFEE \mid
           \ERRPUK \mid \ERRPUH \mid \ERRARG \mid \ERRINIT\\
	\EXPR & :: =  \CONSTANT \mid \STATUS \mid \ERROR \mid \VARIABLE \mid \lambda \VARIABLE. \EXPR\ 
	\mid \EXPR\EXPR  %\mid \FST\ \EXPR \mid \SND\ \EXPR 	%\mid \NI \EI
  \mid \EXPR\ \PLUS\ \EXPR\ \mid
  % \EXPR\ \MINUS\ \EXPR\ \mid
  \EXPR\ \EQUAL\ \EXPR\
  % \mid  \EXPR\ \LESS\ \EXPR
  \mid \EXPR\ \AND\ \EXPR\ \mid \EXPR\ \OR\ \EXPR\ \mid \NOT\ \EXPR
  \\& \mid (\EXPR,\EXPR)\mid \NIL\ \mid \CONS\ \EXPR\ \EXPR \mid \LEFT\ \EXPR \mid\RIGHT\
  \EXPR \mid \SOME\ \EXPR \mid \NONE
  \mid \MATCH\ \EXPR\ \WITH\ \PATTERN\to\EXPR \dots 
  \\& \mid \RAISE\ \EXPR \mid \TRY\ \EXPR\ \EXCEPT\ \EXPR \mid \CAST\EXPR\TYPE\TYPEU
  \\& \mid \QOP\  \EXPR \mid \TRANSFER[\EXPR]\EXPR\EXPR\EXPR\EXPR
  \\& \mid \ORIGINATE\EXPR\EXPR\EXPR\EXPR\EXPR
  % \\&\mid \CONTRACT\ \TYPE\ \EXPR
  \\& \mid \TOSTRING\ \EXPR \mid \FROMSTRING\ \TYPE\ \EXPR
  \\
  \PATTERN &::= \VARIABLE \mid (\PATTERN, \PATTERN) \mid \NIL \mid \CONS\ \PATTERN\ \PATTERN \mid \LEFT\ \PATTERN \mid\RIGHT\
             \PATTERN \mid \SOME\ \PATTERN \mid \NONE \\
  &\mid \FALSE \mid \TRUE \mid \STATUS \mid \ERROR\\
  \QOP & ::= \GETBALANCE{} \mid \GETSTATUS{} \mid \GETSTORAGE{} \mid \GETCODE{} \mid \GETCOUNTER{}
         \mid \GETTYPE{}
  \\[2ex]
  \TYPE, \TYPEU & ::=
                  \TPUH \mid
                  \TPUK \mid
                  \TADDR \mid 
                  \TCONTRACT\ \TYPE \mid
                  \TCODE\ \TYPE\ \TYPEU \mid \TTEZ \mid
                  \TOPH \mid
                  \TSTATUS \mid \TEXCEPTION \\
  & \mid \TINT \mid \TUNIT \mid \TBOOL \mid \TSTRING \mid \TYPE\to\TYPEU \mid \TPAIR\ \TYPE\ \TYPEU \mid \TLIST\ \TYPE
    \mid \TSUM\ \TYPE\ \TYPEU \mid \TOPTION\ \TYPE 
\end{align*}
  \caption{Syntax of expressions, \EXPR, and types, \TYPE}
  \label{fig:syntax-expressions}
\end{figure}
All queries and operations are started by programs, i.e., closed expressions that run on the
local node. Each program can send transactions on behalf of any
account on the local node.  Figure~\ref{fig:syntax-expressions} defines the syntax of
expressions, which describe the usual constructs of call-by-value PCF
with sum, product, list, and option types, exceptions and fixpoint. Moreover, there are
domain-specific primitive types and constants \CONSTANT\ to support blockchain
operations, as well as several exceptional values collected in \ERROR.
Pattern matching is the only means to decompose values, cf.\ \PATTERN.
There is syntax to initiate transfers and to originate contracts as
well as for the queries. Finally, there is a type cast
$\CAST\EXPR\TYPE\TYPEU$, which is only applicable to pairs of
types related in the reflexive, transitive, and symmetric closure of
the subtyping relation in Figure~\ref{fig:subtyping}. Upcasts will
just go through, but downcasts may raise an exception, as usual.

Types (also in Figure~\ref{fig:syntax-expressions}) comprise a
collection of standard base types as well as 
functions, pairs, lists, sums, and option types. In addition, there
are domain specific types of public hashes $\TPUH$ and public keys $\TPUK$ subsumed by
a type of addresses $\TADDR$. $\TCONTRACT\ \TYPE$ is the type of
a contract with parameter type $\TYPE$. $\CODE\ \TYPE\ \TYPEU$
indicates a Michelson program with parameter type $\TYPE$ and storage
type $\TYPEU$. Tezos tokens have type $\TTEZ$. The type $\TOPH$ signifies operation hashes
returned by blockchain operations. Querying the status of an operation
returns a value of type $\TSTATUS$. Exceptions have type
$\TEXCEPTION$. 

\begin{figure}[tp]
\begin{align*}
  \ECN{} & :: = \ECHOLE \mid \SC[\overline\VAL\ \ECN{}\ \overline\EXPR] \mid \RAISE\ \ECN{} \mid \TRY\ \ECN{}\ \EXCEPT\ \EXPR
  \mid \MATCH\ \ECN{}\ \WITH\ \PATTERN\to\EXPR \dots
  \\
  \VAL & ::= \CONSTANT \mid \STATUS \mid \ERROR \mid \lambda x.\EXPR \mid(\VAL, \VAL) \mid
         \NIL \mid \CONS\ \VAL\ \VAL \mid \LEFT\ \VAL \mid \RIGHT\
         \VAL \mid \SOME\ \VAL\mid \NONE
\end{align*}
  \caption{Evaluation contexts and values}
  \label{fig:evaluation-contexts-values}
\end{figure}
Figure~\ref{fig:evaluation-contexts-values} defines evaluation
contexts $\ECS$ and values $\VAL$.
Here $\SC$ ranges over the remaining syntactic constructors, which are
treated uniformly: evaluation proceeds from left to right. Values are
standard for call-by-value lambda calculus.

% \begin{figure}[tp]
%   \begin{align*}
%     \LET\ \mathit{oph} &=  \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
%          & \FIX \lambda f.\lambda x. \MATCH\ \GETSTATUS{\mathit{oph}}\ \WITH \\
%          & \mid \STATUSPENDING \to \text{Time.sleep(1)}; f () \textrm{\qquad(* not yet included,
%            continue waiting *)} \\
%          & \mid \STATUSINCLUDING (n) \to \text{if } n < 50\text{ then
%            Time.sleep(1)};f ()\textrm{\quad(* included with $n$
%            blocks confirmation *)}\\
%          & \mid \STATUSTIMEOUT \to \textrm{(* lost operation, try
%            again *)}
%   \end{align*}
%   \caption{Pseudocode example for a token transfer}
%   \label{fig:pseudocode-example}
% \end{figure}
% Figure~\ref{fig:pseudocode-example} shows an incomplete example
% expression that transfers tokens from $\PUK$ to $\PUK'$ and then
% checks the status of the operation. The outer loop to raise the fee
% and retry is omitted.


We define a relation $\SubType$ that establishes pairs of types that can be
subjected to casting. It is given by the axioms
$\inferrule{}{\TPUH \SubType \TADDR}$, $\inferrule{}{\TPUK \SubType
  \TADDR}$, and $\inferrule{}{\TCONTRACT\ \TYPE \SubType \TPUH}$.
A cast from $\TYPE$ to $\TYPEU$ is only allowed
if $\TYPE \SubType \TYPEU$ (upcast) or $\TYPEU \SubType \TYPE$
(downcast). Upcasts always succeed, but downcasts may fail at run time.
In particular,  public hashes and public keys can both stand for addresses. Moreover, a smart
contract with parameter type $\TYPE$ is represented by its public hash
at run time. The corresponding downcast must check whether the public
hash is valid and has the expected parameter type.

Figure~\ref{fig:typing-expressions} presents selected typing rules for
expressions. We rely on an external typing judgment
$\JTypeCode\CODE\TYPE$ for the contract language, which we leave
unspecified, and $\JTypeValue\STRING\TYPE$ for serialized values as
stored on the blockchain. The latter judgment states $\STRING$ is
a string parseable as a value of type $\TYPE$.
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule{}{\JTypeExpr\TEnv\INT\TINT}

    \inferrule{}{\JTypeExpr\TEnv\OPH\TOPH}

    \inferrule{}{\JTypeExpr\TEnv\PUH{\TPUH}}

    \inferrule{}{\JTypeExpr\TEnv\PUK\TPUK}

    \inferrule{\JTypeCode \CODE{ \TPAIR\ \TYPE_p\
        \TYPE_s}}{\JTypeExpr\TEnv\CODE{\TCODE\ \TYPE_p\ \TYPE_s}}

    % \inferrule{\JTypeExpr\TEnv\EXPR\TADDR}{\JTypeExpr\TEnv{\CONTRACT\
    %     \TYPE\ \EXPR}{\TOPTION (\TCONTRACT\ \TYPE)}}
    %     
    \inferrule{}{\JTypeExpr\TEnv\NTEZ\TTEZ}

    \inferrule{}{\JTypeExpr\TEnv\SUNIT\TUNIT}

    \inferrule{}{\JTypeExpr\TEnv\FALSE\TBOOL}

    \inferrule{}{\JTypeExpr\TEnv\TRUE\TBOOL}

    \inferrule{}{\JTypeExpr\TEnv\STATUSPENDING\TSTATUS}

    \inferrule{}{\JTypeExpr\TEnv\STATUSTIMEOUT\TSTATUS}

    \inferrule{\JTypeExpr\TEnv\EXPR\TINT}{\JTypeExpr\TEnv{\STATUSINCLUDING
        (\EXPR)}\TSTATUS}

    \inferrule{}{\JTypeExpr\TEnv\ERROR\TEXCEPTION}

    \inferrule{\JTypeExpr\TEnv\EXPR\TYPE \\ \TYPE \SubType
      \TYPEU}{\JTypeExpr\TEnv\EXPR\TYPEU}

    \inferrule{}{\JTypeExpr\TEnv\VARIABLE{\TEnv (\VARIABLE)}}

    \inferrule{ \JTypeExpr{\TEnv, \VARIABLE:\TYPE'}\EXPR{\TYPE} }{
      \JTypeExpr\TEnv{\lambda\VARIABLE.\EXPR}{\TYPE'\to\TYPE}}

    \inferrule{
      \JTypeExpr\TEnv\EXPR{\TYPE'\to\TYPE} \\
      \JTypeExpr\TEnv{\EXPR'}{\TYPE'} }{ \JTypeExpr\TEnv{\EXPR\
        \EXPR'}\TYPE }

    \inferrule{
      \JTypeExpr\TEnv\EXPR\TYPE \\
      \JTypeExpr\TEnv{\EXPR'}{\TYPE'} }{ \JTypeExpr\TEnv{(\EXPR,
        \EXPR')}{\TPAIR\ \TYPE\ \TYPE'} }
  % 
    % \inferrule{
    % \JTypeExpr\TEnv{\EXPR}{\TPAIR\ \TYPE\ \TYPE'}
    % }{
    %   \JTypeExpr\TEnv{\FST\ \EXPR}\TYPE
    % }
  %   
    %   \inferrule{
    %   \JTypeExpr\TEnv{\EXPR}{\TPAIR\ \TYPE\ \TYPE'}
    % }{
    %   \JTypeExpr\TEnv{\SND\ \EXPR}{\TYPE'}
    % }

    \inferrule{ \JTypeExpr\TEnv\EXPR\TEXCEPTION }{
      \JTypeExpr\TEnv{\RAISE\ \EXPR}\TYPE }

    \inferrule{
      \JTypeExpr\TEnv\EXPR\TYPE \\
      \JTypeExpr\TEnv{\EXPR'}{\TEXCEPTION\to\TYPE} }{
      \JTypeExpr\TEnv{\TRY\ \EXPR\ \EXCEPT\ \EXPR'}\TYPE }

    \inferrule{
      \JTypeExpr\TEnv\EXPR\TYPE \\
      \TYPE \SubType \TYPEU \vee \TYPEU \SubType \TYPE
    }{
      \JTypeExpr\TEnv{\CAST\EXPR\TYPE\TYPEU}\TYPEU
    }
  \end{mathpar}
  \caption{Typing rules for expressions}
  \label{fig:typing-expressions}
\end{figure}
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule{
      \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
      \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
      \JTypeExpr\TEnv{\EXPR_3}\TPUK \\
      % \JTypeExpr\TEnv{\EXPR_3}{\TCONTRACT\ \TUNIT} \\
      \JTypeExpr\TEnv{\EXPR_4}\TUNIT \\
      \JTypeExpr\TEnv{\EXPR_5}\TTEZ }{
      \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
    }

    \inferrule{
      \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
      \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
      \JTypeExpr\TEnv{\EXPR_3}\TCONTRACT\ \TYPE \\
      \JTypeExpr\TEnv{\EXPR_4}{\TYPE} \\
      \JTypeExpr\TEnv{\EXPR_5}\TTEZ }{
      \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
    }


    \inferrule{
      \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
      \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
      \JTypeExpr\TEnv{\EXPR_3}{\TCODE\ \TYPE_p\ \TYPE_s} \\
      \JTypeExpr\TEnv{\EXPR_4}\TYPE_s \\ % really \TSTRING \\
      \JTypeExpr\TEnv{\EXPR_5}\TTEZ }{
      \JTypeExpr\TEnv{\ORIGINATE{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_4}{\EXPR_5}}\TOPH
    }
  \end{mathpar}
\begin{mathpar}
  \inferrule{
    \JTypeExpr\TEnv\EXPR\TPUK
  }{
    \JTypeExpr\TEnv {\QRY\ \GETCOUNTER\EXPR}\TINT
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR\TADDR
  }{
    \JTypeExpr\TEnv {\QRY\ \GETBALANCE\EXPR}\TTEZ
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR\TOPH
  }{
    \JTypeExpr\TEnv {\QRY\ \GETSTATUS\EXPR}\TSTATUS
  }

  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TPUH}
  }{
    \JTypeExpr\TEnv {\QRY\ \GETSTORAGE\EXPR}\TSTRING
  }

  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  % }{
  %   \JTypeExpr\TEnv {\QRY\ \GETCODE\EXPR}?
  % }
  %   
  % \inferrule{
  %   \JTypeExpr\TEnv\EXPR{\CONTRACT\ \TYPE}
  % }{
  %   \JTypeExpr\TEnv {\QRY\ \GETTYPE\EXPR}?
  % }
  %   
  \inferrule{
    \JTypeExpr\TEnv\EXPR{\TOPH}
  }{
    \JTypeExpr\TEnv {\QRY\ \GETCONTRACT\EXPR}\TPUH
  }
\end{mathpar}
  \caption{Typing rules for blockchain operations and queries}
  \label{fig:typing-blockchain-operations}
\end{figure}
% Generic rule for transfers
% \begin{mathpar}
%  \inferrule{
%    \JTypeExpr\TEnv{\EXPR_1}\TTEZ \\
%    \JTypeExpr\TEnv{\EXPR_2}\TPUK \\
%    \JTypeExpr\TEnv{\EXPR_3}\TADDR \\
%    \JTypeExpr\TEnv{\EXPR_4}\TSTRING \\
%    \JTypeExpr\TEnv{\EXPR_5}\TTEZ
%  }{
%    \JTypeExpr\TEnv{\TRANSFER[\EXPR_4]{\EXPR_1}{\EXPR_2}{\EXPR_3}{\EXPR_5}}\TOPH
%  }
% \end{mathpar}

Conversion to and from serialized storage; deserialization may fail
with an exception
\begin{mathpar}
  \inferrule{
    \JTypeExpr\TEnv\EXPR\TYPE \\
    \SERIALIZABLE (\TYPE)
  }{
    \JTypeExpr\TEnv{\TOSTRING\ \EXPR}\TSTRING
  }

  \inferrule{
    \JTypeExpr\TEnv{\EXPR}\TSTRING
  }{
    \JTypeExpr\TEnv{\FROMSTRING\ \TYPE\ \EXPR}\TYPE
  }
\end{mathpar}



\subsection{Global Structures}
\label{sec:global}

Our execution model abstracts from the particulars of the blockchain
implementation, like the peer-to-peer structure or the distributed
consensus protocol. Hence, we represent the blockchain by a few global
entities: managers, contractors, and a pool of operations. 

%\begin{definition}%[Manager]
A \emph{manager} keeps track of a single implicit account. Managers are
represented by a partial map $\MANAGERS : \TPUK \partialto \TBAL
\times \TCOU$. If $\MANAGERS (\PUK) = \Angle{\BAL, \COU}$ is defined, then  $\PUK$ is the
public key of an account, $\BAL$ is its
balance and $\COU$ is its counter whose form is a value-flag pair
$(n,b) \in \Nat\times\TBOOL$, where $n$ is the value of the counter
and ${b}$ is its flag.   The counter is used internally to serialize transactions.
%\end{definition}

%\begin{definition}%[Contractor]
A \emph{contractor} manages a smart contract. Contractors are
represented by a partial map $\CONTRACTORS : \TPUH \partialto
\TCODE \times \TIME  \times \TBAL \times  \TSTORAGE$. If $\CONTRACTORS (\PUH) = \langle
\CODE, \TIME, \BAL, \STORAGE \rangle $ is defined, then $\PUH$ is the
public hash of a contract,
$\CODE$ is its  code,
$\TIME$ is the time when it was accepted,
$\BAL$ is its current balance,
and $\STORAGE$ is its current storage. The hash $\PUH$ is
self-verifying as it is calculated from the fixed components $\CODE$
and $\TIME$. All time stamps will be different in our model.
% \end{definition}

When an operation is started on a node, it enters a \emph{pool} as a
pending operation. A pending operation is either dismissed after some time or
promoted to an included operation, which has become a permanent part
of the blockchain.

 %\begin{definition}%[Pending operation]
%An \emph{operation} is represented by a tuple  $\langle  \OP, \TIME, \STATUS \rangle $, where $\OP$ is an operation, $\TIME$ is the time when the operation was injected, and $\STATUS$ is either $\STATUSPENDING$,$\STATUSINCLUDED\ \TIME'$, or $\STATUSTIMEOUT$.  
%\end{definition}
%\begin{definition}
The pool is a partial map $  \PENDING= \TOPH \partialto
\TOP\times \TTIME \times \TSTATUS$ where
\begin{align*}
  \TSTATUS&= \STATUSPENDING + \STATUSINCLUDED\ \TTIME + \STATUSTIMEOUT
\end{align*}
such that
if $\PENDING(\OPH) = \langle  \OP, \TIME, \STATUS
\rangle $ is defined, then $\OPH$ is the public hash of the operation, $\OP$ is the operation, $\TIME$ is the time when the
operation was injected, and $\STATUS$ is either $\STATUSPENDING$,
$\STATUSINCLUDED\ \TIME'$, or $\STATUSTIMEOUT$.
A pool $\PENDING$ is \emph{well-formed} if, for all $\OPH$, $\PENDING (\OPH) =
\Angle{\OP,\TIME, \STATUSINCLUDED\ \TIME'}$ implies $\TIME' \ge
\TIME$ and $\OPH = \GENERATEOPH (\OP, \TIME)$.
%\end{definition}


A \emph{pending operation} is represented by
$\OPH \mapsto \langle  \OP, \TIME, \STATUSPENDING\rangle $.
Once the operation is accepted, it changes its status to included:
$\OPH \mapsto \langle  \OP, \TIME, \STATUSINCLUDED\ \TIME'\rangle $, where
$\TIME' \ge \TIME$ is  when the operation was included in the
blockchain.  The operation may also be dropped at any time, which is
represented by
$\OPH \mapsto \langle  \OP, \TIME, \STATUSTIMEOUT\rangle $. There are several
causes for dropping, primarily timeout or overflow of the pending
pool which is limited in size in the implementation.


% After some time, a pending operation may be included in the blockchain as an accepted operation.

 % \begin{definition}%[Accepted operation]
% An \emph{accepted operation}  is a tuple $\langle  \OP, \OPH, \TIME, \TIME' \rangle
% $, where $\OP$ is an operation, $\OPH$ is the operation hash, $\TIME$ is the time when the operation was injected, and
% $\TIME'$ is the time when it was included in the blockchain. 
% \end{definition}

%\begin{definition}%[Blockchain]
In summary, the \emph{state of a blockchain} is a tuple
$\BLOCKCHAIN = [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]$ where
$\PENDING$ is a pool of operations, $\MANAGERS$ is a map of managers,
$\CONTRACTORS$ is a map of contractors, and $\TIME$ is the current
time. 
% \end{definition}

We often use the dot notation to project a component from a tuple. For
instance, we write $\BLOCKCHAIN.\MANAGERS$ to access the managers
component. 

%\begin{definition}%[Blockchain system]
A \emph{blockchain configuration} has the form
$\BLOCKCHAIN[ \NODE_1, \dots, \NODE_n]$, for some $n>0$, where $\BLOCKCHAIN$ is a
blockchain and the $\NODE_i$ are local nodes, for $1\le i\le n$.
In a \emph{well-formed configuration}, the accounts on the local nodes are all different and each
local account has a manager in $\BLOCKCHAIN$:
\begin{enumerate}
\item for all $1\le i< j\le n$, $\NODE_i.\ACCOUNTS \cap
  \NODE_j.\ACCOUNTS = \emptyset$;
\item for all $1\le i \le n$, 
    $\forall a \in \NODE_i.\ACCOUNTS \implies a.\PUK \in \DOM( \BLOCKCHAIN.\MANAGERS)$.
\end{enumerate}
%\end{definition}

\section{Operational Semantics}
\label{sec:transitions}

The operational semantics is defined by several kinds of transitions depending on their scope:
\begin{enumerate}
\item $\ExprTrans$ single-step evaluation of an expression in a local node,
\item $\NodeTrans$ internal transitions of a node,
\item $\BlockTrans$ transitions of the blockchain state,
\item $\SystemTrans$ blockchain system transitions.
\end{enumerate}

Evaluation of expressions is standard for call-by-value lambda calculus defined
using evaluation contexts
$\EC{}$. Figure~\ref{fig:expression-reduction} shows some of the
reduction rules. 
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule{}{ \EC{(\lambda x.\EXPR)\VAL} 
      \ExprTrans 
      \EC{\EXPR[\VAL/x]} }

    \inferrule{}{ \EC{\TRY\ \VAL\ \EXCEPT\ \EXPR} \ExprTrans \EC{\VAL} }

    % \inferrule{}{
    % \EC{\FST (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_1}
    % }
  %   
    %   \inferrule{}{
    %   \EC{\SND (\VAL_1, \VAL_2)} \ExprTrans \EC{\VAL_2}
    % }
  %   
    \inferrule{\TYPE \SubType \TYPEU}{ \EC{\CAST\VAL\TYPE\TYPEU} \ExprTrans \EC{\VAL}}

    \inferrule{ \TRY \notin \EC[F]{} }{ \EC{\TRY\ {\EC[F]{\RAISE\
            \VAL}}\ \EXCEPT\ \EXPR} \ExprTrans \EC{\EXPR\ \VAL} }
    %
    % \inferrule{}{ \EC{\MATCH\ (\VAL_1, \VAL_2) \WITH\ (x_1,
    %     x_2)\to\EXPR \mid \dots} \ExprTrans \EC{\EXPR[\VAL_1,
    %     \VAL_2/x_1, x_2]} }
    % \inferrule{}{ \EC{\MATCH\ \NIL\ \WITH\ \NIL\to\EXPR \mid \dots}
    %   \ExprTrans \EC{\EXPR} }
    % \inferrule{}{ \EC{\MATCH\ (\CONS\ \VAL_1\ \VAL_2)\ \WITH\ (\CONS\
    %     x_1\ x_2)\to\EXPR \mid \dots} \ExprTrans
    %   \EC{\EXPR[\VAL_1,\VAL_2/x_1, x_2]} }
    % \inferrule{}{ \EC{\MATCH\ \NONE\ \WITH\ \NONE\to\EXPR \mid \dots}
    %   \ExprTrans \EC{\EXPR} }
    % \inferrule{}{ \EC{\MATCH\ (\SOME\ \VAL)\ \WITH\ (\SOME\ x)\to\EXPR
    %     \mid \dots} \ExprTrans \EC{\EXPR[\VAL/x]} }
    % \inferrule{}{ \EC{\MATCH\ (\LEFT\ \VAL)\ \WITH\ (\LEFT\ x)\to\EXPR
    %     \mid \dots} \ExprTrans \EC{\EXPR[\VAL/x]} }
    % \inferrule{}{ \EC{\MATCH\ (\RIGHT\ \VAL)\ \WITH\ (\RIGHT\
    %     x)\to\EXPR \mid \dots} \ExprTrans \EC{\EXPR[\VAL/x]} }
  \end{mathpar}
  \caption{Select expression reduction rules (pattern matching omitted)}
  \label{fig:expression-reduction}
\end{figure}
The internal transitions of a node are just evaluation of expressions.
\begin{mathpar}
  \inferrule[Node-Eval]
  {
    \EXPR \ExprTrans \EXPR'
  }{
    [\EC\EXPR :: \EXPRS, \ACCOUNTS] \NodeTrans{}
    [\EC{\EXPR'} :: \EXPRS, \ACCOUNTS]
  }
\end{mathpar}
The remaining transitions affect a local node in the context of the
blockchain. To this end, any local node may be selected.
\begin{mathpar}
  \inferrule[Config-System]{
    \NODE\|\BLOCKCHAIN \SystemTrans \NODE'\|\BLOCKCHAIN'
}{
    \BLOCKCHAIN[\NODE :: \overline{\NODE}] \SystemTrans
    \BLOCKCHAIN'[\NODE' :: \overline{\NODE}]
  }

  \inferrule[Config-Node]
  {\NODE \NodeTrans \NODE'}
  { {\BLOCKCHAIN[\NODE :: \overline\NODE]}
    \SystemTrans
    {\BLOCKCHAIN[\NODE' :: \overline\NODE]}}

  \inferrule[Config-Block]
  {\BLOCKCHAIN \BlockTrans \BLOCKCHAIN'}
  { \BLOCKCHAIN[{\overline\NODE}]
    \SystemTrans
    \BLOCKCHAIN'[{\overline\NODE}]}
\end{mathpar}


\begin{figure}[tp]
\begin{mathpar}
  \inferrule[Node-Inject]{
    \Angle{\PAK,\PUK} \in \ACCOUNTS \\
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUB (\MANAGERS, \PUK') \\
    \CHECKGAS (\PUK, \PUK', \NTEZ, \MTEZ) \\
    %\OPH = \GENERATEOPH (\PUK, \PUK','', \NTEZ, \MTEZ, \TIME) \\
    \OPH = \GENERATEOPH (\OP, \TIME) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ    
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] } \SystemTrans \\
   { [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
     [ \OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     ::\PENDING,
     \UPDATECOU(\MANAGERS, \PUK, \TRUE),
     \CONTRACTORS,
     \TIME]
   }
 }

  \inferrule[Node-Reject]{
    \NEG\ \CHECKBAL (\BLOCKCHAIN.\MANAGERS, \OP.\PUK, \OP.\NTEZ, \OP.\MTEZ) \\
    }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
      } \SystemTrans
    { [\EC{\RAISE\ \ERRBAL} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
  }

  \inferrule[Block-Accept]{
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \TIME - \hat\TIME \le 60
  }{
    { 
      [\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSPENDING}
     ::\PENDING, \MANAGERS,
      \CONTRACTORS, \TIME]}
    \BlockTrans  \\
    { 
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, 
      \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ),
      \CONTRACTORS, \TIME +1]}
  }

    \inferrule[Block-Timeout]{
    % \OP = \TRANSFER[\STRING]\NTEZ\PUK\ADDR\MTEZ \\
    \TIME-\hat\TIME > 60
  }{ 
    {[\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSPENDING}
     ::\PENDING, \MANAGERS,
      \CONTRACTORS, \TIME]}
    \BlockTrans \\
    { 
      [\OPH \mapsto \Angle{\OP, \hat \TIME, \STATUSTIMEOUT}
     :: \PENDING, \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
      \CONTRACTORS, \TIME]}
  }
\end{mathpar}
  
  \caption{Lifecycle transitions of a transaction}
  \label{fig:lifecycle-transaction}
\end{figure}
Figure~\ref{fig:lifecycle-transaction} shows the transitions to start
and finalize a transfer transaction.
\TirName{Node-Inject} affects a local node and the blockchain. It
nondeterminstically selects a program that wants to do a transfer
operation. It
checks whether the sender of the transfer is a valid local account, whether
the balance is sufficient to pay the fee and the transferred amount,
whether there is an active transition for this sender (chkCount),
whether the receiver's address is valid, and whether the fee is
sufficient. If these conditions are fulfilled, the transition forges
an operation hash and returns it to the local node. 
The pending operation enters the pool and the sender's counter is set
to indicate an ongoing transition.

We give just one example \TirName{Node-Reject} of the numerous
transitions that cover the cases where one of the 
premises of \TirName{Node-Inject} is not fulfilled. Each of them
raises an exception that describes which condition was violated.

Acceptance or rejection of a pending operation happens on the
blockchain independent of any local node. In our model, these
transitions are nondeterministic so that acceptance can happen any
time in the next 60 cycles \TirName{Block-Accept}. Afterwards, a
pending operation can only time out \TirName{Block-Timeout}.
If the transaction is accepted, then the sender's counter is reset,
the balances of sender and receiver are adjusted (updSucc), and the
time stamp increases.

Whereas \TirName{Node-Inject} and \TirName{Block-Accept} are
particular to the transfer operation, the timeout transition applies
to all operations. It just changes the state of the operation and
resets the sender's counter, thus rolling back the transaction.

% \begin{itemize}
% \item library call \texttt{call\_contract} with \texttt{confirmations:None} corresponds to
%   \begin{enumerate}
%   \item{} first \TirName{Node-Op'}, \TirName{Node-Inject'}
%   \item{} first \TirName{Node-Op'}, \TirName{Node-Reject(balance,count,pubkey,fee)}
%   \end{enumerate}
% \item afterwards must check the status to find whether the
%   transfer is still pending or \TirName{Block-Accept''} or
%   \TirName{Block-Timeout''} has happened.
% \item no further transfer is possible before the status is resolved to
%   accept or timeout.
% \end{itemize}

\subsection{Cast Reductions}
\label{sec:special-reductions}

\begin{figure}[tp]
\begin{mathpar}
  \inferrule[Contract-Yes]{
    \JTypeCode\CODE{\TPAIR\ \TYPE\ \TYPEU} \\
    \BLOCKCHAIN.\CONTRACTORS (\PUH) =  \Angle{\CODE, \tilde\TIME, \NTEZ', \STRING'}
    %
    }{
    { [\EC{\CAST\PUH\TPUH{\TCONTRACT\ \TYPE}}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\PUH} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }

  % \inferrule[Contract-Implicit?]{
  %   \PUK \in \DOM(\BLOCKCHAIN.\MANAGERS)
  %   %
  %   }{
  %   { [\EC{\CONTRACT\ \TUNIT\ \PUK}  :: \EXPRS, \ACCOUNTS] \|
  %     \BLOCKCHAIN
  %   }
  %   \SystemTrans
  %   { [\EC{\SOME\ \PUK} :: \EXPRS, \ACCOUNTS] \|
  %     \BLOCKCHAIN
  %  }
  % }
  %
  \inferrule[Contract-No]{
    % \ADDR \in \DOM (\BLOCKCHAIN.\MANAGERS) \Rightarrow \TYPE\ne\TUNIT \\
    \BLOCKCHAIN.\CONTRACTORS (\PUH) = \Angle{\CODE, \tilde\TIME,
      \NTEZ', \STRING'} \Rightarrow {}
        \JTypeCode\CODE{\TPAIR\ \TYPE'\ \TYPEU} \wedge \TYPE \ne \TYPE' \\
    }{
    { [\EC{\CAST\PUH\TPUH{\TCONTRACT\ \TYPE}}  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\RAISE\ \ERRPRG} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }
\end{mathpar}
  \caption{Cast reductions (excerpt)}
  \label{fig:cast-reductions}
\end{figure}
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule[Block-Originate]{
      \Angle{\PAK,\PUK} \in \ACCOUNTS \\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
      \CHECKCOU (\MANAGERS, \PUK) \\
      \CHECKPRG (\CODE) \\
      \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ)  \\
      \CHECKINIT (\CODE, \STRING) \\
      % \OPH = \GENERATEOPH(\PUK, \CODE, \STRING, \NTEZ, \MTEZ, \TIME)
      % \\
      \OPH = \GENERATEOPH(\OP, \TIME) \\
      \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ }{ [\EC\OP :: \EXPRS,
      \ACCOUNTS
      ] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \to \\
      [\EC{\OPH} :: \EXPRS, \ACCOUNTS] \| [\OPH \mapsto \Angle{\OP,
        \TIME, \STATUSPENDING} ::\PENDING,
      \UPDATECOU(\MANAGERS,\PUK,\TRUE), \CONTRACTORS, \TIME] }

  \inferrule[Block-Accept]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \PUH = \GENERATEHASH(\CODE, \TIME) \\
    \TIME-\hat\TIME  \le 60
  }{
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING} :: \PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    \BlockTrans \\
     [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, \UPDATESUCC
      (\MANAGERS, \PUK, \NTEZ, \MTEZ),\\ \PUH \mapsto  \Angle{\CODE, \TIME, \NTEZ, \STRING} :: \CONTRACTORS, \TIME+1]
  }

    \inferrule[Block-Accept-Query]{
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
    \PENDING (\OPH) =  \Angle{\OP,
      \hat\TIME, \STATUSINCLUDING\ \tilde\TIME} \\
    \PUH = \GENERATEHASH (\CODE, \tilde\TIME)
    % \CONTRACTORS (\PUH) =  \Angle{\CODE, \tilde\TIME, \NTEZ', \STRING'}
  }{
      [\EC{\GETCONTRACT\ \OPH}  :: \EXPRS, \ACCOUNTS] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
    \SystemTrans 
     [\EC{ \PUH}  :: \EXPRS, \ACCOUNTS] \|  [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]
  }
\end{mathpar}
  \caption{Smart contract origination}
  \label{fig:contract-origination}
\end{figure}
\begin{figure}[tp]
  \begin{mathpar}
    \inferrule[Query-Balance-Implicit]{
      % \BLOCKCHAIN =
      % [\PENDING, \PUK \mapsto \Angle{\BAL, \COU} :: \MANAGERS,
      % \CONTRACTORS, \TIME]
      \BLOCKCHAIN.\MANAGERS (\PUK) = \Angle{\BAL,\COU}
    }{[\EC{\GETBALANCE\PUK} :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN
      \SystemTrans\ [\EC{\BAL} ::\EXPRS, \ACCOUNTS] \| \BLOCKCHAIN}

    \inferrule[Query-Balance-Fail]{ \PUK \notin \DOM
      (\BLOCKCHAIN.\MANAGERS) \ }{[\EC{\GETBALANCE\PUK} :: \EXPRS,
      \ACCOUNTS] \| \BLOCKCHAIN \SystemTrans {[\EC{\RAISE\ \ERRPUK}
        ::\EXPRS, \ACCOUNTS] \| \BLOCKCHAIN}}
  \end{mathpar}
  \caption{Example queries}
  \label{fig:example-queries}
\end{figure}


Figure~\ref{fig:cast-reductions} contains the most interesting
example of cast reductions, from a public hash to a typed
contract. These reductions force the local node to obtain information
from the blockchain. The cast succeeds \TirName{Contract-Yes} on \PUH, if there is a
contractor for \PUH\ such that the stored code has the parameter type
expected by the cast. The cast fails \TirName{Contract-No}, if \PUH\
is invalid or if the types do not match.




\subsection{Smart Contracts}
\label{sec:smart-contracts}

The invocation of smart contracts is similar to a transfer, so we
elide the details. Figure~\ref{fig:contract-origination} contains the
transition \TirName{Block-Originate} to originate a smart contract. The basic scheme is similar
to the transfer. The preconditions for the operation are checked, but
there are extra preconditions for origination:  the program must be
well-formed and typed, the initial storage value must match its
type. The operation ends up in the pool in pending status.

Acceptance of origination is slightly different as for transfers as
shown in \TirName{Block-Accept}. We calculate the public hash \PUH\ of the
contract from the code and the current time stamp and create a new
contractor at that address.  

We obtain the handle of the contract through a query, once the
contract is accepted on the blockchain in
\TirName{Block-Accept-Query}. The query's argument is the operation
hash, which is used to obtain the code and the time stamp of its
acceptance. From this information, we can re-calculate the public
hash. 

\subsection{Queries}
\label{sec:queries}


We conclude with two example transitions for a simple query in
Figure~\ref{fig:example-queries}. To obtain the balance of an implicit
account \PUK, we obtain the account info from the manager and extract
the balance (\TirName{Query-Balance-Implicit}). If the account is
unknown, then we raise an exception
(\TirName{Query-Balance-Fail}). Other queries are implemented analogously.

\section{Properties}
\label{sec:properties}

\subsection{Properties of blockchain state transitions}

Running a program that starts with valid references to accounts,
operations, and contracts does not get corrupted by a transition.
\begin{proposition}
  The following property is preserved by a step on a well-formed
  configuration $ [\EXPRS, \ACCOUNTS] \| \BLOCKCHAIN$:
  \begin{itemize}
  \item for all $\OPH$ in $\EXPRS$, $\OPH \in \DOM (\BLOCKCHAIN.\PENDING)$,
  \item for all $\PUK$ in $\EXPRS$, $\PUK \in \DOM (\BLOCKCHAIN.\MANAGERS)$,
  \item for all $\PUH$ in $\EXPRS$, $\PUH \in \DOM (\BLOCKCHAIN.\CONTRACTORS)$.
  \end{itemize}
\end{proposition}

\begin{proposition}
If $[\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \BlockTrans{}
[\PENDING', \MANAGERS', \CONTRACTORS', \TIME']$, then
\begin{enumerate}
\item $\TIME \le \TIME'$
\item\label{item:1} $\DOM (\PENDING) \subseteq \DOM(\PENDING')$
\item invariant for the pool: if  $\PENDING (\OPH) = \Angle{\OP,
    \hat\TIME, \STATUS}$, then $\OPH = \GENERATEOPH (\OP,
  \hat\TIME)$. 
\item for all $\OPH \in \DOM(P)$, if 
  $\PENDING (\OPH) = \Angle{\OP,  \hat\TIME, \STATUS}$, then either
  \begin{itemize}
  \item     $\PENDING'    (\OPH) = \PENDING (\OPH)$; or
  \item $\STATUS  = \STATUSPENDING$ and $\PENDING' (\OPH) =
    \Angle{\OP, \hat\TIME, \STATUSTIMEOUT}$; or
  \item  $\STATUS  = \STATUSPENDING$, $\TIME - \hat\TIME
    \le 60 $, and
    $\PENDING' (\OPH) =       \Angle{\OP, \hat\TIME, \STATUSINCLUDED\
      \TIME}$.
  \end{itemize}
 \item\label{item:2} for all $\OPH \in \DOM(P)$ and $\PENDING (\OPH) = \Angle{\OP,  \hat\TIME, \STATUSPENDING}$, 
    \begin{itemize}
    	\item  if $\MANAGERS(\OP.\PUK) =  \Angle{\BAL, \COU}$ then  
  $\COU.b = \TRUE$.
    \end{itemize}
 \item\label{item:3} $ \DOM (\MANAGERS) \subseteq \DOM (\MANAGERS')$
 \item\label{item:4} for all $\PUK \in \DOM (\MANAGERS)$\\
   if $\MANAGERS (\PUK) =
   \Angle{\BAL, \COU}$, 
   then $\MANAGERS' (\PUK) =
   \Angle{\BAL', \COU'}$ and
   \begin{itemize}
   \item if $\COU.b=\TRUE$ and $\COU'.b=\FALSE$, then $\COU.n' \in \{
     \COU.n,  \COU.n+1\}$,
   \item otherwise $\COU.n = \COU'.n$
   \item If $\COU.n = \COU'.n$, then $\BAL = \BAL'$.
   % \item if $\COU.b= \FALSE$, then $n' = n$
   % \item if $\COU.b= \TRUE$ and $b'=\TRUE$, then $n' =n$
   \end{itemize}

 \item\label{item:5} $ \DOM (\CONTRACTORS) \subseteq \DOM (\CONTRACTORS')$
   \begin{itemize}
   \item for all $\PUH \in \DOM (\CONTRACTORS)$,
     $\CONTRACTORS (\PUH).\CODE = \CONTRACTORS' (\PUH).\CODE$
   \end{itemize}
 \item\label{item:6} invariant for contractors:
   for all $\PUH \in \DOM (\CONTRACTORS)$,
   $\CONTRACTORS (\PUH) = \Angle{ \CODE, \tilde\TIME, \BAL, \STORAGE}$
   implies that $\PUH = \GENERATEHASH (\CODE, \tilde\TIME)$.
\end{enumerate}
\end{proposition}
Establishing these properties relies on the preimage resistance of the
various hash functions used to calculate operation hashes and public
hashes. Items~\ref{item:1}--\ref{item:2} describe an invariant and the lifecycle of
operations. Items~\ref{item:3} and \ref{item:4} describe the lifecycle
of a transfer and items~\ref{item:5} and~\ref{item:6} describe
invariants for contractors. The invariants establish the
self-verifying property common of blockchain entities.

\subsection{Typing related properties}

To describe contracts we associate each public hash with a pair of
types, the parameter type and the storage type.
\begin{align*}
  \Delta & ::= \EmptyEnv \mid \PUH: \TPAIR\ \TYPE\ \TYPEU, \Delta
\end{align*}

Define $ \Delta \vdash \CONTRACTORS$ by
\begin{itemize}
\item $\DOM (\Delta) = \DOM (\CONTRACTORS)$
\item $\JTypeCode{\CONTRACTORS (\PUH).\CODE} {\Delta (\PUH)}$
\item $\JTypeValue{\CONTRACTORS (\PUH).\STORAGE}{ \TYPE_s}$ where
  $\Delta (\PUH) = \TPAIR\ \TYPE_p\ \TYPE_s$. 
\end{itemize}

Preservation

If $[\PENDING, \MANAGERS, \CONTRACTORS, \TIME] \BlockTrans{}
[\PENDING', \MANAGERS', \CONTRACTORS', \TIME']$
and $\Delta \vdash \CONTRACTORS$, \\
then
there is some $\Delta' \supseteq \Delta$ such that $\Delta' \vdash
\CONTRACTORS'$. 

Consider a blockchain state  $[\PENDING, \MANAGERS, \CONTRACTORS,
\TIME]$ where $\Delta \vdash \CONTRACTORS$.

For all $\OPH\in\DOM (\PENDING)$,
if  $\PENDING (\OPH) =  \Angle{\OP, \hat\TIME, \STATUS}$
\begin{itemize}
\item if $\OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ$, then
\begin{itemize}
  \item
  $\PUK, \PUK' \in \DOM (\MANAGERS)$
\end{itemize}
\item if $\OP = \TRANSFER[\PARAMETER]\NTEZ\PUK\PUH\MTEZ$, then
  \begin{itemize}
  \item $\PUK \in \DOM (\MANAGERS)$ and $\PUH\in\DOM (\CONTRACTORS)$
  \item $\PARAMETER : \TYPE_p$ where $\Delta (\PUH)  =\TPAIR\ \TYPE_p\ \TYPE_s$. 
  \end{itemize}
  
\item if $\OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ$ and $\STATUS =
  \STATUSINCLUDED\ \TIME'$, then
   \begin{itemize}
   \item $\PUK \in \DOM (\MANAGERS)$
  \item $\CODE : \TPAIR\ \TYPE_p\ \TYPE_s$
  \item $\STRING : \TYPE_s$
  \item if $\STATUS =
  \STATUSINCLUDED\ \TIME'$, then $\PUH =\GENERATEHASH (\CODE, \hat\TIME) \in \DOM (\CONTRACTORS)$ and $\Delta (\PUH)  =\TPAIR\ \TYPE_p\ \TYPE_s$ (or $\CONTRACTORS(\PUH).\CODE = \CODE$).

  \end{itemize}
  
 \item if $st = \STATUSPENDING$ and $\MANAGERS(\PUK) = \Angle{\BAL,
     \COU}$, then $\BAL \ge \NTEZ +  \MTEZ$ 
\end{itemize}


\section{Related Work}
\label{sec:related work}
The inability to access external data sources limits the potential of smart contracts. Oracles \cite{oracle-patterns, call-action-oracle, oracles-study} can help overcome this limitation by providing a bridge between the outside sources and the blockchain network. A blockchain oracle is used to provide external data to smart contracts. Several researches have been done to provide oracle solutions for blockchain. The work in \cite{blockchain-oracles} proposes a framework to explain blockchain oracles and various key aspects of oracles. This framework aims to provide developers with a guide for incorporating oracles into blockchain-based applications. Practically, the decentralized oracle network Chainlink \cite{chainlink-whitepaper} is being developed to provide reliable, tamper-proof input for smart contracts on any blockchain. For a specific application, a system called Town Crier \cite{town-crier} provides an authenticated data feed, sourced from HTTPS-enabled data websites, for smart contracts on Ethereum. The authors in \cite{oracle-real-value} construct an oracle that can estimate the value of a real quantity, such as $R$. 
For application to prediction markets, there are Truthcoin system \cite{truthcoin-whitepaper} and Astraea, a trustless decentralized oracle \cite{astraea}.  

The main problems with using a blockchain oracle are the untrusted data provided maliciously or inaccurately \cite{trustworthy}. The researchers in \cite{reliable-oracle} propose an oracle equipped with verification and disputation mechanisms. Similarly, researchers in \cite{reliablity-oracles} provide a framework for performing reliability analysis of various blockchain oracle platforms. Closely following our work, the authors in \cite{interact-coq} present a model-executable specification of smart-contract execution in Coq. Their formalizations target Ethereum and Tezos. 

\newpage{}

\bibliographystyle{splncs04}
\bibliography{bio}

\newpage{}
\appendix

\section{Unused}
\label{sec:unused}

\subsection{An Implicit Account Transfer}


\begin{mathpar}
  \inferrule[rejected of public key]{
    \NEG\ \CHECKPUB (\BLOCKCHAIN.\MANAGERS, \PUK') \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    } \SystemTrans
   { [\EC{\RAISE\ \ERRPUK} :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
    }
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of fee]{
    \NEG\ \CHECKGAS (\BLOCKCHAIN.\MANAGERS, \PUK,\PUK',\NTEZ, \MTEZ) \\
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
  }{
    { [\EC\OP :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
     } \SystemTrans
    { [\EC{\RAISE\ \ERRFEE} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[rejected of counter]{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \OP.\PUK) \\
    }{
    { [\EC\OP  :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
    }
    \SystemTrans
    { [\EC{\RAISE\ \ERRCOUNT} :: \EXPRS, \ACCOUNTS] \|
      \BLOCKCHAIN
   }
  }
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse 
Rule 6 [included]:
\begin{mathpar}
  \inferrule[Block-Accept]{
    \OP = \TRANSFER\NTEZ\PUK{\PUK'}\MTEZ \\
    \TIME'-\TIME < 60
  }{
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans  \\
    {[\PENDING, \Angle{\OP,\OPH, \TIME,\TIME'} :: \ACCEPTED,
      \UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ),
      \CONTRACTORS, \TIME'+1]}
  }
\end{mathpar}
Rule 7 [timeout]: (applies to both, implicit transfers and contract invocations)
\begin{mathpar}
  \inferrule[Block-Timeout]{
    \OP = \TRANSFER[\STRING]\NTEZ\PUK\ADDR\MTEZ \\
    \TIME'-\TIME \ge 60
  }{
    {[\Angle{\OP,\OPH, \TIME} :: \PENDING, \ACCEPTED, \MANAGERS,
      \CONTRACTORS, \TIME']}
    \BlockTrans
    {[\PENDING, \ACCEPTED, \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
      \CONTRACTORS, \TIME']}
  }
\end{mathpar}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Contracts}
\label{sec:contracts}

\begin{mathpar}
  \inferrule[rejected of code]{
    \NEG\ \CHECKPRG (\CODE) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRPRG] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}

\iffalse 
Rule 3 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \PUK) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRCOUNT] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}


\begin{mathpar}
  \inferrule[rejected of balance]{
    \NEG\ \CHECKBAL (\BLOCKCHAIN.\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRBAL] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}
\fi

\begin{mathpar}
  \inferrule[rejected of fee]{
    \NEG\ \CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRFEE] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of initial storage]{
    \NEG\ \CHECKINIT (\CODE, \INIT) \\
    \OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ
  }{
    [\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN \to 
    [\EXPRS[\RAISE\ \ERRINIT] :: \EXPRS, \ACCOUNTS] \|
     \BLOCKCHAIN
  }
\end{mathpar}


% \begin{mathpar}
%   \inferrule[Block-Timeout]{
%     %\OP = \ORIGINATE\NTEZ\PUK\CODE\STRING\MTEZ \\
%     \TIME-\hat\TIME > 60
% }{
%       [ \OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING}
%      ::\PENDING, \MANAGERS,
%       \CONTRACTORS, \TIME]  
%       \BlockTrans \\    
%       [ \OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSTIMEOUT}
%      :: \PENDING, \UPDATECOU(\MANAGERS, \OP.\PUK, \FALSE),
%       \CONTRACTORS, \TIME] 
%   }

% \end{mathpar}
~\\
~\\
B. \textbf{Transfer}

\begin{mathpar}
  \inferrule[Block-Call]{
    \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\ 
    \CHECKCOU (\MANAGERS, \PUK) \\
    \CHECKPUH (\CONTRACTORS, \PUH) \\
    \CHECKARG (\CONTRACTORS, \PUH, \PARAMETER) \\
    \CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ) \\
%    \OPH = \GENERATEOPH (\PUK,\PUH, \PARAMETER,\NTEZ, \MTEZ, \TIME) \\
    \OPH = \GENERATEOPH (\OP, \TIME) \\
    \OP =  \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\    
  }{ [\EC\OP  :: \EXPRS, \ACCOUNTS,
      ] \| [\PENDING, \MANAGERS, \CONTRACTORS, \TIME]     
    \SystemTrans \\
    [\EC{\OPH}  :: \EXPRS, \ACCOUNTS] \|
      [\OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING}
     :: \PENDING, \UPDATECOU(\MANAGERS, \PUK, \TRUE), \CONTRACTORS, \TIME]}
\end{mathpar}

\iffalse 
Rule 2 [rejected of counter]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKCOU (\BLOCKCHAIN.\MANAGERS, \PUK) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EC\OP :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN      
    \SystemTrans
   [\EC[\RAISE\ \ERRCOUNT] :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN }
\end{mathpar}
~\\
~\\
Rule 3 [rejected of balance]:
\begin{mathpar}
  \inferrule{
    \NEG\ \CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ \\
  }{[\EXPRS, \ACCOUNTS, (\EC{},\OP) :: \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]      
    \SystemTrans
    [\EXPRS, \ACCOUNTS, \OPERATIONS] \|
      [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]}
\end{mathpar}
\fi


\begin{mathpar}
  \inferrule[rejected of public hash]{
    \NEG\ \CHECKPUH (\BLOCKCHAIN.\CONTRACTORS, \PUH) \\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ
  }{[\EC\OP  :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN    
    \SystemTrans
    [\EXPRS[\RAISE\ \ERRPUH], \ACCOUNTS] \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of argument]{
    \NEG\ \CHECKARG (\BLOCKCHAIN.\CONTRACTORS, \PUH, \PARAMETER)\\
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ
  }{[\EC\OP  :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN    
    \SystemTrans
    [\EXPRS[\RAISE\ \ERRARG], \ACCOUNTS] \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[rejected of fee]{
    \NEG\ \CHECKGAS (\BLOCKCHAIN.\CONTRACTORS, \PUH, \PARAMETER, \MTEZ) \\ \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK{\PUH}\MTEZ 
  }{[\EC\OP  :: \EXPRS, \ACCOUNTS] \| \BLOCKCHAIN    
    \SystemTrans
    [\EXPRS[\RAISE\ \ERRFEE], \ACCOUNTS] \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[block Accept]{
    \OP = \TRANSFER[\PARAMETER]\NTEZ\PUK\PUH\MTEZ \\
    \TIME-\hat\TIME \le 60
  }{
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSPENDING} :: \PENDING, \MANAGERS,
    \CONTRACTORS, \TIME]
    \BlockTrans \\
    [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME} :: \PENDING, 
    \UPDATESUCC (\MANAGERS, \PUK, '', \NTEZ, \MTEZ), \\
    \UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER),
    \TIME+1]
  }
\end{mathpar}

\subsection{Queries}
\label{sec:queries-1}

\begin{mathpar}
  \inferrule[counter]{
    \BLOCKSYSTEM = 
      [\PENDING, \PUK \mapsto \Angle{\BAL, \COU} :: \MANAGERS, \CONTRACTORS, \TIME]
  }{[\EC{\GETCOUNTER\PUK} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\COU} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}


\begin{mathpar}
\inferrule[balance of smart contract]{
    \BLOCKSYSTEM = 
      [\PENDING,  \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETBALANCE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\BAL} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[storage]{
    \BLOCKSYSTEM = 
      [\PENDING, \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETSTORAGE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\STORAGE} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[code]{
    \BLOCKSYSTEM = 
      [\PENDING,  \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETCODE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\CODE} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[type]{
    \BLOCKSYSTEM = 
      [\PENDING,  \MANAGERS, \PUH \mapsto \Angle{\CODE, \TIME, \BAL, \STORAGE} :: \CONTRACTORS, \TIME]
  }{[\EC{\GETTYPE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\Delta (\PUH)} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}



\begin{mathpar}
  \inferrule[fail of a query for an implicit account]{
    \NEG\ \CHECKPUB (\BLOCKCHAIN.\MANAGERS, \PUK) \
  }{[\EC{\GETBALANCE\PUK/\GETCOUNTER\PUK} :: \EXPRS, \ACCOUNTS]  \| 
  \BLOCKCHAIN 
    \SystemTrans {[\EC{\RAISE\ \ERRPUK} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}}
\end{mathpar}

\begin{mathpar}
  \inferrule[fail of a query for a smart contract]{
    \NEG\ \CHECKPUH (\BLOCKCHAIN.\CONTRACTORS, \PUH) 
  }{[\EC{\GETBALANCE\PUH/\GETSTORAGE\PUH/\GETCODE\PUH/\GETTYPE\PUH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\\ [\EC{\RAISE\ \ERRPUH} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[status-pending]{
    \BLOCKSYSTEM = 
      [\OPH \mapsto \Angle{\OP, \TIME, \STATUSPENDING} :: \PENDING,  \CONTRACTORS, \TIME]
  }{[\EC{\GETSTATUS\OPH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\STATUSPENDING} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[status-including]{
    \BLOCKSYSTEM = 
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSINCLUDING\ \TIME'} :: \PENDING,  \CONTRACTORS, \TIME] \\
    $n$ \ = \TIME\ - \TIME'
  }{[\EC{\GETSTATUS\OPH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\STATUSINCLUDING($n$)} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\begin{mathpar}
  \inferrule[status-timeout]{ 
   \BLOCKSYSTEM = 
      [\OPH \mapsto \Angle{\OP, \hat\TIME, \STATUSTIMEOUT} :: \PENDING, \CONTRACTORS, \TIME]
  }{[\EC{\GETSTATUS\OPH} :: \EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN
    \SystemTrans\ [\EC{\STATUSTIMEOUT} ::\EXPRS, \ACCOUNTS]  \| \BLOCKCHAIN}
\end{mathpar}

\subsection{Functions}
\label{sec:functions}

\begin{enumerate}
    \item Function $\CHECKPUB(\MANAGERS, \PUK)$ checks whether a public key $\PUK$ exists in $\MANAGERS$.
    \begin{itemize}
    \item[] $\CHECKPUB(\MANAGERS, \PUK)$ = $\TRUE$ iff $\PUK \in \DOM(\MANAGERS)$
    \end{itemize}
    \item Function $\CHECKPUH(\CONTRACTORS, \PUH)$ checks whether a public hash $\PUH$ exists in $\CONTRACTORS$.
     \begin{itemize}
    \item[] $\CHECKPUH(\CONTRACTORS, \PUH)$ = $\TRUE$ iff $\PUH \in \DOM(\CONTRACTORS)$
    \end{itemize}
    \item Function $\CHECKBAL (\MANAGERS, \PUK, \NTEZ, \MTEZ)$ checks whether the balance of the account that associates with the public key $\PUK$ is greater or equal to $\NTEZ$ plus $\MTEZ$.
    \begin{itemize}
    \item[] $\MANAGERS(\PUK)$ = $\Angle{\BAL, \COU}$ and $\BAL \ge \NTEZ + \MTEZ$
    \end{itemize}
    \item Function $\CHECKCOU (\MANAGERS, \PUK)$ checks whether the current counter of an account that associates with the public key $\PUK$ is unlocked (its flag is False).
    \begin{itemize}
    \item[] $\MANAGERS(\PUK)$ = $\Angle{\BAL, \COU}$ and $\COU.b = \FALSE$
    \end{itemize}
   % \item Function \CHECKEXIST (\OPH, \PENDING, \ACCEPTED)\ checks whether an operation  \OPH\ exists in either \PENDING\ or \ACCEPTED.
    \item Function $\UPDATESUCC(\MANAGERS, \PUK, \PUK', \NTEZ, \MTEZ)$ updates the balance and the counter of the account that associates with the public key $\PUK$ and the balance of the account that associates with the public key $\PUK'$, where
    \begin{itemize}
        \item[]  $\PUK \mapsto \Angle{\BAL, (\hat\NTEZ, \TRUE)}$ $\Rightarrow$ $ \PUK \mapsto \Angle{\BAL - \NTEZ - \MTEZ, (\hat\NTEZ + 1, \FALSE)}$     
        \item[] $\PUK' \mapsto \langle  \BAL', \COU' \rangle$ $\Rightarrow$ $\PUK' \mapsto \langle \BAL' + \NTEZ, \COU' \rangle $         
    \end{itemize}
    
    \item Function $\UPDATECOU(\MANAGERS, \PUK, \BOOLEAN)$ updates the counter flag (True $=$ locked, False $=$ unlocked) of the account that associates with the public key $\PUK$, where
    \begin{itemize}
        \item[]  $ \PUK \mapsto \langle \BAL, (\NTEZ, \hat\BOOLEAN) \rangle $ $\Rightarrow$ $\PUK \mapsto \langle \BAL, (\NTEZ, \BOOLEAN) \rangle $ 
    \end{itemize}
    
    \item Function  $\UPDATECONSTR (\CONTRACTORS, \PUH, \NTEZ, \PARAMETER)$ updates the contractor that associates with the public hash $\PUH$, where
    \begin{itemize}
        \item[] $\PUH  \mapsto \langle   \CODE, \TIME, \BAL, \STORAGE, \rangle $ $\Rightarrow$ $\PUH  \mapsto \langle  \BAL + \NTEZ, \CODE, \\ \UPDATESTORAGE(\STORAGE,\CODE,\PARAMETER) \rangle $
    \end{itemize}
    
     \item Function $\UPDATESTORAGE(\STORAGE, \CODE,  \PARAMETER)$ returns the new storage by running the code $\CODE$ on the  current storage  $\STORAGE$ with  the input parameter $\PARAMETER$.
    
    \item Function $\CHECKPRG (\CODE)$ checks whether the code $\CODE$ is well type.
    
    \begin{itemize}
        \item[] $\CHECKPRG (\CODE) = \TRUE$ iff $\CODE : \TPAIR\ \TYPE_p\ \TYPE_s$
    \end{itemize}
    \item Function $\CHECKINIT (\CODE, \INIT)$ checks whether the initil stogare valude is well type with corresponding to the code $\CODE$.
    \begin{itemize}
        \item[] $\CHECKINIT (\CODE, \INIT) = \TRUE$ iff $\CODE : \TPAIR\ \TYPE_p\ \TYPE_s$ and $\STRING : \TYPE_s$
    \end{itemize}
    
    \item Function $\CHECKARG (\CONTRACTORS, \PUH, \PARAMETER)$ checks whether the input parameter  $\PARAMETER$ to the smart contract $\PUH$ in $\CONTRACTORS$ is well type with corresponding to its code.
    \begin{itemize}
        \item[] $\CHECKARG (\CONTRACTORS, \PUH, \PARAMETER) = \TRUE$ iff $\Delta (\PUH) =
  \TPAIR\ \TYPE_p\ \TYPE_s$ and $\PARAMETER : \TYPE_p$
    \end{itemize}
   
   % \item Function \CHECKGAS(\CODE, \INIT, \MTEZ) checks whether the gas that is consumed to run the code \CODE\ for the initial value \INIT\ is less or equal to \MTEZ.
    \item Function  $\CHECKGAS (\MANAGERS, \PUK,\NTEZ, \MTEZ)$/ $\CHECKGAS (\CODE, \INIT, \NTEZ, \MTEZ)$ / $\CHECKGAS (\CONTRACTORS, \PUH, \PARAMETER, \MTEZ)$ check whether the fee that is consumed to emit the opertion is less or equal to the fee \MTEZ. 
    %run the code \CODE\ that associates with the public hash \PUH\ for the paremeter \PARAMETER\ is less or equal to \MTEZ.
    \item Function \GENERATEOPH (\PUK, {\ADDR /\CODE},{\INIT /\PARAMETER}, \NTEZ, \MTEZ,  \TIME) generates an operation hash.

    \item Function \GENERATEHASH (\CODE, \TIME)  generates the public hash of a smart contract.
    \end{enumerate}


    

\end{document}