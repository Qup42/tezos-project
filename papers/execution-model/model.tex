\documentclass[a4paper]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\newtheorem{mydef}{Definition}
\newtheorem{mylemma}{Lemma}
\newtheorem{mytheorem}{Theorem}
\newtheorem{mypro}{Proposition}

\input{macros}

\title{Blockchain System}

\author{}
\institute{}

\date{\today}

\begin{document}
\maketitle


\section{Definitions}
\begin{definition}[Set]
Let $\mathbf{Elt}$ be the set of (concrete) elements. Let $\emptyset$ be an empty set and $\mathbf{e}$ $\in$  $\mathbf{Elt}$. A set of elements is expressed as the following syntax:
\\
$\mathbf{s} :: = \emptyset \mid \mathbf{e} \mid \mathbf{s :: s}$
\end{definition}

\begin{definition}[Account]
An account is a tuple $\langle \ALS, \PAK, \PUK, \PKH \rangle $, where $\ALS$ is the alias of the account, $\PAK$ is its private key, $\PUK$ is its public key and $\PKH$ is its public key hash . 
\end{definition}

\begin{definition}[Contract]
An contract is a tuple $\langle  \ALS, \PUH, \CODE \rangle $, where
$\ALS$ is the alias of the contract, $\PUH$ is its public hash, and
$\CODE$ is the code of the contract. 
\end{definition}

\begin{definition}[Manager]
An manager manages accounts on the blockchain. It is represented by a
tuple $\langle  \PUK, \PKH, \BAL, \COU \rangle $, where  $\PUK$ is the
public key of an account, $\PKH$ is its public key hash, $\BAL$ is its
balance and $\COU$ is its counter whose form is a pair ($\mathbf{n},
\mathbf{b}$), where $\mathbf{n}$ is a nature number and $\mathbf{b}$
is a boolean value.  
\end{definition}

\begin{definition}[Contractor]
  A contractor manages smart contracts on the blockchain. It is
  represented by a tuple
  $\langle \PUH, \BAL, \CODE, \STORAGE \rangle $, where $\PUH$ is the
  public hash of the contract, $\BAL$ is its balance, $\CODE$ is its
  code and $\STORAGE$ is its storage.
\end{definition}

\begin{definition}[Operation]
An operation is expressed as the following syntax:
\\
$\OP$ ::= transfer  $\mathbf{n}$ from $\PKH$ to $\PKH'$ fee $\mathbf{m}$
%\\$\mid$ register key $\PKH$ as delegate fee $\mathbf{m}$ 
%\\$\mid$ set delegate for $\PKH$ to $\PKH'$  fee $\mathbf{m}$ 
%\\$\mid$ withdraw delegate from $\PKH$ fee $\mathbf{m}$ 
\\$\mid$ originate contract $\mathbf{id}$ transferring  $\mathbf{n}$ from $\PKH$ running $\CODE$ init $\mathbf{s}$ fee $\mathbf{m}$
\\$\mid$ transfer $\mathbf{n}$ from $\PKH$ to  $\PUH$ arg $\mathbf{s}$ fee $\mathbf{m}$
\end{definition}

\begin{definition}[Query]
An query is expressed as the following syntax:
\\
$\mathbf{qry}$ ::= get balance for $\PKH / \PUH$
%$\mid$ get delegate for $\PKH$
\\$\mid$ get status for $\OPH$ 
\\$\mid$ get contract storage $\PUH$ 
\\$\mid$ get code for $\PUH$ 
%\\$\mid$ waiting for $\OPH$ to be included in $\mathbf{m}$ blocks
%\\$\mid$ get timestamp
%\\$\mid$ get contracts
%\\$\mid$ show contracts for $\PKH$
\\$\mid$ get public key for $\PKH$
%\\$\mid$ get balance for $\PKH$
\\$\mid$ get counter for $\PKH$

\end{definition}
 \begin{definition}[State of a node]
   The state of a node is a tuple
   $[\mathbf{C}, \mathbf{O}, \mathbf{S}]$ where $\mathbf{C}$ is a set of accounts,
   $\mathbf{O}$ a set of operations, and $\mathbf{S}$  a set of contracts. 
\end{definition}

When an operation is injected in a node, it enters in a pending pool
(and is called a pending operation). 
 \begin{definition}[Pending operation]
A pending operation is a tuple  $\langle  \OP, \OPH, \TIME
\rangle $, where $\OP$ is an operation, $\OPH$ is the operation hash
and $\TIME$ is the time when the operation was injected. 
\end{definition}
After some time, a pending operation may be included in the blockchain as an accepted operation.
%Let \textit{P} is the set of pending operations.
 \begin{definition}[Accepted operation]
An accepted operation  is expressed as a tuple $\langle  \OP, \OPH, \TIME \rangle $, where $\OP$ is an operation, $\OPH$ is the operation hash and $\TIME$ is the time when it is included in the blockchain. 
\end{definition}

\begin{definition}[Blockchain]
  The state of a blockchain is a tuple
  $[\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$ where
  $\PENDING$ is a set of pending operations,  $\ACCEPTED$ is a set
  of accepted operations, $\MANAGERS$ is a set of managers,
  $\CONTRACTORS$ is a set of contractors, and $\TIME$ is the current time of the blockchain. 
\end{definition}

\begin{definition}[Blockchain system]
A blockchain system is a pair
$\mathbf{S} \triangleq\langle \mathbf{M}, \mathbf{B} \rangle$ where
\begin{enumerate}
\item $\mathbf{M} = [C, O, S]$ is the state of a node, and
\item $\mathbf{B} = [P, A, K, T, t]$ is the state of a blockchain 
  such that $\forall c \in C \implies \exists k\in K, k.pkh = c.pkh$
  and $\forall s \in S \implies \exists p \in T, s.puh = p.puh$.
\end{enumerate}
\end{definition}

\section{Rules}
\subsection{Transfers}
~\\
Rule 1 [proposal]:

\begin{equation}{}
\frac{\text{checkAcc($pkh$, C)}}{\parbox{4.2in}{\text{$\langle$[C, O, S], [P, A, K, T, t]$\rangle \rightarrow \langle$[C, (transfer $n$ from $pkh$ to $pkh'$ fee $m$)} ~\\\text{ :: O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 2 [injected]:

\begin{equation}{}
\frac{\text{checkBan(K, $pkh, n, m$) $\wedge$ checkCou(K, $pkh$) $\wedge$ checkPub(K, $pkh'$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: O, S], [P, A, K, T, t]$\rangle \rightarrow$}\\
\text{$\langle$[C, O, S], [($<$ transfer $n$ from $puk$ to $puk'$ fee $m$, generateOph($pkh$, }\\
\text{$pkh', n, m$, t), t $>$) :: P, A, updateCou(K, $pkh$, True), T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 3 [rejected of counter]:

\begin{equation}{}
\frac{\text{$\neg$ checkCou(K, $pkh$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: O, S], [P, A, K, T, t]$\rangle \rightarrow$ }\\
\text{$\langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 4 [rejected of balance]:

\begin{equation}{}
\frac{\text{$\neg$ checkBan(K, $pkh, m, n$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: O, S], [P, A, K, T, t]$\rangle \rightarrow$ }\\
\text{$\langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 5 [rejected of public key]:

\begin{equation}{}
\frac{\text{$\neg$ checkPub(K, $pkh'$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: O, S], [P, A, K, T, t]$\rangle \rightarrow$ }\\
\text{$\langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 6 [included]:
\begin{equation}{}
\frac{}{\parbox{4.2in}{\text{[$<$ transfer $n$ from $puk$ to  $puk'$ fee $m$, oph, t $>$ :: P, A, K, T, t' ] $\rightarrow$ } \\
 \text{[P, $<$ transfer $n$ from  $puk$ to $puk'$ fee $m$, oph, t' $>$ :: A, updateSucc(K, } \\
\text{$puk, puk', n, m$), T, t' + 1]}}} 
\end{equation}
~\\
Rule 7 [timeout]:
\begin{equation}{}
\frac{\text{t' - t $\ge$ 60}}{\parbox{4.2in}{\text{[$<$ transfer $n$ from $puk$ to  $puk'$ fee $m$, oph, t $>$ :: P, A, K, T, t' ] $\rightarrow$} \\
 \hspace*{0cm} \text{[P, A, updateCou(K, $puk$, False), T, t']}}} 
\end{equation}

\subsection{Smart Contracts}
~\\
A. Originate
~\\
~\\
Rule 1 [proposal]:

\begin{equation}{}
\frac{\text{checkAcc($pkh$, C) $\wedge$ checkId($id$, S)}}{\parbox{4.2in}{\text{$\langle$[C, O, S], [P, A, K, T, t]$\rangle \rightarrow \langle$[C, (originate contract ${id}$ transferring} \\
  \text{${n}$ from ${pkh}$} \text{running ${code}$ init ${s}$) :: O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 2 [injected]:

\begin{equation}{}
\frac{\text{checkBan(K, $pkh, n, m$) $\wedge$ checkCou(K, $pkh$) $\wedge$ \text{checkPrg($code, s$)}}}{\parbox{4.2in}{\text{$\langle$[C, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{ :: O, S], [P, A, K, T, t] $\rangle \rightarrow \langle$ [C, O, S],} \text{[(originate contract ${id}$ transferring ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{:: P, A, updateCou(K, $pkh$, True), T, t] $\rangle$}}} 
\end{equation}
~\\
~\\
Rule 3 [rejected of code]:

\begin{equation}{}
\frac{\text{$\neg$ checkPrg($code, s$)}}{\parbox{4.2in}{\text{$\langle$[C, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{:: O, S], [P, A, K, T, t]$\rangle \rightarrow \langle$[C, O, S],} \text{[P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 4 [rejected of counter]:

\begin{equation}{}
\frac{\text{$\neg$ checkCou(K, $pkh$)}}{\parbox{4.2in}{\text{$\langle$[C, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$))} \text{:: O, S], [P, A, K, T, t]$\rangle \rightarrow \langle$ [C, O, S],} \text{[P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 5 [rejected of balance]:

\begin{equation}{}
\frac{\text{$\neg$ checkBan(K, $pkh, n, m$)}}{\parbox{4.2in}{\text{$\langle$[C, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{:: O, S], [P, A, K, T, t]$\rangle \rightarrow \langle$[C, O, S],} \text{[P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 6 [included]:
\begin{equation}{}
\frac{}{\parbox{4.2in}{\text{$\langle$[C, O, S], [$<$ (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running } \\
\text{${code}$ init ${s}$), t $>$ :: P, A, K, T, t' ]$\rangle \rightarrow \langle$[C, O,($< id$, } \\
\text{generateHash($id, code, s$, t'), $code >$ :: S)], [P, $<$ (originate contract ${id}$ } \\
\text{transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$), t' $>$ :: A, updateSucc(K, } \\
\text{$puk, n, m$), ($<$ generateHash($id, code, s$, t'), $n, code$, } \\
 \text{getStorage($code, s$) $>$) :: T), t' + 1]$\rangle$}}} 
\end{equation}
~\\
Rule 7 [timeout]:
\begin{equation}{}
\frac{\text{t' - t $\ge$ 60}}{\parbox{4.2in}{\text{[$<$ (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$) $>$ } \\
\text{:: P, A, K, T, t' ] $\rightarrow$[P, A, updateCou(K, $puk$, False), T, t']}}} 
\end{equation}
~\\
~\\
B. \textbf{Transfer}
\\
~\\
Rule 1 [proposal]:

\begin{equation}{}
\frac{\text{checkAcc($pkh$, C)  }}{\parbox{4.2in}{\text{$\langle$[C, O, S], [P, A, K, T, t]$\rangle \rightarrow \langle$[C, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ }  \\
\text{fee ${m}$) :: O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 2 [injected]:

\begin{equation}{}
\frac{\text{checkBan(K, $pkh, n, m$) $\wedge$ checkCou(K, $pkh$) $\wedge$ checkPuh(T, $puh$)}
\\
\text{ $\wedge$ checkArg(T, $puh, s$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: O, S], [P, A, K, T, t]$\rangle$}\\
\text{$\rightarrow$  $\langle$[C, O, S], [($<$ (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$), }\\
 \text{generateOph($pkh, puh, s, n, m$, t), t $>$) :: P, A, updateCou(K, $pkh$, True), }\\
\text{T, t] $\rangle$}}} 
\end{equation}
~\\
~\\
Rule 3 [rejected of counter]:

\begin{equation}{}
\frac{\text{$\neg$ checkCou(K, $pkh$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: O, S], [P, A, K, T, t]$\rangle$  }\\
\text{$\rightarrow \langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 4 [rejected of balance]:

\begin{equation}{}
\frac{\text{$\neg$ checkBan(K, $pkh, n, m$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: O, S], [P, A, K, T, t]$\rangle$ }\\
\text{$\rightarrow \langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 5 [rejected of public hash]:

\begin{equation}{}
\frac{\text{$\neg$ checkPuh(T, $puh$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: O, S], [P, A, K, T, t]$\rangle$ }\\
\text{$\rightarrow \langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 6 [rejected of argument]:

\begin{equation}{}
\frac{\text{$\neg$ checkArg(T, $puh, s$)}}{\parbox{4.2in}{\text{$\langle$[C, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: O, S], [P, A, K, T, t]$\rangle$}\\
\text{$\rightarrow \langle$[C, O, S], [P, A, K, T, t]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 7 [included]:

\begin{equation}
\frac{}{
  \begin{array}{l}
\text{[$<$ transfer $n$ from $puk$ to  $puh$ fee $m$, oph, t $>$ :: P, A, K, T, t' ] $\rightarrow$ } \\
\text{[P, $<$ (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$), oph, t' $>$ :: A, } \\
\text{updateSucc(K, puk, '', $n, m$), updateConstr(T, $puh, n$,
  $s$), $t' + 1$]}
  \end{array}
}\label{eq:1}
\end{equation}
~\\
Rule 8 [timeout]:
\begin{equation}{}
\frac{\text{t' - t $\ge$ 60}}{\parbox{4.2in}{\text{[transfer $n$ from $puk$ to  $puh$ fee $m$, t $>$ :: P, A, K, T, t' ] $\rightarrow$} \\
\text{[P, A, updatecou(K, $puk$, False), T, t']}}} 
\end{equation}

\section{Functions}
\begin{enumerate}
    \item Function \verb!checkAcc(pkh, C)! checks whether an account $pkh$ exists in C
    \item Function \verb!checkPub(K, pkh)! checks whether the public key of the public key hash $pkh$ is reveled to the blockchain.
    \item Function \verb!checkBan(K, pkh, n, m)! checks whether the balance of the account $pkh$ is greater or equal to $m$ + $n$
    \item Function \verb!checkCou(K, pkh)! checks whether the current counter of an account $phk$ is used
    \item Function \verb!updateSuc(K, pkh, pkh', n, m)! updates the balance and the counter of the account $phk$ and the balance of the account $phk'$, where
    \begin{itemize}
        \item  \verb!< puk, pkh, bal, (n, True) >!  \verb!=>! \\ \verb!< puk, pkh, bal - n - m, (n + 1, False) >!
        \item  \verb!< puk', pkh', bal', cou' >! \verb!=>! \verb!< puk', pkh', bal' + n, cou' >!
    \end{itemize}
    
    \item Function \verb!updateCou(K, puk, b')! updates the counter of the account $phk$, where
    \begin{itemize}
        \item  \verb!< puk, pkh, bal, (n, b) >!  \verb!=>! \verb!< puk, pkh, bal, (n, b') >!
    \end{itemize}
    
    \item Function \verb!checkId(id, S)! checks whether a contract $id$ does not already exist in S
    
    \item Function \verb!checkPrg(code, s)! checks whether the code $code$ are well type and $s$ is well type input 
    
    %\item Function \verb!addContr(S, id, puh, code)! adds a new  contract $< id, puh, code >$  into S
    
    \item Function \verb! generateOph(pkh,pkh', n, m, t)! generates a operation hash

    \item Function \verb!generateHash(S, id, puh, code, t)! generates the public hash of a contract 
     
   % \item Function \verb!addOrig(T,< hash, 0, code, storage >)! add the a new originator $\langle  puh$, 0, $code, storage \rangle $ 
    \item Function \verb!getStorage(code, s)! gets the storage for the code $code$ and the input $s$
\end{enumerate}



\section{Some implementations}
Function \verb!checkAcc(puh, C)! checks whether an account exists and and \verb!checkPuk(puh, K)! checks the revelation of its public key to the blockchain.
\begin{verbatim}
let rec checkAcc puh C =
  match C with
  | 0 -> false
  | < als, pak, puk, pkh' > :: C' ->
    if (puh = puh')  then true 
    else checkAcc (puh, C')
\end{verbatim}

\begin{verbatim}
let rec checkPuk puh K =
  match C with
  | 0 -> false
  | < als, pak, puk, pkh' > :: K' ->
    if (puh = puh') and (puk =/= nil) then true 
    else 5checkPuk (puh, K')
\end{verbatim}

The following functions interact with $\MANAGERS$. 

\begin{verbatim}
let rec checkBal K puk n m =
  match K with
  | 0 -> true
  | < puk', bal, cou > :: K' ->
    if (puk = puk') and (n + m) <= bal then true 
    else checkBal (K', puk, n, m)
\end{verbatim}

\begin{verbatim}
let rec checkPub K puk =
  match K with
  | 0 -> false
  | < puk', bal, cou > :: K' ->
    if (puk = puk') then true 
    else checkExi (K', puk)
\end{verbatim}

\begin{verbatim}
let rec checkCou K puk =
  match K with
  | 0 -> false
  | < puk', bal, cou > :: K' ->
    if (puk = puk') and (cou = T) then true 
    else checkCou (K', puk)
\end{verbatim}

\begin{verbatim}
let rec updateCou K puk =
  match K with
  | 0 -> 0
  | < puk', bal, cou > :: K' ->
    if (puk = puk') then < puk', bal, F > :: K'
    else < puk', bal, cou > :: updateCou (K', puk)
\end{verbatim}

\begin{verbatim}
let rec updateSuc K puk puk' m n =
  match K with
  | 0 -> 0
  | < puk'', bal, cou > :: K' ->
    if (puk = puk'') then < puk'', bal - (n + m), T > 
       :: updateSuc (K', puk, puk', n, m)
    else if (puk' = puk'') then < puk'', bal + n, cou > :: K'
         else  < puk'', bal, cou > 
               ::updateSuc (K', puk, puk', n, m)
\end{verbatim}



\end{document}