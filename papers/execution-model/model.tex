\documentclass[a4paper]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\newtheorem{mydef}{Definition}
\newtheorem{mylemma}{Lemma}
\newtheorem{mytheorem}{Theorem}
\newtheorem{mypro}{Proposition}

\input{macros}

\title{Blockchain System}

\author{}
\institute{}

\date{\today}

\begin{document}
\maketitle


\section{Definitions}
\begin{definition}[Set]
Let $\mathbf{Elt}$ be the set of (concrete) elements. Let $\emptyset$ be an empty set and $\mathbf{e}$ $\in$  $\mathbf{Elt}$. A set of elements is expressed as the following syntax:
\\
$\mathbf{s} :: = \emptyset \mid \mathbf{e} \mid \mathbf{s :: s}$
\end{definition}

\begin{definition}[Account]
An account is a tuple $\langle \ALS, \PAK, \PUK, \PKH \rangle $, where $\ALS$ is the alias of the account, $\PAK$ is its private key, $\PUK$ is its public key and $\PKH$ is its public key hash . 
\end{definition}

\begin{definition}[Contract]
An contract is a tuple $\langle  \ALS, \PUH, \CODE \rangle $, where
$\ALS$ is the alias of the contract, $\PUH$ is its public hash, and
$\CODE$ is the code of the contract. 
\end{definition}

\begin{definition}[Manager]
A manager manages a single account. It is represented by a
tuple $\langle  \PUK, \PKH, \BAL, \COU \rangle $, where  $\PUK$ is the
public key of an account, $\PKH$ is its public key hash, $\BAL$ is its
balance and $\COU$ is its counter whose form is a pair $(n, b)$, where $n$ is a natural number and ${b}$
is a boolean value.  
\end{definition}

\begin{definition}[Contractor]
  A contractor manages a smart contract. It is
  represented by a tuple
  $\langle \PUH, \BAL, \CODE, \STORAGE \rangle $, where $\PUH$ is the
  public key hash of the contract, $\BAL$ is its current balance, $\CODE$ is its
  code, and $\STORAGE$ is its current storage.
\end{definition}

\begin{definition}[Operation]
  Operations are defined by the following grammar:
  \begin{align*}
    \OP &::= \TRANSFER[\STRING]\NTEZ\PKH{\PKH'}\MTEZ
    \\&\mid \ORIGINATE\ID\NTEZ\PKH\CODE\STRING\MTEZ
    % \\&\mid transfer $\mathbf{n}$ from $\PKH$ to  $\PUH$ arg $\mathbf{s}$ fee $\mathbf{m}$
  \end{align*}
%\\$\mid$ register key $\PKH$ as delegate fee $\mathbf{m}$ 
%\\$\mid$ set delegate for $\PKH$ to $\PKH'$  fee $\mathbf{m}$ 
%\\$\mid$ withdraw delegate from $\PKH$ fee $\mathbf{m}$ 
\end{definition}

\begin{definition}[Query]
Queries are defined by the following grammar:
\begin{align*}
  \QRY & ::= \GETBALANCE {\PKH / \PUH}
  \\&\mid \GETSTATUS\OPH
  \\&\mid \GETSTORAGE\PUH
  \\&\mid \GETCODE\PUH 
  \\&\mid \GETPUBLICKEY\PKH
  \\&\mid \GETCOUNTER\PKH
\end{align*}

%$\mid$ get delegate for $\PKH$
%\\$\mid$ waiting for $\OPH$ to be included in $\mathbf{m}$ blocks
%\\$\mid$ get timestamp
%\\$\mid$ get contracts
%\\$\mid$ show contracts for $\PKH$
%\\$\mid$ get balance for $\PKH$

\end{definition}
 \begin{definition}[State of a node]
   The state of a node is a tuple
   $[\ACCOUNTS, \OPERATIONS, \CONTRACTS]$ where $\ACCOUNTS$ is a set of accounts,
   $\OPERATIONS$ a set of operations, and $\CONTRACTS$  a set of contracts. 
\end{definition}

When an operation is injected in a node, it enters a \emph{pending pool}
(and is called a pending operation). 
 \begin{definition}[Pending operation]
A pending operation is a tuple  $\langle  \OP, \OPH, \TIME
\rangle $, where $\OP$ is an operation, $\OPH$ is the operation hash
and $\TIME$ is the time when the operation was injected. 
\end{definition}
After some time, a pending operation may be included in the blockchain as an accepted operation.
%Let \textit{P} is the set of pending operations.
 \begin{definition}[Accepted operation]
An accepted operation  is a tuple $\langle  \OP, \OPH, \TIME \rangle
$, where $\OP$ is an operation, $\OPH$ is the operation hash and
$\TIME$ is the time when it was included in the blockchain. 
\end{definition}

\begin{definition}[Blockchain]
  The state of a blockchain is a tuple
  $[\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$ where
  $\PENDING$ is a set of pending operations,  $\ACCEPTED$ is a set
  of accepted operations, $\MANAGERS$ is a set of managers,
  $\CONTRACTORS$ is a set of contractors, and $\TIME$ is the current time of the blockchain. 
\end{definition}

\begin{definition}[Blockchain system]
A blockchain system is a pair
$\langle \mathbf{M}, \mathbf{B} \rangle$ where
\begin{enumerate}
\item $\mathbf{M} = [\ACCOUNTS, \OPERATIONS, \CONTRACTS]$ is the state of a node, and
\item $\mathbf{B} = [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$ is the state of a blockchain 
  such that $\forall c \in \ACCOUNTS \implies \exists k\in \MANAGERS, k.pkh = c.pkh$
  and $\forall s \in \CONTRACTS \implies \exists p \in \CONTRACTORS, s.puh = p.puh$.
\end{enumerate}
\end{definition}

\section{Rules}
\subsection{Transfers}

Rule 1 [proposal]:

\begin{equation}{}
  \frac{
    \text{checkAcc($pkh$, \ACCOUNTS)}
  }{
    \parbox{4.5in}{\text{$\langle[\ACCOUNTS, \OPERATIONS,
        \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS,
        \TIME]\rangle \rightarrow$} \\
      \text{$\langle [\ACCOUNTS, (\TRANSFER\NTEZ\PKH{\PKH'}\MTEZ)$ ::
        \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS,
        \CONTRACTORS, \TIME]$\rangle$}}}  
\end{equation}
~\\
~\\
Rule 2 [injected]:

\begin{equation}{}
\frac{\text{checkBan(\MANAGERS, $pkh, n, m$) $\wedge$ checkCou(\MANAGERS, $pkh$) $\wedge$ checkPub(\MANAGERS, $pkh'$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow$}\\
\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [($<$ transfer $n$ from $puk$ to $puk'$ fee $m$, generateOph($pkh$, }\\
\text{$pkh', n, m$, \TIME), \TIME $>$) :: \PENDING, \ACCEPTED, updateCou(\MANAGERS, $pkh$, True), \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 3 [rejected of counter]:

\begin{equation}{}
\frac{\text{$\neg$ checkCou(\MANAGERS, $pkh$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow$ }\\
\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 4 [rejected of balance]:

\begin{equation}{}
\frac{\text{$\neg$ checkBan(\MANAGERS, $pkh, m, n$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow$ }\\
\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 5 [rejected of public key]:

\begin{equation}{}
\frac{\text{$\neg$ checkPub(\MANAGERS, $pkh'$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer $n$ from $pkh$ to $pkh'$ fee $m$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow$ }\\
\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 6 [included]:
\begin{equation}{}
\frac{}{\parbox{4.2in}{\text{[$<$ transfer $n$ from $puk$ to  $puk'$ fee $m$, oph, \TIME $>$ :: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME' ] $\rightarrow$ } \\
 \text{[\PENDING, $<$ transfer $n$ from  $puk$ to $puk'$ fee $m$, oph, \TIME' $>$ :: \ACCEPTED, updateSucc(\MANAGERS, } \\
\text{$puk, puk', n, m$), \CONTRACTORS, \TIME' + 1]}}} 
\end{equation}
~\\
Rule 7 [timeout]:
\begin{equation}{}
\frac{\text{\TIME' - \TIME $\ge$ 60}}{\parbox{4.2in}{\text{[$<$ transfer $n$ from $puk$ to  $puk'$ fee $m$, oph, \TIME $>$ :: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME' ] $\rightarrow$} \\
 \hspace*{0cm} \text{[\PENDING, \ACCEPTED, updateCou(\MANAGERS, $puk$, False), \CONTRACTORS, \TIME']}}} 
\end{equation}

\subsection{Smart Contracts}
~\\
A. Originate
~\\
~\\
Rule 1 [proposal]:

\begin{equation}{}
\frac{\text{checkAcc($pkh$, \ACCOUNTS) $\wedge$ checkId($id$, \CONTRACTS)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow \langle$[\ACCOUNTS, (originate contract ${id}$ transferring} \\
  \text{${n}$ from ${pkh}$} \text{running ${code}$ init ${s}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 2 [injected]:

\begin{equation}{}
\frac{\text{checkBan(\MANAGERS, $pkh, n, m$) $\wedge$ checkCou(\MANAGERS, $pkh$) $\wedge$ \text{checkPrg($code, s$)}}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{ :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME] $\rangle \rightarrow \langle$ [\ACCOUNTS, \OPERATIONS, \CONTRACTS],} \text{[(originate contract ${id}$ transferring ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{:: \PENDING, \ACCEPTED, updateCou(\MANAGERS, $pkh$, True), \CONTRACTORS, \TIME] $\rangle$}}} 
\end{equation}
~\\
~\\
Rule 3 [rejected of code]:

\begin{equation}{}
\frac{\text{$\neg$ checkPrg($code, s$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{:: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow \langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS],} \text{[\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 4 [rejected of counter]:

\begin{equation}{}
\frac{\text{$\neg$ checkCou(\MANAGERS, $pkh$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$))} \text{:: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow \langle$ [\ACCOUNTS, \OPERATIONS, \CONTRACTS],} \text{[\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 5 [rejected of balance]:

\begin{equation}{}
\frac{\text{$\neg$ checkBan(\MANAGERS, $pkh, n, m$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$)} \text{:: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow \langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS],} \text{[\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 6 [included]:
\begin{equation}{}
\frac{}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [$<$ (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running } \\
\text{${code}$ init ${s}$), \TIME $>$ :: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME' ]$\rangle \rightarrow \langle$[\ACCOUNTS, \OPERATIONS,($< id$, } \\
\text{generateHash($id, code, s$, \TIME'), $code >$ :: \CONTRACTS)], [\PENDING, $<$ (originate contract ${id}$ } \\
\text{transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$), \TIME' $>$ :: \ACCEPTED, updateSucc(\MANAGERS, } \\
\text{$puk, n, m$), ($<$ generateHash($id, code, s$, \TIME'), $n, code$, } \\
 \text{getStorage($code, s$) $>$) :: \CONTRACTORS), \TIME' + 1]$\rangle$}}} 
\end{equation}
~\\
Rule 7 [timeout]:
\begin{equation}{}
\frac{\text{\TIME' - \TIME $\ge$ 60}}{\parbox{4.2in}{\text{[$<$ (originate contract ${id}$ transferring  ${n}$ from ${pkh}$ running ${code}$ init ${s}$) $>$ } \\
\text{:: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME' ] $\rightarrow$[\PENDING, \ACCEPTED, updateCou(\MANAGERS, $puk$, False), \CONTRACTORS, \TIME']}}} 
\end{equation}
~\\
~\\
B. \textbf{Transfer}
\\
~\\
Rule 1 [proposal]:

\begin{equation}{}
\frac{\text{checkAcc($pkh$, \ACCOUNTS)  }}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle \rightarrow \langle$[\ACCOUNTS, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ }  \\
\text{fee ${m}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 2 [injected]:

\begin{equation}{}
\frac{\text{checkBan(\MANAGERS, $pkh, n, m$) $\wedge$ checkCou(\MANAGERS, $pkh$) $\wedge$ checkPuh(\CONTRACTORS, $puh$)}
\\
\text{ $\wedge$ checkArg(\CONTRACTORS, $puh, s$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}\\
\text{$\rightarrow$  $\langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [($<$ (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$), }\\
 \text{generateOph($pkh, puh, s, n, m$, \TIME), \TIME $>$) :: \PENDING, \ACCEPTED, updateCou(\MANAGERS, $pkh$, True), }\\
\text{\CONTRACTORS, \TIME] $\rangle$}}} 
\end{equation}
~\\
~\\
Rule 3 [rejected of counter]:

\begin{equation}{}
\frac{\text{$\neg$ checkCou(\MANAGERS, $pkh$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$  }\\
\text{$\rightarrow \langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 4 [rejected of balance]:

\begin{equation}{}
\frac{\text{$\neg$ checkBan(\MANAGERS, $pkh, n, m$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$ }\\
\text{$\rightarrow \langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 5 [rejected of public hash]:

\begin{equation}{}
\frac{\text{$\neg$ checkPuh(\CONTRACTORS, $puh$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$ }\\
\text{$\rightarrow \langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 6 [rejected of argument]:

\begin{equation}{}
\frac{\text{$\neg$ checkArg(\CONTRACTORS, $puh, s$)}}{\parbox{4.2in}{\text{$\langle$[\ACCOUNTS, (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$) :: \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}\\
\text{$\rightarrow \langle$[\ACCOUNTS, \OPERATIONS, \CONTRACTS], [\PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME]$\rangle$}}} 
\end{equation}
~\\
~\\
Rule 7 [included]:

\begin{equation}
\frac{}{
  \begin{array}{l}
\text{[$<$ transfer $n$ from $puk$ to  $puh$ fee $m$, oph, \TIME $>$ :: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME' ] $\rightarrow$ } \\
\text{[\PENDING, $<$ (transfer ${n}$ from ${pkh}$ to  ${puh}$ arg ${s}$ fee ${m}$), oph, \TIME' $>$ :: \ACCEPTED, } \\
\text{updateSucc(\MANAGERS, puk, '', $n, m$), updateConstr(\CONTRACTORS, $puh, n$,
  $s$), $\TIME' + 1$]}
  \end{array}
}\label{eq:1}
\end{equation}
~\\
Rule 8 [timeout]:
\begin{equation}{}
\frac{\text{\TIME' - \TIME $\ge$ 60}}{\parbox{4.2in}{\text{[transfer $n$ from $puk$ to  $puh$ fee $m$, \TIME $>$ :: \PENDING, \ACCEPTED, \MANAGERS, \CONTRACTORS, \TIME' ] $\rightarrow$} \\
\text{[\PENDING, \ACCEPTED, updatecou(\MANAGERS, $puk$, False), \CONTRACTORS, \TIME']}}} 
\end{equation}

\section{Functions}
\begin{enumerate}
    \item Function \verb!checkAcc(pkh, C)! checks whether an account $pkh$ exists in \ACCOUNTS
    \item Function \verb!checkPub(K, pkh)! checks whether the public key of the public key hash $pkh$ is reveled to the blockchain.
    \item Function \verb!checkBan(K, pkh, n, m)! checks whether the balance of the account $pkh$ is greater or equal to $m$ + $n$
    \item Function \verb!checkCou(K, pkh)! checks whether the current counter of an account $phk$ is used
    \item Function \verb!updateSuc(K, pkh, pkh', n, m)! updates the balance and the counter of the account $phk$ and the balance of the account $phk'$, where
    \begin{itemize}
        \item  \verb!< puk, pkh, bal, (n, True) >!  \verb!=>! \\ \verb!< puk, pkh, bal - n - m, (n + 1, False) >!
        \item  \verb!< puk', pkh', bal', cou' >! \verb!=>! \verb!< puk', pkh', bal' + n, cou' >!
    \end{itemize}
    
    \item Function \verb!updateCou(K, puk, b')! updates the counter of the account $phk$, where
    \begin{itemize}
        \item  \verb!< puk, pkh, bal, (n, b) >!  \verb!=>! \verb!< puk, pkh, bal, (n, b') >!
    \end{itemize}
    
    \item Function \verb!checkId(id, S)! checks whether a contract $id$ does not already exist in \CONTRACTS
    
    \item Function \verb!checkPrg(code, s)! checks whether the code $code$ are well type and $s$ is well type input 
    
    %\item Function \verb!addContr(S, id, puh, code)! adds a new  contract $< id, puh, code >$  into \CONTRACTS
    
    \item Function \verb! generateOph(pkh,pkh', n, m, t)! generates a operation hash

    \item Function \verb!generateHash(S, id, puh, code, t)! generates the public hash of a contract 
     
   % \item Function \verb!addOrig(T,< hash, 0, code, storage >)! add the a new originator $\langle  puh$, 0, $code, storage \rangle $ 
    \item Function \verb!getStorage(code, s)! gets the storage for the code $code$ and the input $s$
\end{enumerate}



\section{Some implementations}
Function \verb!checkAcc(puh, C)! checks whether an account exists and and \verb!checkPuk(puh, K)! checks the revelation of its public key to the blockchain.
\begin{verbatim}
let rec checkAcc puh C =
  match C with
  | 0 -> false
  | < als, pak, puk, pkh' > :: C' ->
    if (puh = puh')  then true 
    else checkAcc (puh, C')
\end{verbatim}

\begin{verbatim}
let rec checkPuk puh K =
  match C with
  | 0 -> false
  | < als, pak, puk, pkh' > :: K' ->
    if (puh = puh') and (puk =/= nil) then true 
    else 5checkPuk (puh, K')
\end{verbatim}

The following functions interact with $\MANAGERS$. 

\begin{verbatim}
let rec checkBal K puk n m =
  match K with
  | 0 -> true
  | < puk', bal, cou > :: K' ->
    if (puk = puk') and (n + m) <= bal then true 
    else checkBal (K', puk, n, m)
\end{verbatim}

\begin{verbatim}
let rec checkPub K puk =
  match K with
  | 0 -> false
  | < puk', bal, cou > :: K' ->
    if (puk = puk') then true 
    else checkExi (K', puk)
\end{verbatim}

\begin{verbatim}
let rec checkCou K puk =
  match K with
  | 0 -> false
  | < puk', bal, cou > :: K' ->
    if (puk = puk') and (cou = T) then true 
    else checkCou (K', puk)
\end{verbatim}

\begin{verbatim}
let rec updateCou K puk =
  match K with
  | 0 -> 0
  | < puk', bal, cou > :: K' ->
    if (puk = puk') then < puk', bal, F > :: K'
    else < puk', bal, cou > :: updateCou (K', puk)
\end{verbatim}

\begin{verbatim}
let rec updateSuc K puk puk' m n =
  match K with
  | 0 -> 0
  | < puk'', bal, cou > :: K' ->
    if (puk = puk'') then < puk'', bal - (n + m), T > 
       :: updateSuc (K', puk, puk', n, m)
    else if (puk' = puk'') then < puk'', bal + n, cou > :: K'
         else  < puk'', bal, cou > 
               ::updateSuc (K', puk, puk', n, m)
\end{verbatim}



\end{document}