\documentclass[a4paper]{llncs}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{mathpartir}
\usepackage{fixme}
\usepackage{listings}

\lstset{
  language=caml,
  morekeywords={contract,sig,entrypoint,module,raises,val},
  % predefined types
  classoffset=1,
  morekeywords={nat,int,unit,string},
  keywordstyle=\color{blue},
  classoffset=2,
  morekeywords={Left,Right},
  keywordstyle=\color{magenta},
  backgroundcolor=\color{brown!20}
}

\lstdefinelanguage{michelson}{
  % basicstyle=\ttfamily{},
  classoffset=0,
  morekeywords={parameter,storage,code},
  keywordstyle=\bfseries, 
  % predefined types
  classoffset=1,
  morekeywords={nat,int,unit,string,union,pair,option,address},
  keywordstyle=\color{blue},
  classoffset=2,
  morekeywords={CAR,CDR,CONS,DUP,EQ,FAILWITH,IF,IF_LEFT,LE,LEFT,NIL,POP,PUSH,RIGHT,SENDER,SUB},
  keywordstyle=\color{magenta},
  backgroundcolor=\color{pink!20}
}

\title{Contract Modules}
\author{Peter Thiemann}
\institute{}

\date{\today}

\begin{document}
\maketitle
\pagestyle{plain}

\section{Motivation}
\label{sec:motivation}


Consider this Michelson code fragment:
\begin{lstlisting}[language=michelson,caption={Michelson code example},label={lst:code-example}]
parameter (union (int %bid_for_auction)
                 (unit %close_auction));
storage address;
code { DUP; CAR; 
       IF_LEFT {
       # %bid_for_auction
        DUP; PUSH int 10000; SUB; LE;
        IF { FAILWITH; } {} # fails with argument value
        # ...
        { PUSH string "closed"; FAILWITH; }
        # ...
        { PUSH string "bid too low"; FAILWITH; }
        # ...
        { PUSH int 42; FAILWITH; }
        # ...
       }
       {
       # %close_auction
         POP; CDR; SENDER; EQ;
         IF {} { PUSH string "not owner"; FAILWITH; }
         # ...
       }
     }
\end{lstlisting}

Here is a contract type that describes / specifies the above Michelson code.
\begin{lstlisting}[caption={Contract module example},label={lst:contract-module-example}]
contract type MyContract = sig
  entrypoint %bid_for_auction (_ : int) 
  raises "closed" as closed       (** auction closed*)
       | "bid too low" as too_low (** bid received is too low *)
       | 42 as the_answer         (** failwith received argument 42 *)
       | (_ : int) as failedwith  (** failwith received an integer arg *)

  entrypoint %close_auction (_ : unit)
  raises "not owner"         (** caller cannot close the auction *)
end
\end{lstlisting}

Alternatively and equivalently, the contracts can be specified using
patterns on the default entrypoint.

\begin{lstlisting}
...
  entrypoint bid_for_auction (Left (_ : int))
...
  entrypoint close_auction (Right (_ : unit))
\end{lstlisting}

The contract module is compiled to an OCaml module which provides a typed API to the
contract. It includes the documentation comments from the contract
module. Internally, the typed API builds on the untyped API developed
by us. 

\begin{lstlisting}
module type MyContract =
sig
  type bid_for_auction_errors = 
     | closed       (** auction closed*)
     | too_low      (** bid received is too low *)
     | the_answer   (** failwith received argument 42 *)
     | failedwith of int (** failwith received an integer arg *)

  val bid_for_auction
    : int -> (status, bid_for_auction_errors) Tezos.monad

  type close_auction_errors = 
     | not_owner    (** caller cannot close the auction *)

  val close_auction
    : unit -> (status, close_auction_errors) Tezos.monad
end
\end{lstlisting}

\begin{itemize}
\item The type \lstinline/Tezos.monad/ is defined by the underlying
  API. The untyped API uses a type \lstinline/Answer.t/. The exact
  relationship is TBD.
\item Error reporting assumes that the monad returns a sum type. But
  things could be handled differently (for the
  \lstinline/close_auction/entrypoint): by an error continuation of
  type \lstinline/close_auction_errors -> Answer.t/ or by
  raising an exception that encapsulates the error type:
\begin{lstlisting}
exception Close_Auction_Exn of close_auction_errors
\end{lstlisting}
\end{itemize}

If the contract source is available, then an extended type checker verifies that the entry points
exist and that all failures that may arise during contract execution from a particular entry point
are covered by the listed cases.

If the contract source is unavailable, then we can obtain it from the
contract's public hash using an API call. In that case, we would
specify the hash in the contract header as follows
\begin{lstlisting}
contract type MyContract "KT1ThEdxfUcWUwqsdergy..." = sig
...
\end{lstlisting}

We propose to deal with the remaining errors (i.e., built-in errors
and failures that are not specifed) like Java's unchecked
exceptions. That is, the API function throws an exception.


\clearpage
\section{Tools}
\label{sec:tools}

An extended type checker collects information about explicit failures along execution paths
starting from each possible entry point. This checker will be able to
verify the contract module specification in
\ref{lst:contract-module-example} against the Michelson code in
\ref{lst:code-example}. We may also wish to provide an entry point so
that the checker only gathers information for that entry point. This alternative may be interesting if there
is an entry point taking a parameter of sum type, rather than using all injections to distinguish
between entry points.

The recommended technology for the type checker is symbolic
execution. In this framework, it would also 
be possible to specify further invariants about the inputs and place them into the contract
module. Essentially, every formula that an SMT solver can deal with
should be fine, although a first version of the symbolic executor
could work without using SMT.

A starting point for the implementation could be the module \lstinline/Tezos_micheline/, which has a
Michelson parser. 

\end{document}
