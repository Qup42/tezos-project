\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{url}

\usepackage{xcolor}
\usepackage{tcolorbox}
\tcbuselibrary{breakable}

\newenvironment{changethis}{%
  \begin{tcolorbox}[breakable,notitle,boxrule=0pt,colback=blue!20,colframe=blue!20]}{%
  \end{tcolorbox}}

\input{solidity-highlighting}

\title{Expos\'{e} Master Thesis\\
  Checking Assertions for Smart Contracts}
\author{Peter Thiemann}
\begin{document}
\maketitle{}

\section{Introduction}
\label{sec:introduction}

Every computation performed by a Smart Contract on the blockchain generates costs. Each
unit of computation and each unit of storage used by an algorithm must be paid for. To
avoid this cost, an application might perform some computation away from the blockchain
(i.e., off-chain) and submit the result as a parameter to a contract on the
blockchain. Typically, such a computation asserts certain properties of the 
submitted parameter. 

However, this approach raises the issue that on the one hand the contract should take
advantage of the offchain computation and assume that the submitted parameter has
these properties, but on the other hand, the off-chain computation might be wrong and
submit illegal parameters. So, we need a mechanism that checks the validity of the
assumptions before the contract starts executing.

As an example, consider a contract that takes a prime number as a parameter.
\begin{lstlisting}[numbers=none]
contract Example {
  function (int p) public {
    // assume p is prime
    ...
  }
}
\end{lstlisting}
This assumption can be expressed with an explicit assertion in predicate logic.
\begin{displaymath}
  (\forall n) (2 \le n \le \sqrt p) \Rightarrow (p \mathbin{\%} n) \ne 0
\end{displaymath}
To test the validity of this assumption requires a loop in the contract, but the test would take
$O(\sqrt p)$ time (assuming constant time for computing the remainder) and thus produce extra cost
linear in $\sqrt p$ accordingly. 
However, we could do better by recruiting the validators of the contract for a distributed
effort to find a counterexample. To this end, we consider the negation of the assertion.
\begin{gather}\label{eq:4}
  (\exists n) (2 \le n \le \sqrt p) \wedge (p \mathbin{\%} n) = 0
\end{gather}
This assertion can be checked pointwise by having each validator independently choose a
random $n$ fulfilling $2 \le n \le 
\sqrt p$ and checking whether $(p \mathbin{\%} n) = 0$. If the remainder is $0$, the
validator found a counterexample, posts its veto to the P2P net, and stops further
exection. Otherwise, it accepts $p$ knowing that other points will be checked by other
validators.

In this scenario, each validator only needs to be paid to generate a random number and
perform a division, which is a constant cost independent from $p$.

Of course, this validation is only probabilistic, so its effectiveness depends on the
number of validators. One could say that the community of validators implements a Bloom
filter for the set of primes: if a value $p$ is rejected it is certainly not a prime (because
there exists a counterexample); if a value $p$ is not rejected it is prime with a
probability that depends on $p$ and the number of validators. 

As another example, consider a contract that takes a sorted array of integers.
\begin{lstlisting}[numbers=none]
contract Sorted {
  function find (int[50] a, int v) public {
    // assume a is sorted
  }
}
\end{lstlisting}
The explicit assertion would be
\begin{gather}\label{eq:1}
  (\forall k) (0\le k <49) \Rightarrow a[k] \le a[k+1]
\end{gather}
While we can check this contract in $O(1)$ time, the constant factor is big! So we
consider its negation.
\begin{displaymath}
  (\exists k) (0\le k <49) \wedge a[k] > a[k+1]
\end{displaymath}
Again, we can have every validator generate a random number $k$. If the
condition is true for such $k$, then the validator found a counterexample for the sortedness
of the array. Otherwise, the validator relies on the other validators to check
different numbers.

To obtain an estimate of the number of validators needed to find a counterexample with
high probibility, 
let's assume the array is unsorted only at position $0$, the size of the array is $n$,
and the number of validators is $m$. Each validator independently has a probability of
$1/n$ to detect the problem and thus probability $\frac{n-1} n$ not to detect the
problem. Hence, if we assume that each $k$ is chosen independenty from a uniform distribution,
the probability that no validator checks at
position $0$ converges to $0$ as the number of validators approaches infinity.
\begin{displaymath}
  \lim_{m\to\infty}\frac{(n-1)^m}{n^m}
  = \lim_{m\to\infty} \left(\frac{n-1}{n}\right)^m
  = 0
\end{displaymath}

\section{Further Thoughts}
\label{sec:further-thoughts}

There may be an alternative way of implementing this scheme without modifying the
protocol, but instead adding instructions to the virtual machine. One instruction would
generate a random number (EVM uses 512 bit unsigned integer IIRC), the other would
raise an overriding failure. Ideally, once a counterexample has been found, this
counterexample is broadcast to the network where it can be verified by further nodes.
But this broadcast and the reaction to this broadcast requires an update of the
protocol: all receivers of the broadcast will check the counterexample and revert the
transaction. This probably means that a transaction using this feature has to wait for
a couple of cycles in the transaction pool until the node feels safe to include the
transaction in a block.

\begin{changethis}
  Tezos specific remarks: here the number of validators is really small compared to
  Bitcoin or Ethereum
  \begin{itemize}
  \item maybe we need to propose and validate the same block multiple times before it
    gets accepted. E.g, a transaction containing this feature is only accepted if it is
    revalidated $n$ times.
  \item Extra validators only for this kind of transaction.
  \end{itemize}
\end{changethis}
This approach poses the danger of a DOS attack. Someone could post a false
counterexample, which does not really lead to a failure. If everyone switches to check
this proposed counterexample instead of generating a random number, then the real
problem may remain hidden. So, there has to be a component in the protocol that
penalizes someone who broadcasts a false counterexample. Moreover, not all validators
should switch to recheck a proposed counterexample; or they could check it in addition
to their own random check.

The interesting assertion formulas are those with prenex universal
quantification. Negation turns them into prenex existential quantification. But it
would be ineffective to generate a random integer and then check that it falls in the
interesting range (e.g., $2\le n \le \sqrt p$ and $0\le k< n-1$). Rather, the formula
needs to be analzed and the random generator should be restricted to only generate
interesting values. 

It would not be significantly more expensive to have every validator perform a
predetermined finite number of checks for each assertion.

What is the minimum number $m$ of validators such that the probability of spotting an
error is less than a given threshold $q$?

Instead of using random numbers, is there a way to coordinate a systematic exploration
of the iteration space? (Is this at all necessary?)

One could also check properties of the values stored by the contract.

Connections to random testing?

In Dafny (citation) \url{https://rise4fun.com/Dafny/tutorialcontent/guide#h29} you can
write
\begin{lstlisting}
forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]
\end{lstlisting}
to express that an array is sorted. This predicate is equivalent to the one given in
\eqref{eq:1}, but it might be more challenging to test. Its negation is
\begin{gather}
  \label{eq:2}
  (\exists j, k ) (0\le j< k < |a|) \wedge a[j] > a[k]
\end{gather}
So we'd have to generate two random numbers $j$ and $k$ such that the condition $0 \le
j < k < |a|$ is fulfilled.


Another condition that might be tested on an array is the heap condition
\begin{gather}
  \label{eq:3}
  (\forall i) (0 \le i < \lfloor|a|/2\rfloor) \Rightarrow a[i] \le a[2i+1] \wedge (2i+2
  < |a| \Rightarrow a[i] \le a[2i+2])
\end{gather}

\section{Tasks}
\label{sec:tasks}

\subsection{Offline Design}
\label{sec:offline-design}

\begin{itemize}
\item Identify a set of logical formulas that are amenable to the kind of checking
  described above.
\item Formalize the cost incurred by checking a formula.
\item Extend the contract language with assertions stating these logical formulas.
\item Implement the transformation: negation of the formula followed by transformation
  of existentials to picking a random value.

  The random choice should be performed in a ``clever'' way that does not waste too
  much effort. For a wasteful example, consider~\eqref{eq:2}:
  \begin{gather*}
    (\exists j, k ) (0\le j< k < |a|) \wedge a[j] > a[k]
  \end{gather*}
  In the worst case, we would generate two arbitrary non-negative integers $j$ and $k$
  and then check the predicate. However, the predicate $(0\le j< k < |a|)$ will fail
  almost always, so we do not get to test the interesting part of the predicate
  $a[j]>a[k]$.

  In the best case, the generated testing code would be equivalent to the following code fragment
  in Python
\begin{lstlisting}[language=Python]
def exists_counterexample (a : list) -> bool:
  if len(a) < 2: return False
  j = random.randint (0, len(a) - 2)
  k = random.randint (j+1, len(a) - 1)
  return a[j] > a[k]
\end{lstlisting}

  As another, simpler example consider~\eqref{eq:4} (checking for prime numbers)
\begin{lstlisting}[language=Python]
def exists_counterexample (p : int) -> bool:
  r = math.isqrt (p)
  if r < 2: return False
  n = random.randint (2, r)
  return (p % n) == 0
\end{lstlisting}

  Observe that in each case there is a test to eliminate trivial cases, which avoids
  illegal invocations of \lstinline/randint/.
\item Each test function should come with a formula that gives an estimate of
  its effectiveness, i.e., how many times do we have to run the test to find a
  counterexample with a given probability $p$. Ideally, the formula returns a lower
  bound on the number of tests for any $p$.
\end{itemize}

\subsection{Protocol Design}
\label{sec:protocol-design}


\end{document}

